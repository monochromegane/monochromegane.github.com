<!doctype html><html>
<head>
<meta name=generator content="Hugo 0.91.2">
<meta charset=utf-8>
<meta name=viewport content="width=device-width">
<meta name=author content>
<title>THINKING MEGANE</title>
<meta name=twitter:card content="summary">
<meta name=twitter:site content="@monochromegane">
<meta property="og:description" content="THINKING MEGANE">
<meta property="og:title" content="THINKING MEGANE">
<meta property="og:url" content="https://blog.monochromegane.com/">
<meta property="og:image" content="https://blog.monochromegane.com/images/ogp.png">
<link rel=stylesheet href=/css/reset.css>
<link rel=stylesheet href="//fonts.googleapis.com/css?family=Source+Code+Pro" type=text/css>
<link rel=stylesheet href="//fonts.googleapis.com/css?family=Montserrat" type=text/css>
<link rel=stylesheet href=//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css>
<link rel=stylesheet href=//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/styles/ir_black.min.css>
<link rel=stylesheet href=/css/text.css>
<link rel=stylesheet href=/css/color.css>
<link rel=stylesheet href=/css/layout.css>
<link rel=apple-touch-icon-precomposed sizes=57x57 href=/images/apple-touch-icon-57-precomposed.png>
<link rel=apple-touch-icon-precomposed sizes=114x114 href=/images/apple-touch-icon-114-precomposed.png>
<link rel=apple-touch-icon-precomposed sizes=72x72 href=/images/apple-touch-icon-72-precomposed.png>
<link rel=apple-touch-icon-precomposed sizes=144x144 href=/images/apple-touch-icon-144-precomposed.png>
<link rel="shortcut icon" href=/images/favicon.ico>
<link rel=canonical href=https://blog.monochromegane.com/>
<link href=https://blog.monochromegane.com/index.xml rel=alternate type=application/rss+xml title="THINKING MEGANE">
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.9/MathJax.js?config=TeX-MML-AM_CHTML" async>MathJax.Hub.Config({HTML:["input/TeX","output/HTML-CSS"],TeX:{Macros:{bm:["\\boldsymbol{#1}",1],argmax:["\\mathop{\\rm arg\\,max}\\limits"],argmin:["\\mathop{\\rm arg\\,min}\\limits"]},extensions:["AMSmath.js","AMSsymbols.js"],equationNumbers:{autoNumber:"AMS"}},extensions:["tex2jax.js"],jax:["input/TeX","output/HTML-CSS"],tex2jax:{inlineMath:[['$','$'],["\\(","\\)"]],displayMath:[['$$','$$'],["\\[","\\]"]],processEscapes:!0},"HTML-CSS":{availableFonts:["TeX"],linebreaks:{automatic:!0}}})</script>
</head>
<body>
<div class=header>
<header>
<h1 class=logo><a href=https://blog.monochromegane.com>THINKING MEGANE</a></h1>
<nav>
<ul class=menu>
<li><a href=/self-introduction/>Home</a></li>
<li><a href=/post/>Archives</a></li>
<li><a href=/diary/>Diary</a></li>
<li><a href=http://thinking-megane.blogspot.jp/>Old Blog</a></li>
</ul>
</nav>
</header>
</div>
<div class=container>
<div class=posts>
<article>
<div class=post>
<header>
<h1><a href=https://blog.monochromegane.com/blog/2022/09/11/kernel-ridge-regression/>カーネルリッジ回帰 入門</a></h1>
<time><div class=day><i class="fa fa-calendar-o day-icon"></i>2022-09-11</div></time>
</header>
<div class=post-inner>
<p>基底関数を用いた線形回帰モデルのように入力に非線形な変換を施してモデルの表現力の向上を図る手法では、以下の2つの問題が発生する。</p>
<ol>
<li>特徴ベクトルの次元数の増加に伴う計算量の増加</li>
<li>予測に有用な基底関数の選定</li>
</ol>
<p>カーネルリッジ回帰は、カーネル関数を用いて上記の課題を解決する。
このエントリは、このカーネルリッジ回帰を最初に学んだ際の内容を自分なりにまとめたものである。</p>
<p>以下では、はじめに、記法の整理を兼ねて基本的な線形回帰モデルを説明する。
次に、カーネル法を用いた線形回帰であるカーネルリッジ回帰の説明を通して上記の課題の解決アプローチを学ぶ。
最後に、カーネル法における計算量の課題を解決するためのアプローチである、Random Fourier Featuresも紹介する。</p>
<h2 id=1-線形回帰モデル>1. 線形回帰モデル</h2>
<p>線形回帰モデルの問題設定と解法について述べる。
いま、$N$個の入力$X=(\boldsymbol{x}_1,\ldots,\boldsymbol{x}_N)^{\top} \in \mathbb{R}^{N \times D}$と出力$\boldsymbol{y}=(y_1,\ldots,y_N)^{\top} \in \mathbb{R}^{N}$が与えられている。
このとき、$y$は$\boldsymbol{x}$を入力とした線形回帰モデル$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$の出力として得られると仮定する。
ここで、$\boldsymbol{\phi}(\boldsymbol{x}) = (\phi_1(\boldsymbol{x}),\ldots,\phi_F(\boldsymbol{x}))^{\top} \in \mathbb{R}^{F}$は$F$個の基底関数$\phi: \mathbb{R}^{D} \rightarrow \mathbb{R}$からなる特徴ベクトル、$\boldsymbol{w} \in \mathbb{R}^{F}$はこれに対応する係数ベクトルである。
このとき、この係数ベクトル$\boldsymbol{w}$を推定することが本問題の目標である。</p>
<p>推定には最小二乗法を用いる。
なお、実用上は汎化性能の考慮から正則化を施すことが多いと思われるので、これを適用した<strong>リッジ回帰</strong>を行う。
すなわち、$\Phi = (\boldsymbol{\phi}(\boldsymbol{x}_1),\ldots,\boldsymbol{\phi}(\boldsymbol{x}_N))^{\top} \in \mathbb{R}^{N \times F}$としたとき、学習データに対する誤差の二乗和（に正則化項を加えたもの）$E(\boldsymbol{w}) = \| \Phi \boldsymbol{w} - \boldsymbol{y} \|^2 + \lambda \| \boldsymbol{w} \|^2$を最小化する$\boldsymbol{w}$を求める。</p>
<p>このために、まず$E(\boldsymbol{w})$を次のように整理する。</p>
<p>\begin{align}
\begin{split}
E(\boldsymbol{w}) &= (\Phi \boldsymbol{w} - \boldsymbol{y})^{\top}(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w} \\
&= ((\Phi \boldsymbol{w})^{\top} - \boldsymbol{y}^{\top})(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&= ( \boldsymbol{w}^{\top}\Phi^{\top} - \boldsymbol{y}^{\top})(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} - \boldsymbol{y}^{\top}\Phi\boldsymbol{w} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - 2\boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}.
\label{eq:ew}
\end{split}
\end{align}</p>
<p>整理には、行列の定理$(AB)^{\top}=B^{\top}A^{\top}$と、スカラーは転置しても値が同じであることを利用した（$\boldsymbol{y}^{\top}\Phi\boldsymbol{w} = (\boldsymbol{y}^{\top}\Phi\boldsymbol{w})^{\top} = \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y}$）。</p>
<p>次に、$E(\boldsymbol{w})$を最小化する$\boldsymbol{w}$を求めるために$\boldsymbol{w}$について偏微分して0とおく。</p>
<p>\begin{align}
\frac{\partial E(\boldsymbol{w})}{\partial \boldsymbol{w}} &= 2\Phi^{\top}\Phi\boldsymbol{w} -2\Phi^{\top}\boldsymbol{y} + 0 + 2\lambda\boldsymbol{w} = 0.
\end{align}</p>
<p>偏微分には、対称行列（$A=\Phi^{\top}\Phi=A^{\top}$）に対する二次形式（$\boldsymbol{w}^{\top}A\boldsymbol{w}$）の$\boldsymbol{w}$の偏微分が$(A + A^{\top})\boldsymbol{w} = 2A\boldsymbol{w}$であること、$\boldsymbol{w}^{\top}\boldsymbol{a}, \boldsymbol{a}=\Phi^{\top}\boldsymbol{y}$としたときの$\boldsymbol{w}$の偏微分が$\boldsymbol{a}$であることを利用した。</p>
<p>最後に、$\boldsymbol{w}$について整理する。</p>
<p>\begin{align}
\begin{split}
2\Phi^{\top}\Phi\boldsymbol{w} -2\Phi^{\top}\boldsymbol{y} + 2\lambda\boldsymbol{w} &= 0\\
2\Phi^{\top}\Phi\boldsymbol{w} + 2\lambda\boldsymbol{w} &= 2\Phi^{\top}\boldsymbol{y}\\
\Phi^{\top}\Phi\boldsymbol{w} + \lambda\boldsymbol{w} &= \Phi^{\top}\boldsymbol{y}\\
(\Phi^{\top}\Phi + \lambda I_F)\boldsymbol{w} &= \Phi^{\top}\boldsymbol{y}\\
\boldsymbol{w} &= (\Phi^{\top}\Phi + \lambda I_F)^{-1}\Phi^{\top}\boldsymbol{y}.
\label{eq:w}
\end{split}
\end{align}</p>
<p>ここでは、行列のサイズが$F \times F$の単位行列を$I_{F}$と表記した。</p>
<p>新しい入力$\boldsymbol{x}$に対する出力は推定した$\boldsymbol{w}$を用いて、$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$と予測できる。</p>
<h2 id=2-カーネル法による線形回帰モデル>2. カーネル法による線形回帰モデル</h2>
<p>上述の線形回帰モデルを利用する際には、基底関数を増やし多くの特徴量の候補から予測に有用なものに重み付けできれば良いと考えられることから、特徴ベクトルの次元数$F$を増やすアプローチが検討される。
しかしながら、この場合、パラメータ$\boldsymbol{w}$の推定や出力$\hat{y}$の予測に必要な計算量も同時に増加してしまう。
そこで、カーネル法による線形回帰モデルでは、パラメータの次元数を$N$に抑えるようなアプローチをとる。
これは、学習データ数$N$が特徴ベクトルの次元数$F$よりも少ない場合に有効である。
また、線形回帰モデルにはもう一つ、予測に対して有用な基底関数の種類や数が明らかではないという課題がある。
これに対しカーネル法による線形回帰モデルは、カーネル関数を導入することで、基底関数の選定を省略することができる。</p>
<p>以下、上述のリッジ回帰にカーネル法を適用した<strong>カーネルリッジ回帰</strong>を説明する。</p>
<h3 id=21-線形回帰モデルの双対表現>2.1. 線形回帰モデルの双対表現</h3>
<p>パラメータの次元数を$N$に抑えるため、$F$次元の$\boldsymbol{w}$についての線形モデル$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$を、$N$個の学習データ$\Phi$に対応するパラメータ$\boldsymbol{\alpha} \in \mathbb{R}^{N}$で表現することを考える。</p>
<p>そのために、式\eqref{eq:w}の3行目以降の変形を以下のように進める。</p>
<p>\begin{align}
\begin{split}
\Phi^{\top}\Phi\boldsymbol{w} + \lambda\boldsymbol{w} &= \Phi^{\top}\boldsymbol{y}\\
\lambda\boldsymbol{w} &= - \Phi^{\top}\Phi\boldsymbol{w} + \Phi^{\top}\boldsymbol{y}\\
\lambda\boldsymbol{w} &= - \Phi^{\top}(\Phi\boldsymbol{w} - \boldsymbol{y})\\
\boldsymbol{w} &= - \frac{1}{\lambda} \Phi^{\top}(\Phi\boldsymbol{w} - \boldsymbol{y}).
\end{split}
\end{align}</p>
<p>ここで$\boldsymbol{\alpha} = - \frac{1}{\lambda}(\Phi\boldsymbol{w} - \boldsymbol{y})$とすると、$\boldsymbol{w} = \Phi^{\top}\boldsymbol{\alpha}$となる。
これにより、元の線形回帰モデルを$\hat{y} = (\Phi^{\top}\boldsymbol{\alpha})^{\top}\phi(\boldsymbol{x})$と、（右辺にも$\boldsymbol{w}$は含まれるが）見かけ上は$\boldsymbol{w}$を含まない形で表現できるようになった（<strong>双対表現</strong>）。</p>
<p>この双対表現の線形回帰モデルについて、最小二乗法を用いて$\boldsymbol{\alpha}$を推定する。
これは上述の$E(\boldsymbol{w})$を双対表現の線形回帰モデルで記述し、解を求めることと同等である。</p>
<p>このために、式\eqref{eq:ew}に$\boldsymbol{w} = \Phi^{\top}\boldsymbol{\alpha}$を代入し$\boldsymbol{\alpha}$についての関数$E(\boldsymbol{\alpha})$とした上で、以下のように整理する。</p>
<p>\begin{align}
\begin{split}
E(\boldsymbol{\alpha}) &= (\Phi^{\top}\boldsymbol{\alpha})^{\top}\Phi^{\top}\Phi(\Phi^{\top}\boldsymbol{\alpha}) - 2(\Phi^{\top}\boldsymbol{\alpha})^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda(\Phi^{\top}\boldsymbol{\alpha})^{\top}(\Phi^{\top}\boldsymbol{\alpha})\\
&= \boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\Phi\Phi^{\top}\boldsymbol{\alpha} - 2\boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\boldsymbol{\alpha}\\
&= \boldsymbol{\alpha}^{\top}KK\boldsymbol{\alpha} - 2\boldsymbol{\alpha}^{\top}K\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{\alpha}^{\top}K\boldsymbol{\alpha}.
\end{split}
\end{align}</p>
<p>なお、
\[
K = \Phi\Phi^{\top} =
\begin{pmatrix}
\boldsymbol{\phi}(\boldsymbol{x}_1)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_1) & \ldots & \boldsymbol{\phi}(\boldsymbol{x}_1)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_N) \\
\vdots & \ddots & \vdots \\
\boldsymbol{\phi}(\boldsymbol{x}_N)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_1) & \ldots & \boldsymbol{\phi}(\boldsymbol{x}_N)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_N)
\end{pmatrix} =
\begin{pmatrix}
k(\boldsymbol{x}_1,\boldsymbol{x}_1) & \ldots & k(\boldsymbol{x}_1,\boldsymbol{x}_N) \\
\vdots & \ddots & \vdots \\
k(\boldsymbol{x}_N,\boldsymbol{x}_1) & \ldots & k(\boldsymbol{x}_N,\boldsymbol{x}_N)
\end{pmatrix}
\in \mathbb{R}^{N \times N}
\]
とした。
ここで、入力$\boldsymbol{p}$と$\boldsymbol{q}$を$\boldsymbol{\phi}$によって特徴ベクトルに変換し内積をとる操作である$k(\boldsymbol{p},\boldsymbol{q})$をカーネル関数と呼ぶ。
また、学習データ$X$に対する全ての組み合わせである$K$をグラム行列と呼ぶ。</p>
<p>次に、$E(\boldsymbol{\alpha})$を最小化する$\boldsymbol{\alpha}$を求めるために$\boldsymbol{\alpha}$について偏微分して0とおく。</p>
<p>\begin{align}
\begin{split}
\frac{\partial E(\boldsymbol{\alpha})}{\partial \boldsymbol{\alpha}} &= 2KK\boldsymbol{\alpha} - 2K\boldsymbol{y} + 0 + 2\lambda K\boldsymbol{\alpha}= 0.
\end{split}
\end{align}</p>
<p>最後に、$\boldsymbol{\alpha}$について整理する。</p>
<p>\begin{align}
\begin{split}
2KK\boldsymbol{\alpha} - 2K\boldsymbol{y} + 2\lambda K\boldsymbol{\alpha} &= 0\\
KK\boldsymbol{\alpha} - K\boldsymbol{y} + \lambda K\boldsymbol{\alpha} &= 0\\
KK\boldsymbol{\alpha} + \lambda K\boldsymbol{\alpha} &= K\boldsymbol{y}\\
K\boldsymbol{\alpha} + \lambda \boldsymbol{\alpha} &= \boldsymbol{y}\\
(K + \lambda I_N)\boldsymbol{\alpha} &= \boldsymbol{y}\\
\boldsymbol{\alpha} &= (K + \lambda I_N)^{-1}\boldsymbol{y}.
\label{eq:alpha}
\end{split}
\end{align}</p>
<p>新しい入力$\boldsymbol{x}$に対する出力は、推定した$\boldsymbol{\alpha}$を用いて以下のように予測できる。</p>
<p>\begin{align}
\begin{split}
\hat{y} &= (\Phi^{\top}\boldsymbol{\alpha})^{\top}\boldsymbol{\phi}(\boldsymbol{x}) \\
&= \boldsymbol{\alpha}^{\top}\Phi\boldsymbol{\phi}(\boldsymbol{x}) \\
&= \sum_{n=1}^{N} \alpha_n \boldsymbol{\phi}(\boldsymbol{x}_n)^{\top}\boldsymbol{\phi}(\boldsymbol{x}) \\
&= \sum_{n=1}^{N} \alpha_n k(\boldsymbol{x}_n, \boldsymbol{x}).
\label{eq:yk}
\end{split}
\end{align}</p>
<p>すなわち、$F$次元の$\boldsymbol{w}$を用いず、学習データ数$N$を次元とする$\boldsymbol{\alpha}$で予測できるようになった。</p>
<h3 id=22-カーネル関数の構成>2.2. カーネル関数の構成</h3>
<p>ここまで、$F$個の基底関数$\phi$を用いた特徴ベクトルとしての$\boldsymbol{\phi}$同士の内積として、カーネル関数をボトムアップ的に定義した。</p>
<p>この場合、どのような基底関数を選定するかという線形回帰モデルのもう一つの課題が残る。
カーネル法を用いた線形回帰モデルでは、発想を逆転させ、カーネル関数をトップダウン的に先に直接定義することで、その内部の基底関数を陽に知らずにすませるというアプローチをとる。</p>
<p>ただし、この場合は定義したカーネル関数が正定値性を満たす必要がある。
すなわち、任意の$M$個の点から計算される、定義したカーネル関数による$M \times M$のグラム行列$K$の2次形式が常に非負（任意の$\boldsymbol{\mu} \in \mathbb{R}^M$に対して$\boldsymbol{\mu}^{\top}K\boldsymbol{\mu} \geq 0$）となる必要がある。</p>
<p>このような条件を満たすカーネル関数を直接定義できたならば、これはなんらかの特徴ベクトル同士の内積と考えることができる。
ありがたいことに、式\eqref{eq:yk}は基底関数$\phi$を使わず全てカーネル関数$k$で表現できているため、直接定義したカーネル関数があれば、基底関数の選定が不要となる（<strong>カーネルトリック</strong>）。</p>
<p>幸い、さまざまなカーネル関数が考案されているため、まずはそれらのカーネル関数を利用することとなる。
以下、多項式カーネルとガウスカーネルを紹介する。</p>
<h4 id=多項式カーネル>多項式カーネル</h4>
<p>多項式カーネルは$k(\boldsymbol{p}, \boldsymbol{q}) = (\boldsymbol{p}^{\top}\boldsymbol{q} + c)^{m}$の形をとるカーネル関数である。
上述のカーネルリッジ回帰を利用するにあたってはどのような特徴ベクトルが利用されているのかを陽に知る必要はないが、例えば$m=2,\boldsymbol{p},\boldsymbol{q} \in \mathbb{R}^2$であれば次のような特徴ベクトルが対応することが分かる。</p>
<p>対応する特徴ベクトルを調べるために、多項式カーネルを特徴ベクトルの内積$\boldsymbol{\phi}(\boldsymbol{p})^{\top}\boldsymbol{\phi}(\boldsymbol{q})$に変形する。</p>
<p>\begin{align}
\begin{split}
k(\boldsymbol{p}, \boldsymbol{q}) &= (\boldsymbol{p}^{\top}\boldsymbol{q} + c)^{2} \\
&= ((p_1, p_2)^{\top}(q_1, q_2) + c)^2 \\
&= (p_1q_1 + p_2q_2 + c)^2 \\
&= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + 2p_1q_1p_2q_2 + 2cp_2q_2 + 2cp_1q_1\\
&= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + 2p_1p_2q_1q_2 + 2cp_2q_2 + 2cp_1q_1\\
&= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + \sqrt{2}p_1p_2\sqrt{2}q_1q_2 + \sqrt{2c}p_2\sqrt{2c}q_2 + \sqrt{2c}p_1\sqrt{2c}q_1\\
&= (p_1^2, p_2^2, c, \sqrt{2}p_1p_2, \sqrt{2c}p_2, \sqrt{2c}p_1)^{\top}(q_1^2, q_2^2, c, \sqrt{2}q_1q_2, \sqrt{2c}q_2, \sqrt{2c}q_1).
\end{split}
\end{align}</p>
<p>つまり、今回の例では、特徴ベクトルが$\boldsymbol{\phi}(\boldsymbol{x}) = (x_1^2, x_2^2, c, \sqrt{2}x_1x_2, \sqrt{2c}x_2, \sqrt{2c}x_1)$として扱われていたことが分かる。
言葉を返せば、多項式カーネルを用いると、このような変換を行う6つの基底関数を明示的に選定して地道に内積を取った場合と同様の結果を得られる。</p>
<p>なお、多項式カーネルの$m=1,c=0$の場合、これを線形カーネルと呼び、この時の特徴ベクトルは入力と等しい（$\boldsymbol{\phi}(\boldsymbol{x}) = \boldsymbol{x}$）。</p>
<h4 id=ガウスカーネル>ガウスカーネル</h4>
<p>ガウスカーネルは$k(\boldsymbol{p}, \boldsymbol{q}) = \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2})$の形をとるカーネル関数である。</p>
<p>以下では、ガウスカーネルにどのような特徴ベクトルが対応するかを確認する。
まず、ガウスカーネルを以下のように展開、変形する。</p>
<p>\begin{align}
\begin{split}
k(\boldsymbol{p}, \boldsymbol{q}) &= \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2}) \\
&= \exp(-\frac{(\boldsymbol{p} - \boldsymbol{q})^{\top}(\boldsymbol{p} - \boldsymbol{q})}{2\sigma^2}) \\
&= \exp(-\frac{(\boldsymbol{p}^{\top} - \boldsymbol{q}^{\top})(\boldsymbol{p} - \boldsymbol{q})}{2\sigma^2}) \\
&= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - \boldsymbol{q}^{\top}\boldsymbol{p} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - (\boldsymbol{q}^{\top}\boldsymbol{p})^{\top} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - \boldsymbol{p}^{\top}\boldsymbol{q} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - 2\boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&= \exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2} + \frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2} + \frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&= \exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2})\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2})\exp(\frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&= \rho\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2})\psi \\
&= \rho\psi\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2}).
\end{split}
\end{align}</p>
<p>最後の2行では以降の展開を見やすくするため、$\rho=\exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2}), \psi=\exp(\frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2})$とおいた。</p>
<p>次に、$e^x$のマクローリン展開の公式（$e^x = \sum_{i=0}^{\infty} \frac{x^i}{i!} = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + \cdots$）を使い、特徴ベクトルの内積$\boldsymbol{\phi}(\boldsymbol{p})^{\top}\boldsymbol{\phi}(\boldsymbol{q})$に変形する。</p>
<p>簡単のため$\sigma=1$とすると、次のような式が得られる。</p>
<p>\begin{align}
\begin{split}
\rho\psi\exp(\boldsymbol{p}^{\top}\boldsymbol{q}) &= \rho\psi \left(1 + (\boldsymbol{p}^{\top}\boldsymbol{q})^1 + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^2}{2} + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^3}{6} + \ldots \right).
\end{split}
\end{align}</p>
<p>これは$c=0$の多項式カーネルを次数$m$を増やしながら無限回足したものである。
よって例えば、$\boldsymbol{p},\boldsymbol{q} \in \mathbb{R}^2$では、次のような<strong>無限次元</strong>の特徴ベクトルが対応することが分かる。</p>
<p>\begin{align}
\begin{split}
\rho\psi\exp(\boldsymbol{p}^{\top}\boldsymbol{q}) &= \rho\psi \left(1 + (\boldsymbol{p}^{\top}\boldsymbol{q})^1 + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^2}{2} + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^3}{6} + \ldots \right) \\
&= \rho\psi \left(1 + (p_1q_1 + p_2q_2) + \frac{p_1^2q_1^2 + p_2^2q_2^2 + \sqrt{2}p_1p_2\sqrt{2}q_1q_2}{2} + \frac{p_1^3q_1^3 + p_2^3q_2^3 + \sqrt{3}p_1^2p_2\sqrt{3}q_1^2q_2 + \sqrt{3}p_1p_2^2\sqrt{3}q_1q_2^2}{6} + \ldots \right) \\
&= \rho\left(1, p_1, p_2, \frac{p_1^2}{\sqrt{2}}, \frac{p_2^2}{\sqrt{2}}, \frac{\sqrt{2}p_1p_2}{\sqrt{2}}, \frac{p_1^3}{\sqrt{6}}, \frac{p_2^3}{\sqrt{6}}, \frac{\sqrt{3}p_1^2p_2}{\sqrt{6}}, \frac{\sqrt{3}p_1p_2^2}{\sqrt{6}}, \ldots \right)^{\top}\psi\left(1, q_1, q_2, \frac{q_1^2}{\sqrt{2}}, \frac{q_2^2}{\sqrt{2}}, \frac{\sqrt{2}q_1q_2}{\sqrt{2}}, \frac{q_1^3}{\sqrt{6}}, \frac{q_2^3}{\sqrt{6}}, \frac{\sqrt{3}q_1^2q_2}{\sqrt{6}}, \frac{\sqrt{3}q_1q_2^2}{\sqrt{6}},\ldots \right) \\
&= \rho\left(1, p_1, p_2, \frac{p_1^2}{\sqrt{2}}, \frac{p_2^2}{\sqrt{2}}, p_1p_2, \frac{p_1^3}{\sqrt{6}}, \frac{p_2^3}{\sqrt{6}}, \frac{p_1^2p_2}{\sqrt{2}}, \frac{p_1p_2^2}{\sqrt{2}}, \ldots \right)^{\top}\psi\left(1, q_1, q_2, \frac{q_1^2}{\sqrt{2}}, \frac{q_2^2}{\sqrt{2}}, q_1q_2, \frac{q_1^3}{\sqrt{6}}, \frac{q_2^3}{\sqrt{6}}, \frac{q_1^2q_2}{\sqrt{2}}, \frac{q_1q_2^2}{\sqrt{2}},\ldots \right).
\end{split}
\end{align}</p>
<p>ガウスカーネルでは、このような無限個の基底関数を用意して内積を地道に計算した結果が、$k(\boldsymbol{p}, \boldsymbol{q}) = \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2})$のみの計算から得られるとも考えられる。</p>
<h2 id=3-random-fourier-features乱択化フーリエ特徴>3. Random Fourier Features（乱択化フーリエ特徴）</h2>
<p>カーネルリッジ回帰による入力$\boldsymbol{x}$に対する予測は式\eqref{eq:alpha}\eqref{eq:yk}より、$\hat{y} = \sum_{n=1}^{N} \alpha_n k(\boldsymbol{x}_n, \boldsymbol{x}), \boldsymbol{\alpha} = (K + \lambda I_N)^{-1}\boldsymbol{y}$となるのであった。
カーネルリッジ回帰では、$F \gg N$となるような学習データ数$N$に対し十分大きい$F$個の基底関数を用いる場合に、双対表現によってパラメータ数を$N$に抑えつつ、カーネル関数の導入によって$F$次元の特徴ベクトルの直接的な算出を回避できた。</p>
<p>しかしながら、カーネルリッジ回帰は、学習データ数$N$に対して計算量が指数的に増加してしまう課題がある。
これは、グラム行列$K$のサイズが$N \times N$であるため、$\boldsymbol{\alpha}$の計算にあたって、必要なカーネル関数の計算が$N^2$のオーダーで増加することからも分かる。
また、逆行列の計算も$K$のサイズに応じて計算量が増加する。
加えて、$\hat{y}$の計算にあたっても、新しい入力$\boldsymbol{x}$に対して$N$回のカーネル関数の計算が都度必要となってしまう。</p>
<p><strong>Random Fourier Features</strong>は、ある確率分布からのサンプリング結果でカーネル関数とグラム行列を近似することで、上述の課題を解決する、高速化のための手法である。</p>
<p>この手法では、$\mathbb{R}^D$上のカーネル関数$k(\boldsymbol{p},\boldsymbol{q})$が$\boldsymbol{p}$と$\boldsymbol{q}$の差の形（$k(\boldsymbol{p}-\boldsymbol{q})$）で表せるとき、このカーネル関数が、ある確率密度関数$p(\boldsymbol{\omega})$のフーリエ変換で表せることを利用する。</p>
<p>\begin{align}
\begin{split}
k(\boldsymbol{p},\boldsymbol{q}) &= k(\boldsymbol{p} - \boldsymbol{q})\\
&= \int_{\mathbb{R}^{D}} p(\boldsymbol{\omega}) \exp(i \boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))d\boldsymbol{\omega} \\
&= \mathbb{E}_{\boldsymbol{\omega}}[\exp(i \boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))] \\
&= \mathbb{E}_{\boldsymbol{\omega}}[\cos(\boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))] \\
&= \mathbb{E}_{\boldsymbol{\omega},b}[\sqrt{2}\cos(\boldsymbol{\omega}^{\top}\boldsymbol{p} + b) \cdot \sqrt{2}\cos(\boldsymbol{\omega}^{\top}\boldsymbol{q} + b)] \\
&\approx \frac{1}{R} \sum_{r=1}^{R} \sqrt{2}\cos(\boldsymbol{\omega}_r^{\top}\boldsymbol{p} + b_r) \cdot \sqrt{2}\cos(\boldsymbol{\omega}_r^{\top}\boldsymbol{q} + b_r).
\end{split}
\end{align}</p>
<p>ここで、$\boldsymbol{\omega} \sim p(\boldsymbol{\omega}), b \sim \text{Uniform}(0, 2\pi)$である。
なお、$p(\boldsymbol{\omega})$は利用するカーネル関数によって異なるが、ガウスカーネルの場合、$\boldsymbol{w} = (w_d)^{1 \leq d \leq D}, w_d \sim \mathcal{N}(0, \sigma^2)$となる。</p>
<p>最後の行は、この確率分布の期待値（$=$カーネル関数の結果）を$R$個のサンプリング結果の平均で近似することを示している。</p>
<p>すなわち、各サンプルから求めた結果を、$z_r(\boldsymbol{x}) = \cos(\boldsymbol{\omega}_{r}^{\top}\boldsymbol{x} + b_r)$、$R$個の$z_r$を$\boldsymbol{z}(\boldsymbol{x}) = \sqrt{\frac{2}{R}}(z_1(\boldsymbol{x}),\ldots,z_R(\boldsymbol{x}))^{\top}$とおくと、カーネル関数$k$の近似$\hat{k}$が$\hat{k}(\boldsymbol{p},\boldsymbol{q}) = \boldsymbol{z}(\boldsymbol{p})^{\top}\boldsymbol{z}(\boldsymbol{q})$のように得られる。
また、学習データ$X$に対する$\boldsymbol{z}$の集合を$Z = (\boldsymbol{z}(\boldsymbol{x}_1)^{\top}, \ldots, \boldsymbol{z}(\boldsymbol{x}_N)^{\top})^{\top} \in \mathbb{R}^{N \times R}$とすると、$\hat{K} = ZZ^{\top}$の操作によって$N \times N$行列の各要素がカーネル関数$k$の近似$\hat{k}(\boldsymbol{x}_i, \boldsymbol{x}_j) = \boldsymbol{z}(\boldsymbol{x}_i)^{\top}\boldsymbol{z}(\boldsymbol{x}_j)$となるグラム行列$K$の近似$\hat{K}$を得られる。</p>
<p>よって、これらの近似を用いたカーネルリッジ回帰のパラメータ$\boldsymbol{\alpha}$の近似$\hat{\boldsymbol{\alpha}}$は、$\hat{\boldsymbol{\alpha}} = (\hat{K} + \lambda I_{N})^{-1}\boldsymbol{y}$となる。
ただし、この手法では、$\hat{K} = ZZ^{\top}$であることを利用して、計算量を学習データ数$N$ではなくサンプリング数$R$のオーダーに変えることができる。
そのため、$R \ll N$であるならば、非常に効率よく予測が可能となる。</p>
<p>以下に、$\hat{K}$や$\hat{\boldsymbol{\alpha}}$を消去していく経過と合わせて、この手法における予測式を示す。</p>
<p>\begin{align}
\begin{split}
\hat{y} &= \sum_{n=1}^{N} \hat{\alpha}_n \hat{k}(\boldsymbol{x}_n, \boldsymbol{x}) \\
&= \sum_{n=1}^{N} \hat{\alpha}_n \hat{k}(\boldsymbol{x}, \boldsymbol{x}_n) \\
&= \sum_{n=1}^{N} \hat{\alpha}_n \boldsymbol{z}(\boldsymbol{x})^{\top}\boldsymbol{z}(\boldsymbol{x}_n) \\
&= \boldsymbol{z}(\boldsymbol{x})^{\top} \sum_{n=1}^{N} \hat{\alpha}_n \boldsymbol{z}(\boldsymbol{x}_n) \\
&= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} \hat{\boldsymbol{\alpha}} \\
&= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} (\hat{K} + \lambda I_{N})^{-1}\boldsymbol{y} \\
&= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} (ZZ^{\top} + \lambda I_{N})^{-1}\boldsymbol{y} \\
&= \boldsymbol{z}(\boldsymbol{x})^{\top} (Z^{\top}Z + \lambda I_{R})^{-1}Z^{\top} \boldsymbol{y}.
\end{split}
\end{align}</p>
<p>よって、$A=(Z^{\top}Z + \lambda I_{R}) \in \mathbb{R}^{R \times R}$、$\boldsymbol{b} = (Z^{\top} \boldsymbol{y}) \in \mathbb{R}^{R}$、$\boldsymbol{\beta} = A^{-1}\boldsymbol{b}$として、$\hat{y} = \boldsymbol{z}(\boldsymbol{x})^{\top} \boldsymbol{\beta}$と予測できる。
$Z$は$N \times R$であるものの、逆行列のサイズは$R \times R$となること、$\hat{y}$の計算も、新しい入力$\boldsymbol{x}$に対して$R$回の計算で済む$\boldsymbol{z}(\boldsymbol{x})$のみで良いことから、計算量が抑えられることが分かる。</p>
<p>なお、最後の行では逆行列の補題（$P(I_N + QP)^{-1} = (I_R +PQ)^{-1}P, P \in \mathbb{R}^{R \times N}, Q \in \mathbb{R}^{N \times R}$）を用いた。</p>
<h2 id=参考>参考</h2>
<h3 id=線形回帰モデル>線形回帰モデル</h3>
<ul>
<li><a href=https://manabitimes.jp/math/1128>正規方程式の導出と計算例</a></li>
<li><a href=https://www.kspub.co.jp/book/detail/5161968.html>スタンフォード　ベクトル・行列からはじめる最適化数学</a></li>
<li><a href=https://www.kspub.co.jp/book/detail/1529267.html>ガウス過程と機械学習</a></li>
</ul>
<h3 id=カーネル法による線形回帰モデル>カーネル法による線形回帰モデル</h3>
<ul>
<li><a href=https://qiita.com/wsuzume/items/09a59036c8944fd563ff>線形な手法とカーネル法（回帰分析）</a></li>
<li><a href=https://qiita.com/kilometer/items/66e6116cc661019ead59>カーネルトリック</a></li>
<li><a href=https://www.slideshare.net/KeisukeSugawara/slide0629>PRML第６章「カーネル法」</a></li>
<li><a href=https://www.slideshare.net/hagino_3000/prml-61-17081123>PRML 6.1章 カーネル法と双対表現</a></li>
<li><a href=https://www.iwanami.co.jp/book/b257891.html>カーネル多変量解析 非線形データ解析の新しい展開</a></li>
<li><a href=https://towardsdatascience.com/truly-understanding-the-kernel-trick-1aeb11560769>Understanding the Kernel Trick with fundamentals</a></li>
<li><a href=https://en.wikipedia.org/wiki/Radial_basis_function_kernel>Radial basis function kernel</a></li>
</ul>
<h3 id=random-fourier-features>Random Fourier Features</h3>
<ul>
<li><a href=https://qiita.com/githug0906/items/448daec79fac2ffd82a0>乱択化フーリエ特徴を用いたリッジ回帰</a></li>
<li><a href=https://www.kyoritsu-pub.co.jp/book/b10003381.html>機械学習のためのカーネル100問 with Python</a></li>
<li><a href=https://gregorygundersen.com/blog/2019/12/23/random-fourier-features/>Random Fourier Features</a></li>
<li><a href=https://proceedings.neurips.cc/paper/2007/hash/013a006f03dbc5392effeb8f18fda755-Abstract.html>Rahimi, Ali, and Benjamin Recht. &ldquo;Random features for large-scale kernel machines.&rdquo; Advances in neural information processing systems 20 (2007).</a></li>
</ul>
</div>
<footer class=tag>
<i class="fa fa-tags tag-icon"></i>
<ul>
<li><a class=tag-link href=/tags/regression>regression</a></li>
</ul>
<div class=clear></div>
</footer>
</div>
</article>
<article>
<div class=post>
<header>
<h1><a href=https://blog.monochromegane.com/blog/2022/07/02/matrix-adapter/>gonum/matパッケージを直感的に操作するMatrix Adapterをつくった</a></h1>
<time><div class=day><i class="fa fa-calendar-o day-icon"></i>2022-07-02</div></time>
</header>
<div class=post-inner>
<p>gonum/matによる行列計算を幾分か直感的に扱える薄いラッパーを作りました。
具体的には、計算結果用に空の行列を予め用意するのではなく、計算結果を戻り値で受け取れるように統一します。</p>
<ul>
<li><a href=https://github.com/monochromegane/mat>Matrix Adapter</a>: Small adapter which provides method signatures that allow intuitive operation with fewer lines of code for gonum/mat.</li>
</ul>
<h1 id=背景と課題感>背景と課題感</h1>
<p><a href=https://github.com/gonum/gonum/tree/master/mat>Gonumプロジェクトのmatパッケージ</a>はGo言語での行列計算ライブラリを提供してくれています。
こういった正確さと速度の求められる数値計算の処理には、（趣味は別として）自作ではなく、多くの人に使われ実績のあるライブラリを採用したいことから、このパッケージを利用しています。</p>
<p>非常に便利に使わせていただいている一方で、自分の場合、スムーズに書けないことがありました。
理由としては、計算結果の受け取り方法に対する一貫性の崩れがあるだろうと考えています。</p>
<p>matパッケージでは、予め空の行列を用意し、これをレシーバーとして計算対象となる行列を引数で渡します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>Dense</span>
<span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>a</span>, <span style=color:#a6e22e>b</span>)
</code></pre></div><p>元の行列が維持されるこの設計は非常にありがたいです。
しかしながら、一部の関数（例えば <code>Dense.T</code>）は結果が戻り値として得られます。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>ct</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>c</span>.<span style=color:#a6e22e>T</span>()
</code></pre></div><p>この一貫性の崩れは不変と可変の混在にあるのではないかと考えています。
gonum/matパッケージでは、<a href=https://pkg.go.dev/gonum.org/v1/gonum/mat#hdr-Invariants>引数で渡す行列は計算操作に対して不変</a>とされています。
これは、関数のパラメータの方が、<code>mat.Matrix</code>インターフェースであることからも読み取れます。
実際、このインターフェースには、<code>Dims()</code>, <code>At()</code>といった参照系かレシーバーを壊さない<code>T()</code>のみが用意されています。</p>
<p>一方で、このインターフェースを実装した<code>mat.Dense</code>などは自身をレシーバーとして内容を変更する操作を認めています。
この差異により、mat.Matrixインターフェースのシグネチャの一つである<code>T()</code>は戻り値を返すが、Denseの関数ではレシーバーを変更するという振る舞いの違いがあるのではないかと思われました。</p>
<p>gonum/matパッケージではほとんどの関数が空の行列を予め用意する方式に従っているため、慣れれば問題ない程度ではありますが、久しぶりに使う場合など、多少まごつくことが何度かありました。
個人的に、Go言語で何か書くときは迷わず書きたいという欲求があり、迷わないため一貫性のあるラッパーを作ることとしました。</p>
<h1 id=matrix-adapter>Matrix Adapter</h1>
<p>今回は、計算結果を戻り値で受け取れるように統一します。
これにより、利用側からはDenseらも不変であるかのように扱え、一貫性という側面から認知負荷が減ると考えるためです。</p>
<p>Matrix Adapterを適用した場合、先ほどの例は以下のようになります。
<code>c</code>がレシーバーではなく、先ほどは引数となっていた<code>a</code>がレシーバーとなっていることに注意してください。
<code>c</code>は戻り値として受け取ることになりました。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>a</span>.<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>b</span>)
</code></pre></div><h2 id=実装と使い方>実装と使い方</h2>
<p>Adapterの実装は単純明快で、元の構造体を埋め込み（embedding）し、結果を戻り値で返すように関数のシグネチャを変更しました。
変更が不要なものは移譲されます。
いわゆるGoFのデザインパターンにおけるAdapterパターンというやつです。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Dense</span> <span style=color:#66d9ef>struct</span> {
	<span style=color:#f92672>*</span><span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>Dense</span>
}

<span style=color:#66d9ef>func</span> (<span style=color:#a6e22e>m</span> <span style=color:#f92672>*</span><span style=color:#a6e22e>Dense</span>) <span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>b</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>Matrix</span>) <span style=color:#f92672>*</span><span style=color:#a6e22e>Dense</span> {
	<span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dense</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>Dense</span>
	<span style=color:#a6e22e>dense</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>m</span>.<span style=color:#a6e22e>Dense</span>, <span style=color:#a6e22e>b</span>)
	<span style=color:#66d9ef>return</span> <span style=color:#f92672>&amp;</span><span style=color:#a6e22e>Dense</span>{<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>dense</span>}
}
</code></pre></div><p>現状、DenseとVecDenseに対するAdapterを提供しています。
既存と同名の<code>NewDense()</code>と<code>NewVecDense()</code>を使って、ラップされたDenseやVecDenseを作成できます。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>

<span style=color:#f92672>import</span> (
	<span style=color:#e6db74>&#34;fmt&#34;</span>

	<span style=color:#e6db74>&#34;github.com/monochromegane/mat/adapter&#34;</span>
)

<span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>() {
	<span style=color:#a6e22e>m</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>adapter</span>.<span style=color:#a6e22e>NewDense</span>(<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>2</span>, []<span style=color:#66d9ef>float64</span>{<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>2.0</span>, <span style=color:#ae81ff>3.0</span>, <span style=color:#ae81ff>4.0</span>})
	<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Printf</span>(<span style=color:#e6db74>&#34;%v\n&#34;</span>, <span style=color:#a6e22e>m</span>)
	<span style=color:#75715e>// ⎡1  2⎤
</span><span style=color:#75715e></span>	<span style=color:#75715e>// ⎣3  4⎦
</span><span style=color:#75715e></span>}
</code></pre></div><p>ちなみに、提供されるDenseとVecDenseは<code>fmt.Stringer</code>インターフェースを実装し、行列の内容を整形して出力するようにしています。</p>
<p>ここで、少し実践的な例として、リッジ回帰によるパラメータ推定（$\hat{\theta} = (X^{\top}X + \lambda I)^{-1} X^{\top}Y$）を実装し、比較してみます。</p>
<h3 id=matrix-adapterでの実装>Matrix Adapterでの実装</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>X</span>, <span style=color:#a6e22e>Y</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syntheticData</span>(<span style=color:#a6e22e>N</span>, <span style=color:#a6e22e>theta</span>) <span style=color:#75715e>// Return adapter.Dense
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>I</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>NewDiagDense</span>(<span style=color:#ae81ff>3</span>, []<span style=color:#66d9ef>float64</span>{<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>})
	<span style=color:#a6e22e>reg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>DenseCopyOf</span>(<span style=color:#a6e22e>I</span>).<span style=color:#a6e22e>Scale</span>(<span style=color:#a6e22e>lambda</span>)

	<span style=color:#a6e22e>XTXinv</span>, <span style=color:#a6e22e>_</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>X</span>.<span style=color:#a6e22e>Transpose</span>().<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>X</span>).<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>reg</span>).<span style=color:#a6e22e>Inverse</span>()
	<span style=color:#a6e22e>XTY</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>X</span>.<span style=color:#a6e22e>Transpose</span>().<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>Y</span>)

	<span style=color:#a6e22e>estimated</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>XTXinv</span>.<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>XTY</span>)
</code></pre></div><h3 id=gonummatでの実装>gonum/matでの実装</h3>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go>	<span style=color:#a6e22e>X</span>, <span style=color:#a6e22e>Y</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>syntheticData</span>(<span style=color:#a6e22e>N</span>, <span style=color:#a6e22e>theta</span>) <span style=color:#75715e>// Return adapter.Dense
</span><span style=color:#75715e></span>
	<span style=color:#a6e22e>XTXinv</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>NewDense</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>3</span>, <span style=color:#66d9ef>nil</span>)
	<span style=color:#a6e22e>XTXinv</span>.<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>X</span>.<span style=color:#a6e22e>T</span>(), <span style=color:#a6e22e>X</span>)

	<span style=color:#a6e22e>I</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>NewDiagDense</span>(<span style=color:#ae81ff>3</span>, []<span style=color:#66d9ef>float64</span>{<span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>, <span style=color:#ae81ff>1.0</span>})
	<span style=color:#a6e22e>reg</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>DenseCopyOf</span>(<span style=color:#a6e22e>I</span>)
	<span style=color:#a6e22e>reg</span>.<span style=color:#a6e22e>Scale</span>(<span style=color:#a6e22e>lambda</span>, <span style=color:#a6e22e>reg</span>)

	<span style=color:#a6e22e>XTXinv</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>XTXinv</span>, <span style=color:#a6e22e>reg</span>)
	<span style=color:#a6e22e>XTXinv</span>.<span style=color:#a6e22e>Inverse</span>(<span style=color:#a6e22e>XTXinv</span>)

	<span style=color:#a6e22e>XTY</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>NewDense</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>nil</span>)
	<span style=color:#a6e22e>XTY</span>.<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>X</span>.<span style=color:#a6e22e>T</span>(), <span style=color:#a6e22e>Y</span>)

	<span style=color:#a6e22e>estimated</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>mat</span>.<span style=color:#a6e22e>NewDense</span>(<span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>1</span>, <span style=color:#66d9ef>nil</span>)
	<span style=color:#a6e22e>estimated</span>.<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>XTXinv</span>, <span style=color:#a6e22e>XTY</span>)
</code></pre></div><p>この例では、gonum/matでの実装に比べてMatrix Adapterでの実装が、結果用の<code>Dense</code>の準備が省略できたこと、各関数で受け取る引数が減ったことなどから、幾分か簡潔に記述できているかと思います。</p>
<p>なお、Adapterでの実装では、Method Chainによる行数の短縮も見てとれます。
これについては、戻り値を返す実装としたことで副次的に得られた、本Adapterの特徴です。
Go言語におけるMethod Chainは、errorを含む多値の戻り値との相性から、積極的に採用されていないと認識しています。
ただ、今回は元のパッケージが各計算においてerrorを返さないものが多く、多値にならない関数が多くできたため、結果としてMethod Chainがつながる場合ができています（<code>Inverse()</code>などerrorを返すものもあるため全部は繋げません）。
この辺りのエラー処理については、一考の価値があると思いますが、現時点で本Adapterの対象外（従来パッケージを踏襲）としています。</p>
<h2 id=相互運用性>相互運用性</h2>
<p>Adapterの提供する関数でも、引数は<code>mat.Matrix</code>（や<code>mat.Vector</code>）を使うため、既存のラップしていないものを入力として受け取れます。
また、これらのAdapterは、<code>mat.Dense</code>（や<code>mat.VecDense</code>）構造体を埋め込んでいるため、<code>mat.Matrix</code>（や<code>mat.Vector</code>）の実装を満たします。
よって、ラップされた<code>adapter.Dense</code>（や<code>adapter.VecDense</code>）を既存の関数の入力として渡すことができます。</p>
<p>また、<code>T()</code>は<code>mat.Matrix</code>として維持しなければならない関数であることから、同等の<code>Transpose()</code>を提供しています。
これにより、転置行列がレシーバーとなるような呼び出しであっても、<code>adapter.Dense</code>として振る舞うことができるようになり、Matrix Adapterとの親和性が向上します。</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#75715e>// X.T().Product(Y) is invalid due to mat.Matrix has no method Product.
</span><span style=color:#75715e></span><span style=color:#a6e22e>XTY</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>X</span>.<span style=color:#a6e22e>Transpose</span>().<span style=color:#a6e22e>Product</span>(<span style=color:#a6e22e>Y</span>) <span style=color:#75715e>// Valid
</span></code></pre></div><h1 id=まとめ>まとめ</h1>
<p>本エントリでは、gonum/matパッケージを直感的に操作するための<a href=https://github.com/monochromegane/mat>Matrix Adapter</a>を紹介しました。
本Adapterの作成とエントリ執筆において、「直感的でない」と主観的に感じる理由について、不変と可変の混在に起因するものではないかなと言語化できたのがよかったかなあと思います。</p>
<p>自分の利用範囲だと、DenseとVecDenseで事足りる場合が多いのですが、必要に応じて対象を増やしていこうかと思います。</p>
<h1 id=参考>参考</h1>
<ul>
<li><a href=https://po3rin.com/blog/gonum>Go + Gonum を使った行列計算まとめ</a>
<ul>
<li>関数の直感性を上げるための独自関数や、行列のフォーマットなどを参考にさせていただきました。</li>
</ul>
</li>
<li><a href=https://github.com/gorgonia/tensor>gorgonia/tensor</a>
<ul>
<li>gonum/matではないGo言語の行列計算パッケージ。戻り値で結果を受け取れたりerrorも返すので本Adapterの目指すところに近いとは思います。速度含めて検証が必要なのもあり、今回は慣れて使っている方が多いであろうgonum/matをラップする方式を採用しました。</li>
</ul>
</li>
</ul>
</div>
<footer class=tag>
<i class="fa fa-tags tag-icon"></i>
<ul>
<li><a class=tag-link href=/tags/golang>golang</a></li>
</ul>
<div class=clear></div>
</footer>
</div>
</article>
<article>
<div class=post>
<header>
<h1><a href=https://blog.monochromegane.com/blog/2021/12/29/2021/>2021</a></h1>
<time><div class=day><i class="fa fa-calendar-o day-icon"></i>2021-12-29</div></time>
</header>
<div class=post-inner>
<p>2021年は、自分の研究テーマとひたすら向き合った年となった。
昨年10月より博士後期課程に在学していることもあり、まずは1本国際会議に通すべく、自身の提案手法の改善、評価と従来手法との比較分析を、1年間ひたすら続けていた。
研究の進捗の節目ごとに投稿していた国際会議は、残念ながら3回投稿して全てリジェクトとなってしまったが、これらのフィードバックや方式の改善の結果、論文の質や提案手法の性能はこの1年間で随分上がったのではないかと思う。</p>
<p>実際に、これらの進捗を議論すべく報告した、国内の2回の研究会では3つの賞を受賞することができ、客観的にも、自分の研究テーマとの向き合ってきた結果が出てきていると思える。
昨年度の受賞は、優秀プレゼンテーション賞という発表の分かりやすさの側面が強かったが、今年は、それに加え、座長や運営委員による選定という、より内容に踏み込んだ評価の上での受賞であり、非常に嬉しかったし、国際会議挑戦を継続するにあたって励みになった。</p>
<p>来年は引き続き国際会議への挑戦と研究の発展を進めたい。
そのために、結果に一喜一憂せずに淡々と継続することを心がけていく。
また、手法改善の基盤となる数学的な能力向上や先行研究のサーベイは一過性ではなく計画的に長期的に取り組めるような枠組みを作り上げたい。
加えて、来年度は、個人のみの研究の位置付けからもう少し視座を高め、例えば研究所の取り組みと各研究員の研究、会社のサービスやビジョンとの関係性などから、方針や行動を見定め、それらに向かって導いたり知ってもらえるような振る舞いなど、今よりも先を見通し、今よりも大きく影響を与えることも意識していきたい。</p>
<p>2022年からは、支えてくれる周りの人にも、恩返しだったり良い影響を与えることをできるようになりたいと思う。
来年もよろしくお願いします。</p>
<h1 id=実績>実績</h1>
<p>以下、実績を列挙する。</p>
<h2 id=表彰>表彰</h2>
<p>2021年は2つの研究会で3つの賞を受賞できた。
聴講者だけでなく運営委員や座長による評価をいただけるような研究を継続的に出せるようになっていることは素直に嬉しい。
また、研究所の共著論文でも2つの賞を受賞しており、研究所全体の盛り上げにも貢献できてよかったと思う。</p>
<ul>
<li><a href=https://www.sigwi2.org/prev-awardlist>ARG 第17回Webインテリジェンスとインタラクション研究会 優秀研究賞</a>, 三宅 悠介, 峯 恒憲, 仮想的な探索を用いて文脈や時間の経過による番狂わせにも迅速に追従する多腕バンディット手法, 2021年12月.</li>
<li><a href=https://sites.google.com/view/sig-macc/smash/smash21-summer-symposium>SMASH21 Summer Symposium 優秀賞</a>, 三宅 悠介, 峯 恒憲, Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム, 2021年9月.</li>
<li><a href=https://sites.google.com/view/sig-macc/smash/smash21-summer-symposium>SMASH21 Summer Symposium 奨励賞</a>, 三宅 悠介, 峯 恒憲, Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム, 2021年9月.</li>
</ul>
<h2 id=論文>論文</h2>
<p>招待講演1本、研究報告2本。
実際には国際会議3回投稿、投稿中の国内ジャーナル1本があり、体感的な執筆量は例年と変わらない程度であったと思う。
また、研究報告のラストオーサーを2本、国内査読付き論文と国際会議（ワークショップ）論文でそれぞれ1本づつ共著を務めた。</p>
<ol>
<li>三宅 悠介, 峯 恒憲, <a href=https://www.sigwi2.org/d_library>仮想的な探索を用いて文脈や時間の経過による番狂わせにも迅速に追従する多腕バンディット手法</a>, ARG Webインテリジェンスとインタラクション研究会 第17回研究会予稿集, No.17, pp.19-24, Dec 2021. <a href=https://rand.pepabo.com/papers/wi2-17-miyakey.pdf>[論文]</a> <a href=https://speakerdeck.com/monochromegane/wi2-lkf-bandits>[発表資料]</a></li>
<li>三宅 悠介, 峯 恒憲, <a href=http://id.nii.ac.jp/1001/00212709/>Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム</a>, 研究報告知能システム（ICS）, Vol.2021-ICS-204, No.9, pp.1-8, Sep 2021. <a href=https://rand.pepabo.com/papers/smash21-miyakey.pdf>[論文]</a> <a href=https://speakerdeck.com/monochromegane/smash21-synapse>[発表資料]</a></li>
<li>三宅 悠介, 栗林 健太郎, <a href=https://tsys.jp/dicomo/2021/program/program_abst.html#8A-1>(招待講演) なめらかなシステムと運用維持の未来</a>, マルチメディア，分散，協調とモバイル（DICOMO2021）シンポジウム論文集, 2021, p.1509, Jun-Jul 2021.<a href=https://rand.pepabo.com/papers/dicomo2021-miyakey.pdf>[論文]</a> <a href=https://speakerdeck.com/monochromegane/dicomo2021-coherently-fittable-system>[発表資料]</a></li>
</ol>
<h2 id=国内発表>国内発表</h2>
<p>技術イベント、研究会での発表をそれぞれ1回（学会の研究会、シンポジウムを除く）。
今年はFukuoka.goもWSAも開催が少なかったこともあり、随分控えめになってしまった。
来年はもう少し機会を見つけて登壇していきたい。</p>
<ol>
<li>三宅 悠介 <a href=https://speakerdeck.com/monochromegane/fukoukago17-go-code-embedding>go:embedでExplainable Binaryを作る</a>, <a href=https://fukuokago.connpass.com/event/202570/>Fukuoka.go#17(オンライン開催)</a>, 2021年6月.</li>
<li>三宅 悠介 <a href=https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/>非定常な多腕バンディット問題において効率的に変化を察知する方式の検討</a>, <a href=https://wsa.connpass.com/event/207143/>Web System Architecture 研究会 (WSA研) #8</a>, 2021年6月.</li>
</ol>
<h2 id=oss>OSS</h2>
<p>Fukuoka.go用に書いたツールが1本。
先行研究の実装など随分とコードは書いている気がするので研究とOSSもうまくつないでいきたいところ。</p>
<ul>
<li><a href=https://github.com/monochromegane/go-code-embedding>go-code-embedding</a> A tool to embed Go source code into binary using go:embed.</li>
</ul>
<h2 id=コミュニティ活動>コミュニティ活動</h2>
<p>今年よりこれまでのFukuoka.goに加え、学会系の活動も手伝うようになった。
具体的には研究会の運営委員への就任に伴う運営従事の他、査読、座長、シンポジウムのプログラム委員などを務めた。</p>
<ul>
<li><a href=https://fukuokago.connpass.com/event/202570/>Fukuoka.go#17 (オンライン開催)</a></li>
<li><a href=https://www.iot.ipsj.or.jp/>情報処理学会 インターネットと運用技術研究会 運営委員 就任</a></li>
<li><a href=https://www.iot.ipsj.or.jp/symposium/iots2021/>第14回 インターネットと運用技術シンポジウム（IOTS 2021）プログラム委員</a></li>
</ul>
<h2 id=ブログ>ブログ</h2>
<p>2本。昨年までに比べるとかなり少なめだが、研究の進め方シリーズとして集中的サーベイは研究所のみんなに紹介するなど役立ったと思う。
このような手探りからやり方に昇華できたものは今後もブログにまとめていきたい。</p>
<ul>
<li><a href=https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/>非定常な多腕バンディット問題において効率的に変化を察知する方式の検討</a></li>
<li><a href=https://blog.monochromegane.com/blog/2021/05/15/survey-method/>研究の位置づけを明確にする集中型の論文サーベイ方法</a></li>
</ul>
</div>
<footer class=tag>
<i class="fa fa-tags tag-icon"></i>
<ul>
<li><a class=tag-link href=/tags/%E3%81%B5%E3%82%8A%E3%81%8B%E3%81%88%E3%82%8A>ふりかえり</a></li>
</ul>
<div class=clear></div>
</footer>
</div>
</article>
<article>
<div class=post>
<header>
<h1><a href=https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/>非定常な多腕バンディット問題において効率的に変化を察知する方式の検討</a></h1>
<time><div class=day><i class="fa fa-calendar-o day-icon"></i>2021-06-08</div></time>
</header>
<div class=post-inner>
<p>このエントリは、<a href=https://wsa.connpass.com/event/207143/>第8回 Web System Architecture 研究会 (WSA研)</a>の予稿です。</p>
<h1 id=非定常な多腕バンディット問題において効率的に変化を察知する方式の検討>非定常な多腕バンディット問題において効率的に変化を察知する方式の検討</h1>
<h2 id=はじめに>はじめに</h2>
<p>適応的なシステムの実現には、利用者と情報システムが互いの状態をよく理解するためのコミュニケーションと、それに応じた振る舞いの変更が必要となる。
一方で、そのコミュニケーションから得られる情報や利益の価値を考慮しなければならない環境では、確実な情報に基づく振る舞いを選択しつつ、まだ得られていない情報を引き出すために、価値の低いコミュニケーションを敢行しなければならない。</p>
<p>これは、多腕バンディット問題として定式化できる。
多腕バンディット問題では、振る舞いの選択肢のことを腕と呼び、ある時点までの情報をもとに有効な腕を選択することを「活用」、腕の可能性を探るために有効ではない腕を選択することを「探索」と呼ぶ。
それぞれの腕はある確率分布に従い報酬を生成する。
中でも、選択肢の相対的な有効性が時間経過とともに変化する問題設定は非定常な多腕バンディット問題と呼ばれ、いくつかの解法が提案されている。</p>
<p>非定常な多腕バンディット問題に対する解法には、腕の有効性の変化に応じた評価の更新が重要とされてきた。
しかしながら、選択による機会損失の低減を目的とした多腕バンディット問題の設定では、ある時点で有効性の低い選択肢が利用される機会は少なく、腕の有効性の変化を察知する、それ自体がまず難しい。</p>
<p>本研究では、このような非定常な多腕バンディット問題における変化を素早く察知するにあたり、探索による機会損失を抑制した、効率的な方式を検討する。
なお、多腕バンディット問題の設定は、同時に文脈付きの問題設定に拡張することができるが、課題の本質は同じであること、方式検討の容易性から、本方向では文脈の考慮は行わない。</p>
<h2 id=非定常な多腕バンディット問題の解法における変化察知の課題>非定常な多腕バンディット問題の解法における、変化察知の課題</h2>
<p>非定常な多腕バンディット問題への解法では、腕の報酬分布が変化した際に、過去に観測した報酬に捉われずに腕の評価を迅速に更新しなくてはならない。
この問題の解法には大きく4つのアプローチがある。
一つ目は、腕の報酬分布が変化することを前提にして、観測時点からの経過に応じて腕の評価に重み付けをするアプローチである（減衰型）。
二つ目も、同様の前提において、新しく観測した報酬から一定の期間のみの情報で報酬分布を評価する（ウィンドウ型）。
三つ目は、腕の報酬分布の変化を契機として、腕を再評価するものである（変化検出型）。
このアプローチでは、変化検出の手法を用いて腕の報酬の変化を検出し、変化前の観測を取り除くことで、新しく観測された報酬を重視する。
これは変化検出による可変のウィンドウ型とみなすこともできる。
四つ目は、現時点の腕の評価を継続的に推定するものである。
このアプローチでは、腕の状態として状態空間モデルを仮定し、カルマンフィルタや粒子フィルタを推定に用いる。</p>
<p>これらの全てのアプローチは、変化後の報酬分布から得られる報酬のサンプルを一定数必要とする。
選択による機会損失の低減を目的とした多腕バンディット問題の設定では、ある時点で評価の高い腕を最も多く活用する。
そのため、評価の高い腕が、ある時点で有効性が低くなるようなケースでは、十分な報酬のサンプルを観測することができ、各アプローチは有効に働く。
反対に、評価の低かった腕が、ある時点で有効性が高くなるケースでは、その腕に対する報酬のサンプルを得るまでに時間が掛かり、機会損失の発生に繋がると考えられる。
例えば、ECサイトの推薦アルゴリズムのコールドスタートのような、一定の嗜好情報が蓄積されることでその有効性を増すような選択肢がある場合に、この問題が発生する。</p>
<p>この問題に直接挑んだ先行研究[1][2]では、いずれもなんらかの非定常な多腕バンディットの解法に従い腕の選択を行うが、一定の割合で、ランダムに腕を選択することで、腕の選択の偏りの解消を試みている。
また、上述のアプローチのうち、報酬の観測数の上限を変化させるような、減衰型、ウィンドウ型、変化検出型でも、間接的に腕の選択の偏りが緩和される。
なぜなら、多くの多腕バンディットの解法では、観測数の少なさを評価の不確かさと捉え、探索を促すからである。</p>
<p>これらの探索を増やすアプローチは、トレードオフが発生する。
すなわち、相対的な腕の評価が逆転しない期間では、その期間中の探索が機会損失につながってしまう。
そのため、評価の低い腕の有効性の変化を素早く察知できるよう探索を行いつつ、その探索に伴う機会損失を減らすことが求められる。</p>
<h2 id=非定常な多腕バンディット問題の解法における効率的な変化察知の方式の検討>非定常な多腕バンディット問題の解法における、効率的な変化察知の方式の検討</h2>
<p>本研究では、評価の低い腕に対する変化の察知について、素早さと機会損失低減の観点を両立させるため、この探索行為を多腕バンディット内の多腕バンディットとみなす。
そして、この多腕バンディット内の多腕バンディットの評価基準に、腕の不安定性と、将来性を採用することで、探索時の機会損失低減を目指す。</p>
<p>本報告では、先行研究の一定の割合で実施される探索行為を対象として機会損失の改善を目指す。
すなわち、腕の選定の比率が同一となるようなランダム選定ではなく、腕の不安定性と将来性を基準に、腕の選定の比率を変化させる。
提案手法では、腕の不安定性と将来性を扱うために、獲得報酬の時系列予測を行う。
時系列予測には、将来性の変化を扱えるよう少なくともトレンド成分を扱うことができ、不安定性を扱えるよう予測の幅も扱えるようなモデルが望ましい。
そこで、これらを満たすベイズ型統計モデルを採用する。
扱う報酬の形式により、カルマンフィルタや粒子フィルタを選択可能である。
探索には、各腕でn時点先の評価を予測値と信用区間に基づき腕の不安定性と将来性が高い腕を選定する。
予測値が将来性、信用区間の広さが不安定性に該当する。
なお、これらのモデルでは時系列予測の時点が進むにつれ、その信用区間が広がっていくことから、無限の将来を想定した腕の選定では、先行研究と同じ振る舞いになると考えられる。</p>
<h2 id=評価>評価</h2>
<p>カルマンフィルタベースの提案方式のコンセプト実装し、トイ・シミュレーションで機会損失を抑えられることを評価した。</p>
<h3 id=シミュレーション設定>シミュレーション設定</h3>
<p>評価環境として、腕の数が3、1000回の試行において、期間中に有効性の最も低かった腕が最も高くなるよう設定した。
なお、このシミュレーションでは、先行研究における一定数の割合の探索の試行のみを取り出したことを想定している。</p>
<p><img src=https://user-images.githubusercontent.com/1845486/120578001-10a3b200-c460-11eb-83f6-d9b4d703125b.png alt=plot_true_reward></p>
<h3 id=評価方法>評価方法</h3>
<p>そして、以下のそれぞれの方式に対して、機会損失を抑える性能と変化を素早く察知する性能を評価した。</p>
<ul>
<li>random: ランダムな探索（予測できない未来を想定）ε-Greedy(ε=1.0)</li>
<li>epsilon: 現在の情報に基づく探索（予測できない未来を想定）ε-Greedy(ε=0.1)</li>
<li>state model: 予測に基づく探索（予測できる未来を想定）ε-Greedy(ε=0.1)だが活用時はカルマンフィルタによる100期先予測の値で選定する</li>
</ul>
<p>なお、本報告の提案手法のコンセプト実装では、将来性のみを扱い、不安定性の考慮はできていない。</p>
<p>本評価では、機会損失を抑える性能を、累積リグレットの低さによって評価する。
本報告で、累積リグレットとは、各時点での最適な腕から得られる期待報酬額と方策が選定した腕から得られた報酬額の差の合計のことを指す。
また、変化を素早く察知する性能を、腕の真の有効性が切り替わった時点以降で新しい最適な腕を選択した回数が一定数を超えるまでの期間の短さによって評価する。</p>
<p>なお、準備期間の関係上、シミュレーションは複数回行っていないため、変動する可能性がある。</p>
<h3 id=機会損失を抑える性能の評価>機会損失を抑える性能の評価</h3>
<p>各方式の累積リグレットの推移を下図に示す。</p>
<p><img src=https://user-images.githubusercontent.com/1845486/120577990-0e415800-c460-11eb-9521-bc81e83b2f38.png alt=plot_cum_regret></p>
<p>均等に腕を選択するrandomではおおよそ線形にリグレットが増加する。
epsilonでは、変化前のリグレットの増加は抑えられるが、変化後には追従が遅れ、リグレットが大きく増加した。
これは、腕の選定の偏りによって探索が十分に行えないことと、過去データにひきづられて腕の評価の更新が遅れていることから発生していると考えられる。</p>
<p>提案のstate modelでは、シミュレーション初期にrandomと同じ程度のリグレットの増加が確認された。
これは、予測に基づく活用が精度が低かったことに起因する。
50時点以降は予測が安定することで、リグレットの増加がepsilonと同等になった。
そして、変化後であっても、リグレットの増加が抑えられていることが確認できる。
これは、予測によって、将来性がある探索すべき腕を決定し、評価の更新をいち早く行えたためである。</p>
<h3 id=変化を素早く察知する性能の評価>変化を素早く察知する性能の評価</h3>
<p>切り替わり後の最適な腕を選択した累積回数の推移を下図に示す。</p>
<p><img src=https://user-images.githubusercontent.com/1845486/120577999-10a3b200-c460-11eb-8798-e56325190308.png alt=plot_sampled_new_arm></p>
<p>均等に腕を選定するrandomではおおよそ線形に腕が選定される。
本研究の課題設定では、この増加より大きいことが望まれる。
epsilonでは、腕の有効性の変化に追従できず、ε-Greedyの探索割合に応じた増加にとどまった。
これは、腕の選択肢が増加するほど、探索が行われない可能性が増すことも示している。
提案のstate modelでは、予測によって、将来性がある探索すべき腕を決定し、該当の腕に対する探索がrandomと比べて多く行われた。
これにより、変化の察知が素早く進むことが期待できる。</p>
<p>腕の有効性の変更に対する、提案方式の100時点先の予測を下図に示す。</p>
<p><img src=https://user-images.githubusercontent.com/1845486/120577996-0f728500-c460-11eb-963f-63cf25f17038.png alt=plot_predicted_reward></p>
<p>本評価のシミュレーション設定は非常に単純なものであったため、予測がおおよそ正しかったことがわかる。</p>
<h2 id=まとめ>まとめ</h2>
<p>本報告では、非定常な多腕バンディットにおける変化の察知の課題を整理し、腕の不安定性と将来性に着目した予測型の多腕バンディット方策を提案した。
将来性を考慮可能なコンセプト実装では、シミュレーションにおいて、累積リグレットを抑えた素早い変化察知の可能性が示唆された。
今後はコンセプト実装に、不安定性の考慮を組み込むこと、そのためにε-Greedyではなくトンプソンサンプリングをベースにした手法との統合を進めたい。
また、文脈を考慮した場合での実装とシミュレーションの拡張を行う。
加えて、探索割合自体を環境の変化の度合いに応じて変動させる方式も検討する。</p>
<h2 id=参考文献>参考文献</h2>
<ul>
<li>[1] Fang Liu, Joohyun Lee, and Ness Shroff. 2018. A change-detection based framework for piecewise-stationary multi-armed bandit problem. In Proceedings of the AAAI Conference on Artificial Intelligence, Vol. 32.</li>
<li>[2] Yang Cao, Zheng Wen, Branislav Kveton, and Yao Xie. 2019. Nearly optimal adaptive procedure with change detection for piecewise-stationary bandit. In The 22nd International Conference on Artificial Intelligence and Statistics. PMLR, 418–427.</li>
</ul>
<h1 id=発表スライド>発表スライド</h1>
<h1 id=発表を終えて>発表を終えて</h1>
</div>
<footer class=tag>
<i class="fa fa-tags tag-icon"></i>
<ul>
<li><a class=tag-link href=/tags/wsa%E7%A0%94>WSA研</a></li>
</ul>
<div class=clear></div>
</footer>
</div>
</article>
<article>
<div class=post>
<header>
<h1><a href=https://blog.monochromegane.com/blog/2021/05/15/survey-method/>研究の位置づけを明確にする集中型の論文サーベイ方法</a></h1>
<time><div class=day><i class="fa fa-calendar-o day-icon"></i>2021-05-15</div></time>
</header>
<div class=post-inner>
<p>博士課程に進学し、国際会議に論文を投稿した際に行った論文サーベイの流れやツールについてまとめておく。
今回のサーベイを行うにあたり、既存研究に対する自身の研究の位置づけを明らかにすることを目標とした。
すなわち、自身の提案がある程度カタチになっていることを前提とした集中的サーベイ方法である。</p>
<h1 id=論文サーベイの流れ>論文サーベイの流れ</h1>
<p>以下に行った工程を示す。</p>
<ol>
<li>会議名とキーワード検索による候補のリストアップ</li>
<li>各候補のアブストラクトによる選定</li>
<li>各候補の精読</li>
<li>必要に応じて参考になる会議名、キーワード、参照論文を候補に追加</li>
<li>候補がなくなるまで繰り返す</li>
</ol>
<p>以降、各工程について利用したツールや工夫などを述べる。</p>
<h1 id=1-会議名とキーワード検索による候補のリストアップ>1. 会議名とキーワード検索による候補のリストアップ</h1>
<p>サーベイは十分な量の候補を必要とする。
自身の研究分野や貢献と完全に一致する論文は多くはないが、全くゼロではない。
もし多すぎるのであれば、自身の研究の貢献や目的が十分に掘り下げられていない可能性がある。
もしゼロであれば、自身の研究に有用性がないか、十分な調査ができていないかもしれない。
自身の研究を信じる我々は、いずれにせよ十分に候補を見つける必要がある。</p>
<p>候補の選定には、<a href=https://scholar.google.com/>Google Scholar</a>によるキーワード検索を用いる。
なるべく多くの論文を候補とするため、キーワードは関連しそうなキーワードを複数挙げて、ORで繋ぐと良い。
この時、指導教官からのアドバイスで会議名を絞って検索するようにした。
これは、検索クエリに <code>source:SIGKDD</code> などと指定することで実現できる。</p>
<p>そして、検索結果から以下の情報をリスト化する。</p>
<ul>
<li>Title</li>
<li>Citiations</li>
<li>URL</li>
<li>Authors</li>
</ul>
<p>おおよそ、Google Scholarではキーワードへの関連性が高いものから並べてくれているため、会議ごとに上位20-50本程度を候補とすれば十分であったように思える。</p>
<p>リスト化にはGoogleスプレッドシートを利用した。後の工程のため、関連有無フラグとメモ欄をカラムとして追加する。</p>
<p>なお、検索〜リスト作成は手動では面倒なので、スクリプトを用意した。</p>
<h1 id=2-各候補のアブストラクトによる選定>2. 各候補のアブストラクトによる選定</h1>
<p>1.でリストアップした候補について、精読すべきかの選定を行う。
なお、選定はアブストラクトのみで行うこと。
ここで、個別に精読を始めると時間がいくらあっても足りないからである（逆に言えば自身の研究もやはりアブストラクトに提案と貢献をしっかり記述する必要がある）。</p>
<p>選定基準は自身の研究や提案、貢献に関連がありそうかとする。
また、いくつか読んでいく中で判断基準が徐々に形成されていくので、効率よく見直せるよう、メモを書いておく。
メモには、どういう提案や手法かを一行程度書けば良い。
精読すべきと判断したものには、リストに丸をつけ、フィルタなり色付けして候補を見つけやすくしておく。</p>
<h1 id=3-各候補の精読>3. 各候補の精読</h1>
<p>2.で選定した精読候補を読み、まとめる。
多くの論文を読まなければならないこと、最終的に自分の研究との相対的な位置づけを整理する必要があるため、効率よく見直せるようまとめを残す必要がある。
まとめがないと何度も同じ論文をイチから読み直す必要があるので絶対にまとめること。
以下にまとめの観点とこれを実現するツールについて示す。</p>
<h2 id=まとめの観点>まとめの観点</h2>
<p>まとめの粒度や項目が統一されていることが望ましい。
自分は、<a href=https://www.slideshare.net/Ochyai/1-ftma15/>落合メソッド</a>をアレンジして使っている。
つまり、自分の研究の位置づけを整理するのに適した問いかけにしている。</p>
<ul>
<li>どんなもの？</li>
<li>先行研究と比べてどこがすごい？（どんな課題を解決する？）</li>
<li>技術や手法のキモはどこ？（どうやって解決した？）</li>
<li>どうやって有効だと検証した？</li>
<li>議論はある？（自分の研究との差異は？）</li>
<li>次に読むべき論文は？（他に知らなかった技術や概念は？）</li>
</ul>
<p>括弧内が自分用の問いかけである。
特に、「議論はある？」を「自分の研究との差異は？」に置き換えることで位置付けの整理を強く意識したまとめができるようになった点が気に入っている。</p>
<h2 id=まとめのためのツール>まとめのためのツール</h2>
<p>これまで論文管理には、<a href=https://www.mendeley.com/>Mendeley</a>を利用し、<a href=https://www.papershipapp.com/>PaperShip</a>と同期、必要に応じてiPadで書き込みを行っていた。</p>
<p>しかしながら、今回まとめには<a href=https://www.notion.so/>Notion</a>を別途利用した。
Notionは、論文への直接書き込みの場合の、十分な余白がない点や論文同士の関係性を横串で把握しにくかった点を解消してくれる。
Notionで、上述のアレンジ版落合メソッドを含んだテンプレートを用意し、サーベイDATABASEに論文ごとに1ページ作り、読みながらまとめを作っていく。</p>
<p>この時、最初からまとめようとすると論文全体を覚えておかなくてはならないので、自由に記入可能なメモ欄を用意して、読みながら、そちらにわかったこと疑問に思ったことなどを気楽に書いて、最後にまとめる方法をとっている。
メモ欄も残したままにしておくと後から読み直した時に記憶が蘇りやすいのでそのまま残している。</p>
<p>また、Notionでは各ページに対してPropertyを付与することで絞り込みができるため、会議名タグ、論文の発行年度、論文のURL、その論文を読んだ日付、キーワードのタグをPropertyとして設定している。</p>
<p><img src=/images/2021/05/notion_survey_template.png alt=notion-survey-template></p>
<h1 id=4-必要に応じて参考になる会議名キーワード参照論文を候補に追加>4. 必要に応じて参考になる会議名、キーワード、参照論文を候補に追加</h1>
<p>精読の中で、気になる会議名、キーワードが追加された場合、もう一度、1.の検索に戻り候補を追加する。
また、参照されている論文も候補に追加する。</p>
<p>コツとしては、追加された候補に対してすぐにアブストや精読を始めずに、候補として追加に止める事。
この追加した候補はまた新しい候補を増やすので、ゴールが見えなくなってしまうからである。
なので、最初に決めた候補まで読み切ってから、新しい候補の処理に着手すると気分的に進捗感が出て楽であった（これはまあ人による）。</p>
<h1 id=5-候補がなくなるまで繰り返す>5. 候補がなくなるまで繰り返す</h1>
<p>以上を候補がなくなるまで繰り返す。
参考文献が参考文献を呼んで終わらないのではないかと思われたが、2-3周もすれば新しい文献も出てこなくなってくる。
まとめの中で自身の研究が位置付けられてくるので、そこを一旦の止め時とした。</p>
<h1 id=まとめ>まとめ</h1>
<p>国際会議への投稿にあたって、自身の研究の位置づけを明確にするための論文サーベイの方法をまとめた。
今回は、最初のリストが243本、精読が47本であった。
会議を分けてサーベイすることで会議ごとに同じキーワードでも論文に特色があることなどが分かり興味深かった。
また、トップカンファレンスに限ることで、サーベイ効率も高まったと思う。
指導教官に感謝である。</p>
<p>Notion上の47ページの論文まとめは執筆中、何度も読み直したが自分なりのまとめメモが入っていること、自分の研究との位置づけが一言でまとめられていることから、効率よく記憶が蘇らせることができた。
結果として、複数の論文同士の関係性を整理するという目標に自身のリソースを采配することができたと思う。</p>
<p>一方で、キーワード検索では、既読管理と相性が悪いため、普段のインプットとしての継続的なサーベイには向かない。
RSSフィード的なインプットの方法を探したい。</p>
</div>
<footer class=tag>
<i class="fa fa-tags tag-icon"></i>
<ul>
<li><a class=tag-link href=/tags/%E8%AB%96%E6%96%87>論文</a></li>
</ul>
<div class=clear></div>
</footer>
</div>
</article>
<article>
<div class=post>
<header>
<h1><a href=https://blog.monochromegane.com/blog/2020/12/31/2020/>2020</a></h1>
<time><div class=day><i class="fa fa-calendar-o day-icon"></i>2020-12-31</div></time>
</header>
<div class=post-inner>
<p>今年は、なんと言っても、6月の初めてのジャーナル論文採録が文句なしに一番嬉しかった出来事だった。
ペパボ研究所に入って3年半。
本当に長かったし苦しかった。
それでもこの期間にたくさん自分自身や研究と向き合うことで、多くのものを得ることができたと思う。
今は、ただただ「巨人の肩に乗ることから逃げずに真摯に向き合い一歩づつ精進して」いる。</p>
<p>10月には、博士後期課程に挑戦し、無事に入学することができた。
12月のインターネットと運用技術シンポジウムではジャーナル論文の研究を発展させる手法が採録され、優秀プレゼンテーション賞も受賞することができた。
来年は国際会議に挑戦する。</p>
<p>長い暗中模索を抜けたが、スタートラインにやっと立てたとも言える。
遅れを取り戻すことを動機とはしないが、2021年は、可能な限り、適切な粒度で継続的に分野への貢献を出していきたい。
また、その貢献を通して周りの人へ直接的間接的に良い影響を与えたいと思う。</p>
<p>そのためにも、習慣と計画をうまく使い、仕組みによって淡々と自分を駆動していきたい。
2020年は1月末からリモートワークに完全移行したが、毎朝の論文読み会によって生活リズムが崩れることはなく研究に取り組めた。
毎日の業務後に進めるよう計画していた、大学基礎数学の参考書は、微分積分、線形代数、確率統計を一通りこなすことができた。
一方で、研究開発において、習慣と計画は適用が難しいと感じている。
研究には終わりがないため、どこまでの試行錯誤を区切りとするのか判断がつきにくい。
また、アイディアは無限にあるため、いろいろなことをやりたくなり、優先順位の判断がつきにくい。
つまり、全体をブレイクダウンしてルーティーンに落とし込むところに苦労している。
ここに関しては、研究日誌のような短期のアウトプットに加えて、もう少しだけ長い視点での判断をする機会を計画や習慣として組み込んでいきたい。
まずは、その観点でも指導教官や研究所のみんなにも相手になってもらおう。</p>
<p>2020年は光が見えた年だった。
2021年からは、この成果を普段から出せるよう、そして一つ上を目指せるようにしていこうと思う。
そして、その成果から行動の意義が伝わるような良い影響を与えられるようになりたいと思う。
来年もよろしくお願いします。</p>
<h1 id=実績>実績</h1>
<p>以下、実績を列挙する。</p>
<h2 id=表彰>表彰</h2>
<p>2020年は2回の表彰があった。
コミュニティ活動と研究活動の両面で表彰をいただくことができて、非常に嬉しい。</p>
<ul>
<li><a href=https://www.iot.ipsj.or.jp/awards/symposium/>IOTS2020 優秀プレゼンテーション賞</a>, 三宅 悠介, 栗林 健太郎, 変化検出と要約データ構造を用いた利用者の嗜好の変化に迅速に追従する多腕バンディット手法, 2020年12月.</li>
<li><a href=https://efc.fukuoka.jp/information/3116>エンジニアフレンドリーシティ福岡アワード コミュニティ部門</a>, 三宅 悠介,小田 知央, Fukuoka.go, 2020年1月.</li>
</ul>
<h2 id=論文>論文</h2>
<p>国内ジャーナル論文1本、査読付き論文1本。研究報告については第一著者のものが1本。
また、今年は研究報告のラストオーサーを2本務めた。</p>
<ol>
<li>三宅 悠介, 峯 恒憲, <a href="https://search.ieice.org/bin/summary.php?id=j103-d_11_764">Synapse: 文脈に応じて継続的に推薦手法の選択を最適化する推薦システム</a>, 電子情報通信学会論文誌D, Vol.J103-D, No.11, pp.764-775, Nov 2020.</li>
<li>三宅 悠介, 栗林 健太郎, <a href=http://id.nii.ac.jp/1001/00208105/>変化検出と要約データ構造を用いた利用者の嗜好の変化に迅速に追従する多腕バンディット手法</a>, インターネットと運用技術シンポジウム論文集, 2020, pp.1-8, Nov 2020. <a href=https://speakerdeck.com/monochromegane/iots2020-adaptive-linear-mab>[発表資料]</a></li>
<li>三宅 悠介, 栗林 健太郎, <a href=http://id.nii.ac.jp/1001/00206029/>非定常な多腕バンディット問題における変化検出アプローチの線形モデルへの拡張</a>, 研究報告インターネットと運用技術（IOT）, Vol.2020-IOT-50, pp.1-8, July 2020.<a href=http://localhost:4567/papers/iot50-miyakey.pdf>[論文]</a> <a href=https://speakerdeck.com/monochromegane/extension-of-change-detection-method-for-non-stationary-linear-multi-armed-bandit>[発表資料]</a></li>
</ol>
<h2 id=国内発表>国内発表</h2>
<p>技術イベント、研究会での発表で計６回（学会の研究会、シンポジウムを除く）。
Fukuoka.go、WSA研究会といったお馴染みのところに加え、GMOのテックカンファレンス、エンジニアフレンドリーシティ福岡のような声をかけていただいた登壇もあり、バランスは良かったと思う。
来年は、国際カンファレンス登壇が最初の目標だが、国内でも参加したことがない技術カンファレンスや勉強会なども挑戦してみたい。</p>
<ol>
<li>三宅 悠介 <a href=https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/>嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討</a>, <a href=https://wsa.connpass.com/event/187128/>Web System Architecture 研究会 (WSA研) #7</a>, 2020年11月.</li>
<li>三宅 悠介 <a href=https://speakerdeck.com/monochromegane/coherently-fittable-system>なめらかなシステムの実現に向けて</a>, <a href=https://www.gmo.jp/developersday/>GMO Developers Day 2020</a>, 2020年7月. [<a href=https://youtu.be/KW-YKuM1ndI>動画</a>]</li>
<li>三宅 悠介 <a href=https://speakerdeck.com/monochromegane/fukuokago-stage>Go言語でシミュレーション用のシンプルなフレームワークStageをつくった</a>, <a href=https://fukuokago.connpass.com/event/180414/>Fukuoka.go#16(オンライン開催)</a>, 2020年7月.</li>
<li>三宅 悠介 <a href=https://speakerdeck.com/monochromegane/wsa6-sifter>軽量なインデックス機構を用いた全文検索ツールの高速化の検討</a>, <a href=https://websystemarchitecture.hatenablog.jp/entry/2019/12/11/165624>Web System Architecture 研究会 (WSA研) #6</a>, 2020年4月.</li>
<li>三宅 悠介 <a href=https://speakerdeck.com/monochromegane/fukuokago15-adwin-exphist>Adaptiveなウィンドウを求めて 〜サーベイと実装 Go言語編〜</a>, <a href=https://fukuokago.connpass.com/event/164350/>Fukuoka.go#15 + 鹿児島Gophers(オンライン開催)</a>, 2020年3月.</li>
<li>三宅 悠介, 田中 孝明, 白石 憲正, 浜崎 陽一郎, 松口 健司 <a href=https://efc.fukuoka.jp/information/2562#day2_7>トークセッション / エンジニアと企業が描く未来のかたち</a>, <a href=https://efc.fukuoka.jp/information/2562>エンジニアフレンドリーシティ福岡フェスティバル</a>, 2020年2月.</li>
</ol>
<h2 id=oss>OSS</h2>
<p>変化検出の手法をはじめ、シミュレーションのフレームワークなど研究開発で取り組む分野の実装が増えてきた。</p>
<ul>
<li><a href=https://github.com/monochromegane/adwin-v>ADWIN-V</a>: ADWIN-V is an adaptive windowing algorithm for vector data.</li>
<li><a href=https://github.com/monochromegane/stage>stage</a>: Simple and flexible simulation framework for Go.</li>
<li><a href=https://github.com/monochromegane/sifter>sifter</a>: A lightweight index for full text search tools using bloom filter.</li>
<li><a href=https://github.com/monochromegane/adwin>adwin</a>: Adwin is an adaptive windowing algorithm.</li>
<li><a href=https://github.com/monochromegane/exponential-histograms>exponential-histograms</a>: Exponential histograms is a data structure for sliding windows.</li>
<li><a href=https://github.com/monochromegane/random_multivariate_normal>random_multivariate_normal</a>: Random number generator from a multivariate normal distribution.</li>
</ul>
<h2 id=コミュニティ活動>コミュニティ活動</h2>
<p>昨年度の活動や昨今の状況でのオンラインでの活動が評価され、表彰やインタビューを受ける機会をいただき非常にありがたいことであった。
一方で、Fukuoka.go自体の活動実績は2回と例年に比べかなり少なめであった。
オンライン開催での主催者側のモチベーションをどう維持するかも課題である。</p>
<ul>
<li>小田 知央,三宅 悠介,清家 史郎 <a href=https://efc.fukuoka.jp/interview/3704>勉強会はパーティーだ! ビール片手に楽しくGo言語を学ぶコミュニティ「Fukuoka.go」</a>, <a href=https://efc.fukuoka.jp/interview>ENGINEER INTERVIEW - Engineer Friendly City Fukuoka</a>, 2020年8月.</li>
<li><a href=https://fukuokago.connpass.com/event/180414/>Fukuoka.go#16 (オンライン開催)</a></li>
<li><a href=https://fukuokago.connpass.com/event/164350/>Fukuoka.go#15 + 鹿児島Gophers(オンライン開催)</a></li>
<li>三宅 悠介,小田 知央 <a href=https://dayori.city.fukuoka.lg.jp/129892/>エンジニアの技術向上に取り組むコミュニティ･企業を表彰 エンジニアフレンドリーシティ福岡アワード</a>, <a href=https://dayori.city.fukuoka.lg.jp/>福岡市政だより</a>, 2020年3月.</li>
</ul>
<h2 id=ブログ>ブログ</h2>
<p>13本。結果だけでなく、どうしてその考えに至ったかなど、その経緯、考えをまとめるカタチの文章をいくつか出すことができた。特に論文執筆のエントリのような自分なりのまとめは定期的に書いていきたいと思う。</p>
<ul>
<li><a href=https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/>嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/10/14/pen-tablet/>ペンタブレットでリモートワークのコミュニケーションを改善する</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/09/23/structure-of-research-paper/>構造を意識した抜け漏れがなく主張点が明確な論文執筆</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/09/21/isee-kyushu-u/>九州大学大学院システム情報科学府博士後期課程に入学します</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/>ペパ研から研究をはじめてジャーナルでのアクセプトまでいけた日</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/05/31/simulation-framework-stage/>Go言語でシミュレーション用のシンプルなフレームワークStageをつくった</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/05/16/bandit-algorithm-ucb1/>多腕バンディット問題におけるUCB方策を理解する</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/04/29/why-fukuokago/>なぜ勉強会「だった」のか</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/04/29/wsa6_sifter/>軽量なインデックス機構を用いた全文検索ツールの高速化の検討</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/03/11/dynamic-gamma-poisson/>Dynamic Gamma-Poisson modelを試す</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/03/03/minimum-start-for-online-event/>勉強会をオンライン配信するための必要最小限な環境構築</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/01/30/memo-getting-start-reinformation-learning-algorithm/>『強化学習アルゴリズム入門』第1章〜第2章の学習メモ</a></li>
<li><a href=https://blog.monochromegane.com/blog/2020/01/26/exhalation-and-coherently-fittable-system/>テッド・チャン『息吹』と「なめらかなシステム」</a></li>
</ul>
</div>
<footer class=tag>
<i class="fa fa-tags tag-icon"></i>
<ul>
<li><a class=tag-link href=/tags/%E3%81%B5%E3%82%8A%E3%81%8B%E3%81%88%E3%82%8A>ふりかえり</a></li>
</ul>
<div class=clear></div>
</footer>
</div>
</article>
<article>
<div class=post>
<header>
<h1><a href=https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/>嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討</a></h1>
<time><div class=day><i class="fa fa-calendar-o day-icon"></i>2020-11-17</div></time>
</header>
<div class=post-inner>
<p>このエントリは、<a href=https://wsa.connpass.com/event/187128/>第7回 Web System Architecture 研究会 (WSA研)</a>の予稿です。</p>
<h1 id=嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討>嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討</h1>
<h2 id=はじめに>はじめに</h2>
<p>適応的なシステムの実現には、システムが利用者の状況をよく知ることが重要になる。
ECサイトのシステムであれば、利用者の嗜好を把握することで、最適な商品を提案できると考えられる。</p>
<p>ECサイトのシステムが利用者の嗜好を把握するためには、特に初期段階における利用者との一定量のコミュニケーションが必要となる。
明示的なコミュニケーションであれば、システムは利用者に、年齢や居住地、興味関心などのプロファイルの登録を依頼する。
暗黙的なコミュニケーションであれば、システムは利用者の、閲覧や購買、検索履歴を通して利用者の嗜好を把握する。
システムはこれらのプロファイルの登録や履歴の蓄積なくして、適応的に振舞うことが難しい。
一方で、これらのコミュニケーションは利用者に負担を強いる。
これには、システムごとに発生するプロファイルの登録や履歴蓄積のための労力的な負担の他、プライバシーを守りたいという意識的な負担も考えられる。</p>
<p>本研究では、利用者の嗜好伝達に纏わるコミュニケーションの負担を低減しつつ、適応的なシステムによる利便性を常に享受できるインターネット世界に向けて、嗜好伝達コミュニケーションの効率化のための伝達方式の検討を行う。</p>
<h2 id=嗜好伝達コミュニケーションの課題>嗜好伝達コミュニケーションの課題</h2>
<p>嗜好伝達コミュニケーションの課題整理にあたり、本研究における「嗜好」を定義する。
まず、嗜好(preference)とは「利用者の素性(feature)」に基づく「対象(content)への反応(reaction)」と考える。</p>
<pre tabindex=0><code>preference(feature,content) #=&gt; reaction
</code></pre><p>対象(content)はシステムごと（ECサイトごと）に異なるため、嗜好伝達にはシステムごとに個別のコミュニケーションが求められる。
利用者の素性(feature)を示すか、直接、対象(content)への反応(reaction)を示す行為がこれに該当する。
推薦システムでは、利用者の素性(feature)を示す場合、類似する素性の群の反応を用いて利用者の嗜好が推測される。
対象(content)への反応(reaction)を示す場合、この反応から、もしくは類似する群から利用者の嗜好が推測される。</p>
<p>本研究では、この、利用者の素性(feature)の伝達か、対象(content)への反応(reaction)の伝達に纏わるコミュニケーションの効率化を検討する。</p>
<h3 id=利用者の素性featureの伝達の課題>利用者の素性(feature)の伝達の課題</h3>
<ol>
<li>システム内に限定された利用者の素性</li>
<li>適切なデータ構造が不明</li>
<li>プライバシー保護が必要</li>
</ol>
<p>「1. システム内に限定された利用者の素性」について、利用者の素性(feature)には人口統計的な情報だけでなく、行動データが考えられる。
利用者の素性をより知るためには、システムを横断して蓄積された行動データを得られることが望ましい。
しかしながら、通常、システムの把握可能な履歴はシステム内に限定される。
オンライン広告に見られるアドネットワークやオーディエンスデータの利用により、横断した行動を特定できる。
しかしながら、これらのcookieなどを用いた名寄せに関してはプライバシー保護意識の高まりもあり、代替手段を検討すべきである（要リファレンス）。</p>
<p>「2. 適切なデータ構造が不明」について、利用者の素性(feature)となり得る要因は無限に検討可能なことから、これを全てのシステムで共通に管理することは困難である。
例えば、訪問したサイトを利用者の素性として扱うとして、多次元のベクトルデータで表現すると、各次元とサイトの紐付けやサイトの追加削除を管理しなければならない。</p>
<p>「3. プライバシー保護が必要」について、人口統計的な情報だけでなく、行動データを含む利用者の素性は多くのセンシティブな情報を含むことから、利用者側が開示するにあたって内容の制限が求められるであろう。</p>
<h3 id=対象contentへの反応reactionの伝達の課題>対象(content)への反応(reaction)の伝達の課題</h3>
<ol>
<li>システム内に限定された利用者の嗜好</li>
<li>プライバシー保護が必要</li>
</ol>
<p>「1. システム内に限定された利用者の嗜好」について、前述の通り、プロファイルの登録や履歴蓄積のための労力的な負担が発生する。
対象(content)はシステム内に限定されるため、システムごとにその反応を提示しなければならない。
この時、利用者の嗜好をより知るためには、できるだけ多くの対象(content)に対する反応(reaction)を示せることが望ましいが、労力的な負担は比例して増加する。</p>
<p>「2. プライバシー保護が必要」について、利用者の嗜好傾向は（素性と比較して間接的ではあるものの）センシティブな情報を含むことから、利用者側が開示するにあたって内容の制限が求められるであろう。</p>
<h2 id=嗜好伝達コミュニケーションの効率化の検討>嗜好伝達コミュニケーションの効率化の検討</h2>
<h3 id=利用者の素性featureの伝達の効率化>利用者の素性(feature)の伝達の効率化</h3>
<p>本研究では、利用者の素性(feature)の伝達の効率化のため、人口統計的な情報だけでなく、システムを横断した行動データを局所管理するアプローチを検討する。
無限に検討可能な要因を共通して扱うため、Key-Value形式のデータ構造を採用する。
また、システムへの提示時に、このKey-Value形式のデータをBloomFilterに変換することでプライバシー保護を試みる。
すなわち、BloomFilterの偽陽性に着目した素性であるKeyを断定することができない特性を利用する。
また、BloomFilterが保存する要素数に依存しない特性を利用して、無限に検討可能な利用者の素性の要因を固定次元で扱うことができる。</p>
<p>なお、あるシステムに提示されるBloomFilterのパラメータは全ての利用者が同じものを用いる必要があるが、これらの共有方式についてはここでは検討しない。</p>
<h3 id=対象contentへの反応reactionの伝達の効率化>対象(content)への反応(reaction)の伝達の効率化</h3>
<p>本研究では、対象(content)への反応(reaction)の伝達の効率化のため、嗜好モデルを局所管理するアプローチを検討する。
提案手法では、システムを横断した行動データから、嗜好モデルを構築するローカルエージェントを設ける。
構築される嗜好モデルはこれまでの行動データから、未知の対象(content)への反応(reaction)を精度よく推測する。
ローカルエージェントは、このモデルを使い、システムに対する対象(content)への反応(reaction)の伝達を代理する。
具体的には、利用者が新しいシステムへのアクセスする際に、（システムが対応していれば）この嗜好モデルを使って、先方のシステムから示された大量の対象(content)への反応(reaction)を回答する。
先方のシステムは、十分な量のコミュニケーションを終え、利用者に利便性の高い状態から利用を開始してもらうことができる。
また、予めローカルエージェントの嗜好提示範囲に制限を持たせておくことで、プライバシー管理も行えると考える。</p>
<p>なお、これらの方式は検討段階であり、ローカルエージェント、嗜好モデルの具体的な実装はこれから検討していく。</p>
<h2 id=評価>評価</h2>
<h3 id=利用者の素性featureの伝達の効率化の評価>利用者の素性(feature)の伝達の効率化の評価</h3>
<p>提案手法の有効性を判断するため、BloomFilterに変換した素性によって嗜好情報の伝達能力を評価した。
評価として、素性を特徴量として用いた多腕バンディットのシミュレーションを行った。
元の素性と比較して提案手法の素性で、どの程度精度に変化があったかを確認した。</p>
<p>以下は、腕の数が30、密度（＊後述）10倍の実験設定の時の、BloomFilterの次元数と精度の変化を表している。
ここで、精度の変化とは、元の素性を使ったシミュレーションで選定された腕と同じ腕を選定できた割合を言う。</p>
<pre tabindex=0><code>1: 1.0
2: 0.60425
3: 0.424515
4: 0.38845
5: 0.35002
6: 0.32798
7: 0.335945
8: 0.307885
9: 0.31443
10: 0.317955
20: 0.311235
30: 0.3068
40: 0.320385
50: 0.30193
60: 0.31655
70: 0.33412
80: 0.319935
90: 0.309365
100: 0.33812
</code></pre><p>BloomFilterで表現された素性をコンテキスト情報として用いた推定には誤差が生じる。
そして、この誤差の増加はBloomFilterの偽陽性率の増加に従う。
今回の問題設定では、例えば100次元のバイナリベクトルを50次元のBloomFilterで表現することである（このような状態を本研究では密度2倍と考える）。
また、多腕バンディットでは腕の本数の増加に従い、不確実な状況において偶然当たる確率が下がる。
これらを考慮して、100次元のコンテキスト情報を10次元へ圧縮、30本の腕という問題設定でベストな腕を選択できた割合をサンプリングによって求めた。
結果として正しい腕を選択できたのは33%程度であった。
現実の推薦システムにおいてあり得る程度のスケールでも精度に対して大きな影響が発生することがわかった。</p>
<h3 id=対象contentへの反応reactionの伝達の効率化の評価>対象(content)への反応(reaction)の伝達の効率化の評価</h3>
<p>今後、実装と評価を行っていく。</p>
<h1 id=発表スライド>発表スライド</h1>
<p>発表後の議論では、アプローチに対する新規性や有用性について、また、Webサービスへの適用のアイディアについても話すことができ、今後にとって非常に有意義なものとなった。</p>
<h1 id=発表を終えて>発表を終えて</h1>
<p>今回のWSA研では、最初のアプローチの失敗で終わらず、やりたいことに立ち返り、より良いと思われるアプローチも検討できた点が良かったと思う。
長期間続く研究であればこそ、個々の結果に一喜一憂ではなく全体として進んでいけるよう全てを糧にしていきたい。</p>
<p>そして、このような研究のアイディア段階から前向きに意見を出し合うことができる機会を定期的に設けることができるWSA研はとても良いコンセプトの研究会だと思う。
何よりその時間はとても楽しい。</p>
<p>Webシステムアーキテクチャに関する運用知見を研究的アプローチで前進させること興味がある方は次回開催の参加を検討してみてはいかがでしょうか。</p>
</div>
<footer class=tag>
<i class="fa fa-tags tag-icon"></i>
<ul>
<li><a class=tag-link href=/tags/wsa%E7%A0%94>WSA研</a></li>
</ul>
<div class=clear></div>
</footer>
</div>
</article>
<a href=/post/ class=archives>Archives</a>
</div>
</div>
<footer class=footer>
<div class=author></div>
<p class=author-name><a href=https://twitter.com/monochromegane target=_blank>@monochromegane</a></p>
<p>monochromegane (モノクロめがね) と申します。</p>
<p>最近はもっぱらGoに夢中です。普段は研究開発をやっています。</p>
<ul class=social>
<li><a href=https://twitter.com/monochromegane target=_blank><i class="fa fa-twitter"></i></a></li>
<li><a href=https://github.com/monochromegane target=_blank><i class="fa fa-github"></i></a></li>
<li><a href=/index.xml target=_blank><i class="fa fa-rss"></i></a></li>
</ul>
<p class=copyright>
<small>&copy; <span>Powered by <a href=http://gohugo.io target=_blank>Hugo</a>, Designed by <a href=https://twitter.com/keita_kawamoto target=_blank>&copy;keita_kawamoto</a></span></small>
</p>
</footer>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/highlight.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/go.min.js></script>
<script src=//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.6/languages/vim.min.js></script>
<script>hljs.initHighlightingOnLoad()</script>
<script>(function(a,e,f,g,b,c,d){a.GoogleAnalyticsObject=b,a[b]=a[b]||function(){(a[b].q=a[b].q||[]).push(arguments)},a[b].l=1*new Date,c=e.createElement(f),d=e.getElementsByTagName(f)[0],c.async=1,c.src=g,d.parentNode.insertBefore(c,d)})(window,document,'script','//www.google-analytics.com/analytics.js','ga'),ga('create','UA-38374674-1','auto'),ga('send','pageview')</script>
</body>
</html>