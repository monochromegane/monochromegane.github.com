<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on THINKING MEGANE</title>
    <link>https://blog.monochromegane.com/post/</link>
    <description>Recent content in Posts on THINKING MEGANE</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language>
    <lastBuildDate>Fri, 25 Oct 2019 17:24:43 +0900</lastBuildDate>
    <atom:link href="/post/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>コマンドラインオプションをパースするコードをコマンドラインオプションから生成するツールをつくった</title>
      <link>https://blog.monochromegane.com/blog/2019/10/25/fukuokago14_flagen/</link>
      <pubDate>Fri, 25 Oct 2019 17:24:43 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/10/25/fukuokago14_flagen/</guid>
      <description>

&lt;p&gt;コマンドラインオプションの形式は決まったけれども、パース処理を実装するために各言語やライブラリのドキュメントを読むことを繰り返していたので、この手間を省くためのツールをつくりました。&lt;/p&gt;

&lt;iframe src=&#34;//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fmonochromegane%2Fflagen&#34; title=&#34;monochromegane/flagen&#34; class=&#34;embed-card embed-webcard&#34; scrolling=&#34;no&#34; frame border=&#34;0&#34; style=&#34;width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&#34;&gt;&amp;lt;a href=&#34;https://github.com/monochromegane/flagen&#34;&amp;gt;monochromegane/flagen&amp;lt;/a&amp;gt;&lt;/iframe&gt; 

&lt;p&gt;flagenは、先に決めたコマンドラインオプションから、これを解析するための各言語用のコードを出力するツールです。
オプション名から変数名や変数の型、デフォルト値が決定されるため、汎用的なボイラーテンプレートと比較して編集の手間が少なくなります。
また、テンプレートによって任意の出力を行えるため、エディタや自前のボイラーテンプレート出力ツールとの連携が容易です。
使いやすくするため、プリセットのテンプレートとしてGo、Ruby、Python、Shellのものを提供しています。&lt;/p&gt;

&lt;h1 id=&#34;使い方&#34;&gt;使い方&lt;/h1&gt;

&lt;p&gt;使い方は、テンプレートと実際に使う時のコマンドラインオプションを渡すだけです。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ flagen YOUR_TEMPLATE YOUR_COMMAND_LINE_OPTIONS...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例えば、&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ flagen go --dist erlang -e k/l --lambda 1.5 -k 1 -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;と指定すると、Go用のコマンドラインオプションの解析処理を出力します。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var (
	dist	string
	e	string
	lambda	float64
	k	int
	v	bool
)

func init() {
	flag.StringVar(&amp;amp;dist, &amp;quot;dist&amp;quot;, &amp;quot;erlang&amp;quot;, &amp;quot;usage of dist&amp;quot;)
	flag.StringVar(&amp;amp;e, &amp;quot;e&amp;quot;, &amp;quot;k/l&amp;quot;, &amp;quot;usage of e&amp;quot;)
	flag.Float64Var(&amp;amp;lambda, &amp;quot;lambda&amp;quot;, 1.5, &amp;quot;usage of lambda&amp;quot;)
	flag.IntVar(&amp;amp;k, &amp;quot;k&amp;quot;, 1, &amp;quot;usage of k&amp;quot;)
	flag.BoolVar(&amp;amp;v, &amp;quot;v&amp;quot;, false, &amp;quot;usage of v&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;指定されたコマンドラインオプションから変数名、オプション名、型、デフォルト値が設定されることで編集の手間が極力ない状態になっています。&lt;/p&gt;

&lt;p&gt;Python、Ruby、Shellの例は&lt;a href=&#34;https://godoc.org/github.com/monochromegane/flagen#pkg-examples&#34;&gt;GodocのExamples&lt;/a&gt;を参考にしてください。&lt;/p&gt;

&lt;h1 id=&#34;テンプレート&#34;&gt;テンプレート&lt;/h1&gt;

&lt;p&gt;テンプレートはGoの&lt;a href=&#34;https://golang.org/pkg/text/template/&#34;&gt;text/template&lt;/a&gt;を利用して解析されます。
テンプレート内では、&lt;code&gt;.Flags&lt;/code&gt;（解析したオプションの情報）と&lt;code&gt;.Args&lt;/code&gt;（残りのコマンドライン引数）が利用可能です。
&lt;code&gt;.Flags&lt;/code&gt;は&lt;code&gt;Name&lt;/code&gt;と&lt;code&gt;Value&lt;/code&gt;をもち、&lt;code&gt;Value&lt;/code&gt;は更に&lt;code&gt;Type&lt;/code&gt;と&lt;code&gt;Get&lt;/code&gt;をもちます。&lt;/p&gt;

&lt;p&gt;以下は、解析したオプションの情報を列挙するシンプルなテンプレート(my.tmpl)です。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{{ range $flag := .Flags -}}
  {{ $flag.Name }}={{ $flag.Value.Get}}({{ $flag.Value.Type }})
{{ end }}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ flagen my.tmpl --dist erlang -e k/l --lambda 1.5 -k 1 -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;このテンプレートから以下の出力を得ることができます&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dist=erlang(string)
e=k/l(string)
lambda=1.5(float)
k=1(int)
v=false(bool)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、テンプレート内では文字列のケース変換のための関数を利用することができます。
主に変数を言語の命名規約に合わせるのに使えます。
使える関数は、&lt;a href=&#34;https://godoc.org/github.com/monochromegane/flagen#pkg-variables&#34;&gt;こちら&lt;/a&gt; で確認ください。&lt;/p&gt;

&lt;h1 id=&#34;連携&#34;&gt;連携&lt;/h1&gt;

&lt;h2 id=&#34;vim&#34;&gt;Vim&lt;/h2&gt;

&lt;p&gt;flagenの結果は標準出力を使っているため、エディタとの連携も容易です。
例えば、Vimでは以下により、カーソル位置に結果を挿入することができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;:r!flagen YOUR_TEMPLATE YOUR_COMMAND_LINE_OPTIONS...
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;ボイラーテンプレート出力ツール&#34;&gt;ボイラーテンプレート出力ツール&lt;/h2&gt;

&lt;p&gt;flagenはライブラリとして利用することができるため、自前のボイラーテンプレート出力ツールがGo製であれば以下のように呼び出すことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;	tmpl, err := flagen.NewTemplate(args[0])
	if err != nil {
		return err
	}
	return tmpl.Execute(outStream, args[1:])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;また、独自の関数が必要な場合は &lt;code&gt;flagen.TemplateFuncMap&lt;/code&gt;に設定することでテンプレート内で利用することができます。&lt;/p&gt;

&lt;h1 id=&#34;ワークアラウンド&#34;&gt;ワークアラウンド&lt;/h1&gt;

&lt;h2 id=&#34;曖昧なフラグ&#34;&gt;曖昧なフラグ&lt;/h2&gt;

&lt;p&gt;flagenはオプションに値が指定されていないときにboolだと見なすため、以下のようにboolフラグで終わって引数がある場合に判断がつきません。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ flagen TEMPLATE --bool-flag arg1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;想定どおりにするためには値としてtrue or falseを受け取ることを明示する必要があります。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ flagen TEMPLATE --bool-flag=false arg1
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;様々な実装が提供されているコマンドラインオプションの解析処理を利用形式から動的に生成するジェネレーターとしてflagenをつくりました。実際にいくつかの言語のテンプレートを用意してエディタと連携させることでCLI開発の効率が改善しています。&lt;/p&gt;

&lt;p&gt;今後はflagen自体のオプションとしてprefixなどを提供すれば構造体の変数に設定する用途などのテンプレートとの相性もよくなりそうだと考えています。
便利なテンプレート追加のプルリクエストやイシュー、ボイラーテンプレートのツールへ組み込んだ報告などお待ちしています。&lt;/p&gt;

&lt;h1 id=&#34;fukuoka-go&#34;&gt;Fukuoka.go&lt;/h1&gt;

&lt;p&gt;このツールは&lt;a href=&#34;https://fukuokago.connpass.com/event/146447/&#34;&gt;Fukuoka.go#14+Umeda.go&lt;/a&gt;で発表しました。
発表資料はこちらです。&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;ece61cadb91e46febd8b692e32a8679f&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>待ち行列理論に使われる分布に従う乱数をGo言語で生成する</title>
      <link>https://blog.monochromegane.com/blog/2019/10/11/random_number_gen_using_go/</link>
      <pubDate>Fri, 11 Oct 2019 09:42:13 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/10/11/random_number_gen_using_go/</guid>
      <description>

&lt;p&gt;待ち行列理論をシミュレーションする際にいくつかの分布に従う乱数を生成する必要があったのでメモ．
また，確率まわりの用語と分布についても理解が曖昧な点があったのでこの機会にまとめておく．&lt;/p&gt;

&lt;h1 id=&#34;用語の整理&#34;&gt;用語の整理&lt;/h1&gt;

&lt;h2 id=&#34;確率&#34;&gt;確率&lt;/h2&gt;

&lt;p&gt;確率は，&lt;/p&gt;

&lt;p&gt;\[
  \frac{ある事象の起こる場合の数}{全ての事象の起こる場合の数}
\]&lt;/p&gt;

&lt;p&gt;で求められる．&lt;/p&gt;

&lt;h2 id=&#34;確率変数&#34;&gt;確率変数&lt;/h2&gt;

&lt;p&gt;確率変数は，事象に対応した実数のこと．
確率変数には，離散型と連続型の二種類がある．
サイコロの出目のようなものは離散型で，身長や体重のような（原理的には）連続の値になるものは連続型．&lt;/p&gt;

&lt;h2 id=&#34;確率分布&#34;&gt;確率分布&lt;/h2&gt;

&lt;p&gt;確率分布は確率と確率変数との対応付け．
そもそも辞書的な意味での「分布」は「粗密の程度を含めた，空間的な広がり具合」を表す．
度数分布では階級と度数（階級に含まれる変量の数）の対応付けであった．
また，これらの分布は，度数分布と同様に確率分布表や確率分布グラフとして表すことができる．&lt;/p&gt;

&lt;h2 id=&#34;確率を返す関数&#34;&gt;確率を返す関数&lt;/h2&gt;

&lt;p&gt;ここで，ある確率変数を入力に，対応する確率を出力する関数を考える．&lt;/p&gt;

&lt;h3 id=&#34;確率質量関数&#34;&gt;確率質量関数&lt;/h3&gt;

&lt;p&gt;離散型の確率変数であれば，確率分布表を照会し，対応する確率を得ることができる．
確率変数を入力に，対応する確率を出力する関数を確率質量関数（または確率関数）[1]と言い，サイコロの出目を確率変数$X$とした時に1が出る確率を$P(X=1)=\frac{1}{6}$のように書ける．
もちろん確率の総和は1である．&lt;/p&gt;

&lt;h3 id=&#34;確率密度関数&#34;&gt;確率密度関数&lt;/h3&gt;

&lt;p&gt;連続型の確率変数の場合は，ある一点の値を入力とすると対応する確率は常に0となる．
これは，ある範囲においても実数は無限個あるため，全事象が無限になることから，確率の定義より$\frac{1}{\infty}=0$となるためである．
このように連続型の確率変数からは直接的に確率を求めることができないので，この連続型の確率変数を対応する「何か」に変換する必要がある．
また，その「何か」は確率に変換できる必要がある．
確率の定義から，総和は1である．
また，連続型の確率変数であることから，和は積分で求めることになる．&lt;/p&gt;

&lt;p&gt;連続型の確率変数をx軸に，この連続型の確率変数を対応する「何か」をy軸にプロットした時に，ある範囲の割合は該当範囲の定積分によって導くことができる．
そして，全体の積分が1で，その中のある範囲の定積分が，事象がその範囲に含まれる確率に従うような「何か」があれば，それを連続型の確率変数の確率に用いることができる．
そのような「何か」が存在するとき，「何か」は「確率密度」と呼ばれ，連続型の確率変数を入力とし，確率密度を出力する関数を「確率密度関数」と呼ばれる[2]．&lt;/p&gt;

&lt;p&gt;このとき，確率密度関数$f(x)$に従う確率変数$X$が$(a \leqq X \leqq b)$となる確率は\[\int_a^b f(x) dx\]のように書ける．&lt;/p&gt;

&lt;p&gt;確率密度は，その確率変数の相対的な発生のしやすさを表すに過ぎないので，部分的にy軸(確率密度関数の返す値)が1を超えても構わない（全体の面積として1になれば良い．例えば，確率密度関数が$f(x)=2x (0 \leqq X \leqq 1)$のときなど）．&lt;/p&gt;

&lt;h1 id=&#34;待ち行列理論で使う分布&#34;&gt;待ち行列理論で使う分布&lt;/h1&gt;

&lt;p&gt;待ち行列理論では待ち行列のモデルの構造を以下のようなケンドール記号を用いて記述する．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;X/Y/S(N)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ここでXは到着過程の種類，Yはサービス過程の種類，Sは窓口数，Nは待ち行列の長さの制限数が入る．
過程の種類は以下の通り．&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;種類&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;th&gt;備考&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;M&lt;/td&gt;
&lt;td&gt;マルコフ過程&lt;/td&gt;
&lt;td&gt;到着過程ならポアソン分布，サービス過程なら指数分布&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;D&lt;/td&gt;
&lt;td&gt;確定分布&lt;/td&gt;
&lt;td&gt;到着間隔やサービス時間が一定&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;G&lt;/td&gt;
&lt;td&gt;一般の分布&lt;/td&gt;
&lt;td&gt;平均値と分散が既知の任意の分布&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$E_k$&lt;/td&gt;
&lt;td&gt;アーラン分布&lt;/td&gt;
&lt;td&gt;k個の指数分布の和の分布&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;ポアソン分布&#34;&gt;ポアソン分布&lt;/h2&gt;

&lt;p&gt;単位時間に平均$\lambda$回起きる事象が単位時間に$k$回発生する分布[3]．&lt;/p&gt;

&lt;p&gt;平均が$\lambda$のポアソン分布を表す確率質量関数は\[P(X=k)=\frac{\lambda^{k}}{k!}\cdot e^{-\lambda}\]であり平均$E[X]$は$\lambda$となる．&lt;/p&gt;

&lt;h2 id=&#34;指数分布&#34;&gt;指数分布&lt;/h2&gt;

&lt;p&gt;平均$\theta$時間に一回発生する事象の発生間隔を表す分布[4]．&lt;/p&gt;

&lt;p&gt;平均が$\theta$の指数分布を表す確率密度関数は\[f(x)=\frac{1}{\theta}e^{-\frac{x}{\theta}} (x \geqq 0)\]であり平均$E[X]$は$\theta$となる．&lt;/p&gt;

&lt;h3 id=&#34;待ち行列とマルコフ過程&#34;&gt;待ち行列とマルコフ過程&lt;/h3&gt;

&lt;p&gt;あるランダムに起きる事象を発生回数から見たのがポアソン分布，発生間隔(または時間)から見たのが指数関数とみなすことができる．
マルコフ過程は未来の挙動は過去の挙動とは無関係であるとする性質を持つ確率過程であり，これらの分布が適合するため利用されている．&lt;/p&gt;

&lt;p&gt;単位時間に$\lambda$回到着するとした到着過程はポアソン分布が利用されるが，シミュレーションにおいては平均到着間隔を知りたい．
この場合は，$\frac{1}{\lambda}$を到着間隔とした指数分布で求めることができる（1時間に平均5人くる場合，平均1/5時間(12分)の間隔で到着する）．
つまり，$\theta=\frac{1}{\lambda}$として，確率密度関数は\[f(x)=\lambda e^{-\lambda x} (x \geqq 0)\]であり平均$E[X]$は$\frac{1}{\lambda}$となる．&lt;/p&gt;

&lt;p&gt;なお，ポアソン分布と指数分布の関係の理解には[5]が参考になる．このサイトでは時刻$t$を導入したポアソン分布の累積分布関数から指数分布の確率密度関数を導いている．&lt;/p&gt;

&lt;h2 id=&#34;アーラン分布&#34;&gt;アーラン分布&lt;/h2&gt;

&lt;p&gt;まず，ガンマ分布は平均$\theta$時間に一回発生する事象（指数分布）が$k$回発生するまでの時間の分布[6]である．
ガンマ分布の$k=1$のとき，指数分布と等しく，$k$が整数の場合にアーラン分布と呼ばれる．&lt;/p&gt;

&lt;p&gt;ガンマ分布を表す確率密度関数は\[\frac{1}{\Gamma(k)\theta^{k}}x^{k-1}e^{-x/\theta}\]であり平均$E[x]$は$k\theta$となる．&lt;/p&gt;

&lt;p&gt;また，前述のポアソン分布のパラメタから指数分布の確率密度関数を求めたのと同様に，$\theta=\frac{1}{\lambda}$として，確率密度関数は\[\frac{\lambda^k}{\Gamma(k)}x^{k-1}e^{-\lambda x}\]であり平均$E[x]$は$\frac{k}{\lambda}$とも書ける．&lt;/p&gt;

&lt;p&gt;ここまで，$k$回の$\theta=1/\lambda$の指数分布を場合を見てきたが，待ち行列理論の書籍においては，$k$回の$\frac{\theta}{k}=\frac{1}{k\lambda}$の指数分布としている場合がある．
すなわち，一つのサービス時間$\theta$が$k$個の工程（1工程あたり$\frac{\theta}{k}$）からなるとみなしている．
この場合，確率密度関数は\[\frac{(k\lambda)^k}{\Gamma(k)}x^{k-1}e^{-k\lambda x}\]であり平均$E[X]$は$\theta=1/\lambda$となる．&lt;/p&gt;

&lt;h1 id=&#34;待ち行列理論で使う分布に従う乱数&#34;&gt;待ち行列理論で使う分布に従う乱数&lt;/h1&gt;

&lt;p&gt;ここでは，ある分布に従う乱数をGoでの生成する．&lt;/p&gt;

&lt;h2 id=&#34;指数分布-1&#34;&gt;指数分布&lt;/h2&gt;

&lt;p&gt;指数分布に従う乱数はGoの標準パッケージ&lt;a href=&#34;https://golang.org/pkg/math/rand/#Rand.ExpFloat64&#34;&gt;math/randで提供&lt;/a&gt;されている．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Exponential(rnd *rand.Rand, lambda float64) float64 {
        return rnd.ExpFloat64() / lambda
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;パラメタ$\theta=1/\lambda$に合わせるためには結果を$\lambda$で割る（平均到着率が増えるほど平均到着間隔は狭くなる）．&lt;/p&gt;

&lt;p&gt;動作確認のため，生成した乱数のヒストグラムと指数分布の確率密度関数を重ねてプロットした．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2019/10/hist_and_pdf_exponential.png&#34; alt=&#34;hist_and_pdf_exponential&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;ポアソン分布-1&#34;&gt;ポアソン分布&lt;/h2&gt;

&lt;p&gt;ポアソン分布に従う乱数はGoの標準パッケージで提供されていない．
そこで指数分布とポアソン分布の関係性を利用して，指数分布で得られた乱数の和が1を超えるまでの最小のカウント数を用いる方法がある[7][8]．
例えば平均到着率($\lambda$)が5人であれば，平均到着間隔($1/\lambda=0.2$)である．
ここでカウントは$0.2*5$が平均して得られると考えられる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Poisson(rnd *rand.Rand, lambda float64) float64 {
        p := 0.0
        for i := 0; ; i++ {
                p += Exponential(rnd, lambda)
                if p &amp;gt;= 1.0 {
                        return float64(i)
                }
        }
        return 0.0
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;生成した乱数のヒストグラムとポアソン分布の確率質量関数のプロット．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2019/10/hist_and_pmf_poisson.png&#34; alt=&#34;hist_and_pmf_poisson&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;アーラン分布-1&#34;&gt;アーラン分布&lt;/h2&gt;

&lt;p&gt;アーラン分布もしくはガンマ分布に従う乱数はGoの標準パッケージで提供されていない．
しかし，ガンマ分布の定義（k個の指数分布の和の分布）[6]から以下の実装が可能である．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func ErlangKL(rnd *rand.Rand, lambda float64, k int) float64 {
        g := 0.0
        for i := 0; i &amp;lt; k; i++ {
                g += Exponential(rnd, lambda)
        }
        return g
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで，&lt;code&gt;KL&lt;/code&gt;は平均が$\frac{k}{\lambda}$であることを表している．&lt;/p&gt;

&lt;p&gt;生成した乱数のヒストグラムとアーラン分布の確率密度関数のプロット．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2019/10/hist_and_pdf_erlangkl.png&#34; alt=&#34;hist_and_pdf_erlangkl&#34; /&gt;&lt;/p&gt;

&lt;p&gt;待ち行列理論の参考書にあるようなサービス工程を$k$個に分割するアーラン分布では$k$回の$\frac{\theta}{k}=\frac{1}{k\lambda}$の指数分布となることから以下の実装となる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;func Erlang1L(rnd *rand.Rand, lambda float64, k int) float64 {
        g := 0.0
        for i := 0; i &amp;lt; k; i++ {
                g += Exponential(rnd, float64(k)*lambda)
        }
        return g
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ここで&lt;code&gt;1L&lt;/code&gt;は平均が$\frac{1}{\lambda}$であることを表している．&lt;/p&gt;

&lt;p&gt;生成した乱数のヒストグラムとアーラン分布の確率密度関数のプロット．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2019/10/hist_and_pdf_erlang1l.png&#34; alt=&#34;hist_and_pdf_erlang1l&#34; /&gt;&lt;/p&gt;

&lt;h1 id=&#34;動作確認用のコード&#34;&gt;動作確認用のコード&lt;/h1&gt;

&lt;p&gt;動作確認用のコードは以下にある．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/monochromegane/be5b872b3aa71d1a314a8b8bb74be60b&#34;&gt;main.go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://gist.github.com/monochromegane/13123f681db5cf376e79b854cfdec5ba&#34;&gt;plot.py&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;このような感じで利用できる．&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;go run main.go -size 100000 -dist erlang -e k/l -lambda 0.5 -k 2 &amp;gt; data.txt &amp;amp;&amp;amp; python plot.py --dist erlang -e k/l --lambda 0.5 -k 2
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;[1] &lt;a href=&#34;https://ja.wikipedia.org/wiki/%E7%A2%BA%E7%8E%87%E8%B3%AA%E9%87%8F%E9%96%A2%E6%95%B0&#34;&gt;確率質量関数 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[2] &lt;a href=&#34;https://ja.wikipedia.org/wiki/%E7%A2%BA%E7%8E%87%E5%AF%86%E5%BA%A6%E9%96%A2%E6%95%B0&#34;&gt;確率密度関数 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3] &lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%83%9D%E3%82%A2%E3%82%BD%E3%83%B3%E5%88%86%E5%B8%83&#34;&gt;ポアソン分布 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[4] &lt;a href=&#34;https://ja.wikipedia.org/wiki/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83&#34;&gt;指数分布 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[5] &lt;a href=&#34;http://www.f-denshi.com/000TokiwaJPN/17kakto/100prob.html&#34;&gt;ときわ台学/統計学/ポアソン分布と指数分布&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[6] &lt;a href=&#34;https://ja.wikipedia.org/wiki/%E3%82%AC%E3%83%B3%E3%83%9E%E5%88%86%E5%B8%83&#34;&gt;ガンマ分布 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[7] &lt;a href=&#34;https://www.ishikawa-lab.com/montecarlo/4shou.html&#34;&gt;どんな分布の乱数でも作り出せる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[8] &lt;a href=&#34;https://nineties.github.io/math-seminar/14.html&#34;&gt;擬似乱数の生成法・推定 - プログラマの為の数学勉強会&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kaburaya AutoScaler: 多環境での運用性を考慮した自律適応型オートスケーリング制御系</title>
      <link>https://blog.monochromegane.com/blog/2019/10/04/wsa5_kaburaya_autoscaler/</link>
      <pubDate>Fri, 04 Oct 2019 15:19:40 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/10/04/wsa5_kaburaya_autoscaler/</guid>
      <description>

&lt;p&gt;このエントリは、&lt;a href=&#34;https://websystemarchitecture.hatenablog.jp/entry/2019/07/30/172650&#34;&gt;第五回 Web System Architecture 研究会 (WSA研)&lt;/a&gt;の予稿です。&lt;/p&gt;

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Webサービスの運用において，急激なアクセス頻度の上昇に対する安定性を保つため，Webアプリケーションにスケーラビリティの仕組みが一般的に求められるようになった．
これを支援するためにWebアプリケーションを稼働させるクラウドサービスやオーケストレーションツールから，オートスケーリング機能が提供されている．
これらのオートスケーリング機能では，開発運用者が予め定めた条件を元にWebアプリケーションの状況が監視される．
そうして，条件を満たせば，開発運用者が予め定めたスケール方法とその実施量に従いWebアプリケーションをスケールさせる．&lt;/p&gt;

&lt;p&gt;このようにオートスケーリングによって，ユーザからのリクエスト数の増減に応じて最適なサーバ台数を調整されることで利用者の快適さと情報システムの運用コストを両立できるようになった．
一方で，オートスケーリングを導入し，継続的に安定した運用するためには開発運用者の運用努力が必要であるが，これらは管理する環境の増加に従い困難になる．
そのため，多環境での運用性を考慮した自動化可能なオートスケーリング戦略が求められる．&lt;/p&gt;

&lt;p&gt;オートスケーリングの継続的に安定した運用に向けた課題は大きく二つある．
一つ目は，アプリケーション特性の把握，二つ目は，“遅れ”の考慮である．&lt;/p&gt;

&lt;h2 id=&#34;課題1-アプリケーション特性の把握&#34;&gt;課題1: アプリケーション特性の把握&lt;/h2&gt;

&lt;p&gt;スケールにはWebアプリケーションを稼働する仮想サーバへリソースを追加する垂直スケール（スケールアップ），稼働する仮想サーバを追加する水平スケール（スケールアウト）の2種類の方法がある．
しかしながら，どちらの方法を用いるにせよ，開発運用者はWebアプリケーションの特性に応じたオートスケーリングの条件やその実施量を予め定める必要がある．
例えば，時刻ベースであればアクセス頻度の時系列的傾向や，リソース変動ベースであればボトルネックとなるメトリクスである．
また，これらの条件に対する必要台数の算出も必要となる．
Webアプリケーションは常に変更が加わることから，手動での継続的な特性の把握と決定は運用負荷の面で現実的ではない．&lt;/p&gt;

&lt;p&gt;そこで，特性把握の自動化が行われている．
三宅らは，過去のアクセス頻度のデータからLSTMを用いて24時間先までの1時間単位のアクセス頻度を予測するモデルを構築し，予測アクセス頻度を元に経験から得られたサーバ単位のスループットにより必要なサーバ台数を求めた[1]．
スループットの把握では，パラメタを連続的に変化させながら最良の結果を得る値を探索的に求める方法も提案されている[2]．
これらの予測的，探索的なアプローチによる特性把握の自動化により，変化する環境に対する追従性は向上する．
一方で，事前的なアプローチであるため，予測の誤差，探索を行った環境と本番環境の誤差に対処できないという課題が残る．&lt;/p&gt;

&lt;p&gt;そのため，三宅らはフィードバック制御による個別の特性把握を必要としないアプローチ[3][4]を提案した．
この手法では，直近のレスポンスタイムが均衡する点に収束するような台数調整によって特性把握が不要で実行時に誤差を修正することができる．
ただし，フィードバック制御を用いるため，制御量であるサーバ台数の決定は探索的である．
待ち行列理論によれば窓口利用率が1を超えると待ち行列は収束しないとされていることから，サーバ台数は即時かつ決定的に求められることが望ましい．&lt;/p&gt;

&lt;h2 id=&#34;課題2-遅れ-の考慮&#34;&gt;課題2: “遅れ”の考慮&lt;/h2&gt;

&lt;p&gt;オートスケーリングでは，本番環境の誤差に対応するための即応的なアプローチを採用すると&amp;rdquo;遅れ&amp;rdquo;の課題が発生する．
一つ目の遅れは，負荷上昇からサーバ台数を見積もるまでの時間差である．
本稿ではこれを「入力の遅れ」と呼ぶ．
次はサーバ台数の変更指示から起動までの時間差である．
本稿ではこれを「出力の遅れ」と呼ぶ．
待ち行列理論によれば窓口利用率が1を超えると待ち行列は収束しないとされていることから，これらの遅れに対して発生した待ちリクエストが系の安定性を崩す．
安定性の低下は開発運用者による不定期な対応を要請し，運用負荷につながることからこれを回避する必要がある．&lt;/p&gt;

&lt;p&gt;そのために，遅れを最小化する手法が適用される．
入力の遅れでは，変化点検出などにより負荷上昇を即時に察知する方式がある．
また，出力の遅れではCRIUを利用することで起動までの時間を短縮する方式[5]がある．
しかしながら，精度の観点やシステム制約によって遅れを0にはできないため，遅れそのものに対する対策は必要となる．&lt;/p&gt;

&lt;p&gt;遅れを踏まえた準備では，前述の予測的なアプローチが考えられる．
三宅らの手法[1]では，予測と事前起動によりこれらの遅れを考慮するが，本番環境の誤差への課題が残る．
そこで，スミスの予測法[6]のようにフィードバック制御において遅れによる影響を踏まえた制御量を算出する手法がある．
一方で，予測のためには精度の高い予測モデルの構築が必要であり，追従にはここの自動化が必須となる．&lt;/p&gt;

&lt;h1 id=&#34;提案手法&#34;&gt;提案手法&lt;/h1&gt;

&lt;p&gt;多環境での運用性を考慮したアプリケーション特性の把握の自動化と安定性の両立のためには，以下の要件が必要となる．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Webアプリケーション特性として負荷に対する実施量の関係が把握できる&lt;/li&gt;
&lt;li&gt;これを不必要な負荷をかけることなく実行時に自動で把握できる&lt;/li&gt;
&lt;li&gt;把握したWebアプリケーション特性と実環境に誤差が生じた場合に修正できる&lt;/li&gt;
&lt;li&gt;これを実現するリアクティブなアプローチで発生する”遅れ”へ対処できる&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;そこで，フィードフォワード制御を中心とし，実環境の特性把握・追従のためにフィードバック制御を組み込んだ2自由度のオートスケーリング制御系を提案する．
提案手法により，特性把握・追従の自動化ならびに待ち行列理論を用いた決定的な台数算出・遅れ補償による安定化が見込める．
なお，本提案手法の実装はKaburaya AutoScalerとして，OSSでの公開・開発を続けている．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/monochromegane/kaburaya-autoscaler&#34;&gt;monochromegane/kaburaya-autoscaler&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;提案手法では，Webアプリケーション特性を求めるにあたって低負荷時では理想的なレスポンスタイム，高負荷時ではスループット限界を用いることで対象のWebアプリケーションに不必要な負荷をかけることなく現状に即したWebアプリケーション特性を把握することができる．
また，仮想サーバ起動までの遅れに伴う負荷状況を予測し，これを見越した実施量を見積もる遅れ補償機構を設けた．&lt;/p&gt;

&lt;p&gt;提案手法のアーキテクチャを以下に示す．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/65784527-35289080-e18d-11e9-98eb-a155ed8967cc.png&#34; alt=&#34;Kaburaya AutoScaler Architecture&#34; /&gt;&lt;/p&gt;

&lt;p&gt;ここで$F$はフィードフォワード制御部である． 現状の負荷状況に応じて実施量であるサーバ台数を算出する．
算出には待ち行列理論の窓口利用率を求める式を変形した$\lambda/\rho\mu$を用いる．
なお，$\lambda$は平均到着率（req/単位時間），$\mu$は平均サービス率（req/単位時間），$\rho$は窓口利用率を表す．
提案手法では$\rho$には0より大きく1未満の任意の値を設定することができる．&lt;/p&gt;

&lt;p&gt;$P$はプラントであり，$F$で求めたサーバ台数を用いて実際にWebサービスを運用する実環境である．
提案手法では実環境の計測誤差をフィードバックすることで自動かつ継続的な安定性を保つ． $P$は計測結果として単位時間での平均レスポンスタイムである$T_s$と単位時間での1台あたりの処理数である$\mu$を返却する．
これらの値は，$F$における新しい$\mu$に用いられる．&lt;/p&gt;

&lt;p&gt;提案手法では仮想サーバ起動までの遅れに伴う負荷状況を予測し，これを見越した実施量を見積もる遅れ補償機構を設けた．
待ち行列理論では無限時間の平均した待ち時間を求めるため，窓口利用率が1以上の場合に発散し，理論を適用することができない．
一方で，遅れ時間は有限であることから，窓口利用率が1以上の場合であっても待ち行列の長さを求めることができると考えた．
そこで$(\lambda^{t-1}-s^{t-1}\mu^{t-1})\gamma$のように不足処理能力による待ち行列の長さとて加えて，これを捌くことができるサーバ台数を求めている．&lt;/p&gt;

&lt;h1 id=&#34;評価&#34;&gt;評価&lt;/h1&gt;

&lt;p&gt;プラントのシミュレータを使って提案手法によるオートスケーリングの自律・適応の性能を評価した．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/65784472-16c29500-e18d-11e9-9fee-718bac3bbdbd.png&#34; alt=&#34;Evaluation&#34; /&gt;&lt;/p&gt;

&lt;p&gt;右下のグラフにより$\mu$の推定・追従が行えていること，左上のグラフにより遅れ補償が働きアクセス増加時に一時的に多いサーバを投入することで収束できていることが確認できる．
個別の評価についてはスライドを参照されたい．&lt;/p&gt;

&lt;h1 id=&#34;発表スライド&#34;&gt;発表スライド&lt;/h1&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;f71a76ce6cbf454ab583d968916df2b8&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;本研究会ではオートスケーリングと開発運用者間の関係をなめらかにするための多環境での運用を考慮した自律適応型オートスケーリング制御系を提案した．
評価ではM/M/Sモデルを前提としたプラントシミュレータによってこれらが達成可能なことを示した．
実用化に向けて今後はプラントに実際のWebサーバ/アプリケーションサーバを適用した評価や実際の到着，サービス時間間隔に近い分布での評価が必要である．
また，提案手法では入力の遅れに伴い単位時間内に待ちリクエストが必ず発生するため変化点検出などで遅れ時間自体を短縮する方式も検討したい．&lt;/p&gt;

&lt;h1 id=&#34;発表を終えて&#34;&gt;発表を終えて&lt;/h1&gt;

&lt;p&gt;今回のWSA研究会もとても面白かった．
Webシステムアーキテクチャという題材で色々な分野の人が集まって議論することで持ち寄ったアイディアが前進して行くのを何度も見ている．
自分自身の取り組みも研究としてWSA#3からWSA#4を通してGopherConで登壇できるぐらいに育った．
加えて，今回は，オートスケーリングの課題に着目して新しいアプローチを試してみる中で，制御工学や待ち行列理論などを学び楽しめた．
このような普段の研究から少し離れた取り組みであっても，定期的に発表を促されることで形にすることができるのはとても大切で，やりっぱなし学びっぱなしではなく一つの区切りまで考え実装することで次回以降の研究への糧となる．
Webシステムアーキテクチャに関する運用知見を研究的アプローチで前進させること興味がある方は次回開催の参加を検討してみてはいかがでしょうか．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://websystemarchitecture.hatenablog.jp/entry/2017/11/16/182041&#34;&gt;Web System Architecture研究会の発足と挨拶&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://websystemarchitecture.hatenablog.jp/purpose&#34;&gt;研究会の目的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;リファレンス&#34;&gt;リファレンス&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;[1]: 三宅 悠介, 松本 亮介, 力武 健次, 栗林 健太郎, アクセス頻度予測に基づく仮想サーバの計画的オートスケーリング, FIT 2018 第17回情報科学技術フォーラム, CL-002, Sep 2018.&lt;/li&gt;
&lt;li&gt;[2]: 全自動パラメータチューニングさん &lt;a href=&#34;https://blog.mirakui.com/entry/2013/02/20/003401&#34;&gt;https://blog.mirakui.com/entry/2013/02/20/003401&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;[3]: Yusuke Miyake, Optimization for Number of goroutines Using Feedback Control, GopherCon Marriott Marquis San Diego Marina, California, July 2019.&lt;/li&gt;
&lt;li&gt;[4]: 三宅 悠介, Ebira: アクセス負荷に応じて継続的にスケーリング基準を最適化する汎用オートスケーリング機構, 第四回 Webシステムアーキテクチャ研究会, 2019年4月.&lt;/li&gt;
&lt;li&gt;[5]: 松本 亮介, 近藤 宇智朗, CRIUを利用したHTTPリクエスト単位でコンテナを再配置できる低コストで高速なスケジューリング手法, 研究報告インターネットと運用技術（IOT）, Vol.2019-IOT-44, pp.1-8, Feb 2019.&lt;/li&gt;
&lt;li&gt;[6]: O. Smith, &amp;ldquo;Closer control of loops with dead time&amp;rdquo;, Chemical engineering progress, Vol. 53, No. 5, pp. 217-219, 1957.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>初めて海外カンファレンス登壇するためにやったこと</title>
      <link>https://blog.monochromegane.com/blog/2019/08/11/toward_the_oversea_conference/</link>
      <pubDate>Sun, 11 Aug 2019 16:57:47 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/08/11/toward_the_oversea_conference/</guid>
      <description>

&lt;p&gt;7/24から27にかけてアメリカ、サンディエゴで開催されたGopherCon 2019で人生初となる海外カンファレンスに登壇してきました（発表の様子は&lt;a href=&#34;https://blog.monochromegane.com/blog/2019/08/10/gophercon_2019/&#34;&gt;こちら&lt;/a&gt;にまとめました）。
GopherConはGo関連で最大級の国際カンファレンスです。
6年目となる今年は世界中から1,800名のGopherが参加し、200名以上の応募の中から選ばれた36名がスピーカーとして登壇しました。
その中で、僕は「Optimization for Number of goroutines Using Feedback Control」というタイトルで45分の&lt;a href=&#34;https://www.gophercon.com/agenda/speakers/442434&#34;&gt;チュートリアルセッション&lt;/a&gt;を務めました。&lt;/p&gt;

&lt;p&gt;これまで海外カンファレンス登壇経験はなく、英語にも不慣れであるものの、現在の自分にとって非常に重要な位置付けのイベントであり、1月のCfPから7月の発表に至るまでの長丁場を非常に高い優先度で取り組んできました。
これらの取り組みについて、自分自身の次の登壇への振り返りとして、何より今後、僕と同じように海外カンファレンス登壇を目指す方にとって何かしら参考になればと思いまとめておきます。&lt;/p&gt;

&lt;h1 id=&#34;採択に向けて&#34;&gt;採択に向けて&lt;/h1&gt;

&lt;h2 id=&#34;投稿のネタを育てておく&#34;&gt;投稿のネタを育てておく&lt;/h2&gt;

&lt;p&gt;まずは話すネタがなければ投稿できません。
普段の業務やOSS活動で得た生の経験や実績は、頭の中にあるだけではやがて自分にとって当たり前になり輝きを失っていきます。
そのため、普段から忘れないように登壇ネタとしてメモしておくだけでも有効です。
ただ、実際には、ブログや国内の勉強会での登壇などを通して、カタチを与えて上げておくと良いと思います。
このアウトプット作業に暗黙的に含まれる他人に伝えるという制約によって、ただの経験が洗練されてよそゆきの顔になっていくからです。
つまり、曖昧だったり複雑な部分を解きほぐし自分の理解が深まることで提案や動機付けに対する説得力が生まれます。&lt;/p&gt;

&lt;p&gt;今回の僕のネタは、幸いにもこの機会に恵まれました。
関連研究も含めるとWSA研究会とGoCon東京の計3回の発表とフィードバックを通して（現在進行形で）育てています。&lt;/p&gt;

&lt;h2 id=&#34;投稿のネタを選ぶ&#34;&gt;投稿のネタを選ぶ&lt;/h2&gt;

&lt;p&gt;どのようなネタであってもぜひ挑戦させてあげてください。
採択される可能性が限りなく高いネタはあっても絶対に通るネタはないのではないかなと思います。
なぜならカンファレンスの特徴や査読者のバックグラウンド、他の発表とのバランスなど採択には色々なパラメタも影響するからです。
なので、僕は&lt;a href=&#34;https://twitter.com/tenntenn&#34;&gt;@tenntenn&lt;/a&gt;さんのこのスタンスで良いと思います。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;CfPに応募する時の1番の秘訣は自分で諦めないこと。自分って案外自分に厳しいので、このレベルじゃ駄目でしょと決めつけがち。選ぶのは自分じゃないし、落ちてもデメリットないので応募するのが一番得。&lt;/p&gt;&amp;mdash; tenntennʕ ◔ϖ◔ʔ ==Go (@tenntenn) &lt;a href=&#34;https://twitter.com/tenntenn/status/1113254427488509954?ref_src=twsrc%5Etfw&#34;&gt;April 3, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;提出することで査読者からのフィードバックがもらえることもありますし、カンファレンス登壇に興味があればまずは応募してみましょう&amp;hellip;!&lt;/p&gt;

&lt;p&gt;ただし、発表実現性が著しく低いものは避けましょう。
発表までに実装や評価は間に合いますか？（採択されたら当日までにやることは他にもたくさんあります）
プロポーザルを書くコスト、査読するコストは発表実現性が高いものへ。&lt;/p&gt;

&lt;h2 id=&#34;プロポーザルの書き方を学ぶ&#34;&gt;プロポーザルの書き方を学ぶ&lt;/h2&gt;

&lt;p&gt;いかにして提案を査読者にアピールするかは重要であり難しい取り組みです。
ただし、査読者が求める事項は一般に共通しており、それゆえにベストプラクティスはあります。
今回、僕は@tenntennさんから教えてもらった以下のサイトに目を通してプロポーザル執筆に臨みました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://carolynvanslyck.com/blog/2018/12/talk-at-gophercon/&#34;&gt;Submit a Talk to GopherCon!&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://medium.com/@fox/how-to-write-a-successful-conference-proposal-4461509d3e32&#34;&gt;How to write a successful conference proposal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://dave.cheney.net/2017/02/12/how-to-write-a-successful-conference-proposal&#34;&gt;How to write a successful conference proposal (by Dave Cheney)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://russolsen.com/articles/2012/06/21/acing-the-technical-talk-getting-your-proposal-through-the-door.html&#34;&gt;Talking Tech: Getting Your Proposal Through the Door&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.builderscon.io/entry/2017/05/09/090000&#34;&gt;おすすめなカンファレンス用プロポーザルの書き方&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;もちろん対象のカンファレンスの選考基準も目を通します。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;The selection criteria:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Relevance. The talk is relevant to the Go community. GopherCon is not a general software conference, our audience wants to hear about topics that relate to the Go programming language.&lt;/li&gt;
&lt;li&gt;Clarity. You’ve clearly explained what you are going to talk about.&lt;/li&gt;
&lt;li&gt;Correctness. You’ve demonstrated knowledge of your topic. You don’t have to be an expert, but you are expected to be speaking from experience.&lt;/li&gt;
&lt;li&gt;Achievability. You’ve thought about how to present your material in the time available.&lt;/li&gt;
&lt;li&gt;Impact. The goal of the talk. What new idea, technique, tool, or information will the audience leave your presentation with?&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;僕はこの辺の書き方は論文執筆と同じだなあという感想を持ちました。
つまり、提案の新規性、有用性、信頼性などをわかりやすい構成で伝える技術です。
一方で、上で引用したGopherConの選考基準では、「専門家である必要はないが経験から語ることが期待される」と言う文言がありました。
これは一般論で終わらないことを伝えていると捉えられますが、やったことをそのまま出せばいいというわけでもないはずです。
つまり、経験から得られたものを一般化したり、潜在的な課題へと結びつけて、より多くの人に何かを持ち帰ってもらえるように思考することが求められます。
そういう意味ではやはり論文執筆に通じるものを感じます。&lt;/p&gt;

&lt;p&gt;ただ、先の選考基準は「自分で」敷居を上げすぎるなという側面もあるとは思っていて、まずやったことを書く、それから上記を意識しながら少しづつ改善していくことが大切なのだろうと思います。&lt;/p&gt;

&lt;h2 id=&#34;プロポーザルを書く&#34;&gt;プロポーザルを書く&lt;/h2&gt;

&lt;p&gt;プロポーザルの書き方に従い、選んだネタを使ってプロポーザルを書きます。
英語に慣れていない場合はまず日本語で書くと良いと思います。
問題をわかりやすく整理して、可読性の高い構成にするのは難しい仕事なので、日本語で作って英語にする方が結果的に時間的・品質的に満足できるからです。&lt;/p&gt;

&lt;p&gt;提案型の場合、汎用的には以下のような流れで文字数制限に応じて分量を調整していけると思います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1. 現状（現状における問題の定義。つまり理想状態との差）&lt;/li&gt;
&lt;li&gt;2. 背景（定義した問題に対する従来のアプローチの整理。それらのアプローチの持つ課題を&amp;rdquo;自分なりに&amp;rdquo;整理）&lt;/li&gt;
&lt;li&gt;3. 提案（その課題を解決する方法を提案）&lt;/li&gt;
&lt;li&gt;4. 評価（提案手法の有効性を評価する方法、あれば結果を含める）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;従来ツールによる解決であれば、3はそのツールの紹介に、4は導入事例になります。
いずれにせよ、このようにしておくと各ステップの検討事項が分離できるので順番に議論すれば後戻りが発生しません。
つまり査読者の思考の流れを妨げません。
理想状態を念頭に、解決したい本当の問題と、従来アプローチの制約事項をうまく分離してあげるように考えるのがコツでしょうか。
これは難しいので投稿ネタを育てる工程で意識しながら繰り返しやっておくと良いと思います。
なお、論文だと理想状態がなぜ理想なのかの説明も求められるので大変ですが、エンジニア系のカンファレンスだとコンテキストが共有できているのでそこに文字数を割かなくても大丈夫です。
また、エレベータピッチなどの極端に文字数が少ない場合は、1の理想と2の整理した課題だけを述べて3に繋げています（4は含めない）&lt;/p&gt;

&lt;p&gt;参考までに、僕が今回提出したプロポーザルを下記に置いておきます。
タイムテーブルのセクションは@tenntennさんの以前のプロポーザルを参考にさせてもらいました。
査読者目線からも、提案の整合性や発表内容に対する時間配分の妥当性などが分かるのでとても良いセクションだと思います。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/monochromegane/conference-proposals/blob/master/2019-07-24-gophercon-2019.md&#34;&gt;Proposal for GopherCon 2019&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;プロポーザルを英語化する&#34;&gt;プロポーザルを英語化する&lt;/h2&gt;

&lt;p&gt;まず、Google翻訳に放り込みたくなる気持ちをぐっと我慢します。
Google翻訳の進歩は目覚ましいですが、元となる日本語の文章に曖昧な点があるとどうしても翻訳の精度は下がります。
また、係り受けの複雑な日本語の文章も、いたずらに長い文章へ翻訳され、文字数あたりの情報量が減ることもあるでしょう。
査読者の思考を妨げないためには、簡潔で明解な英語文章が必要です。
そのためには、元の日本語の文章を以下の点でチェックすると良さそうです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;主語・述語があるか&lt;/li&gt;
&lt;li&gt;主語・述語がねじれていないか&lt;/li&gt;
&lt;li&gt;事実か意見かが判断できるか&lt;/li&gt;
&lt;li&gt;係り受けが適切か（不要な修飾を減らす、修飾順番を整理）&lt;/li&gt;
&lt;li&gt;文章が複数の主張を含んでいないか（文の分割を検討）&lt;/li&gt;
&lt;li&gt;接続助詞（〜が、〜て、〜ので）は従属節との関係を曖昧にしていないか（厳密な接続助詞への変更か文を分割）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;校正後の日本語文章に対しては、比較的短く基本的な構文だけで英作文ができるはずです。
なお、専門用語や言い回しについては、普段から興味のある分野で論文や技術書を英語のものを読んで、レパートリーを増やしておくと良いです（自戒を込めて）。&lt;/p&gt;

&lt;h2 id=&#34;ギリギリの提出を避ける&#34;&gt;ギリギリの提出を避ける&lt;/h2&gt;

&lt;p&gt;提出時期は早ければ早いほど良いでしょう。
今回、締め切りの5日前に提出しましたが、アーリーフィードバックとして、セッション枠の変更（25分ではなく45分へ）をはじめとする幾つかの提案をもらいました。
これが締め切り寸前だと、もらえなかったかもしれず、そうすると時間に対するコンテンツ過剰によって発表の実現性が低く採点され、採択されなかった可能性もあります。&lt;/p&gt;

&lt;p&gt;実際、投稿数の遷移について、締め切り3日前が87、前日で130、当日の中間発表で192のように駆け込みで投稿数が一気に増える様が伝えられています。
査読者数も限界があるため、締め切り前の全員分にアーリーフィードバックを返せないとすると、提出は早いほうがオススメです。&lt;/p&gt;

&lt;p&gt;僕がもらったフィードバックはこのようなものでした。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;I have some early feedback from the reviewers. The general feeling is this is too much content to cover in a 25 minute keynote slot and may not be generally applicable to the full audience. The recommendation from the reviewers is to revise this proposal as a 45 minute tutorial session

You can edit your proposal at any time before the end of the month. Best of luck!
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;英語学習&#34;&gt;英語学習&lt;/h1&gt;

&lt;p&gt;英語によるコミュニケーションは普段からの積み重ねが全てです（はい&amp;hellip;）。
この章に関しては誇れるものではないので参考までにお読みください。&lt;/p&gt;

&lt;p&gt;僕の場合、発作的に英語をやって身につかずに終わるというのを長年繰り返していました。
そこで、今回、&lt;a href=&#34;https://www.progrit.co.jp/&#34;&gt;PROGRIT&lt;/a&gt;という英語コーチングサービスを使ってカリキュラムを組んでもらい継続的な学習をサポートしてもらうことにしました。
結構なお値段（いやほんと）します。
カリキュラムも画期的な手法というよりは地道にやることで効果が見込める王道のものを組み合わせていて、これを如何に継続してやり抜くかをサポートすることがサービスのコアかなと感じます。
なので、自分にあった勉強法を見つけて継続してやれている方にとってはあまり意味のないサービスかもしれません。
とはいえ、前述の英語に対する僕のニーズにはあっていたので今回利用しました。
結果的に、Versantという英語コミュニケーション能力を図るテストは3ヶ月のカリキュラムを終えて5点上がり（TOEICだと75点UPぐらい？）、やはり継続は力だなと感じています。&lt;/p&gt;

&lt;h2 id=&#34;カリキュラム&#34;&gt;カリキュラム&lt;/h2&gt;

&lt;p&gt;最終的に日々のカリキュラムは以下のように落ち着きました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;瞬間英作文(60min)&lt;/li&gt;
&lt;li&gt;単語(30min)&lt;/li&gt;
&lt;li&gt;シャドーイング(45min)&lt;/li&gt;
&lt;li&gt;多読(45min)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;登壇と質疑応答、そしてスピーカーディナーで自分の考えを述べられることを目標に進めました。
英文法についてはなんとか理解しているものの、それらを「使う」ことの準備がほぼできていないことが分かったため、そこを補強するカリキュラムとなっています。
つまり、英語を使ったコミュニケーションに必要な、文章や単語を通した概念と音声の変換に関する、知覚と瞬発力を鍛えます。&lt;/p&gt;

&lt;p&gt;まず単語は何をやるにも基礎となるのでひたすらボキャブラリを増やします。
僕はキクタンを使って自分のレベルにあったものから進めました。
一方で、発表に向けては普段から興味のある分野で論文や技術書を英語のものを読んで、ボキャブラリを増やしておくと良いのだろうなとも思いました。&lt;/p&gt;

&lt;p&gt;次に、概念と文章をつなぐ瞬発力向上のために、瞬間英作文をやりました。
機械的に翻訳するような平易なものを瞬間で解くのはパズルのようで面白いですが、繰り返すと飽きてくるので覚えた英単語と組み合わせたりして応用するものいいかもしれません。&lt;/p&gt;

&lt;p&gt;逆に、文章を概念につなぐ瞬発力向上には、多読をやりました。
戻り読みをしないという制約で、なるべく意味を理解しながらなるべく速く読みます（85%ぐらい理解しつつ1分あたり何word読めるかのスコアを伸ばす）。
音が明確に聞こえたとしても（つまりテキストとして渡されたとしても）それを読んで理解できるスピード以上には意味理解が追いつかないよねという経験を経てこれも頑張るようになりました。
自分にあったレベルのやつでやらないと途端につまらなくなるので教材選びが大事かも。&lt;/p&gt;

&lt;p&gt;音と文章（単語）をつなぐ知覚向上にはシャドーイングをやりました。
英語音源をテキストを見ずに少し遅れて聞こえたまま繰り返すという学習法です。
30秒から60秒ぐらいの音源を1日50回とか繰り返しました&amp;hellip;
最初は聞こえないし口がついていかないしで「こんなんできるかボケ」と面談で悪態をついてばかりいたのですが、最終的にはこれがヒアリング力の向上につながったと思っています。
では素直にヒアリング練習で良いのではないかと思えますが、口が回るようになったところが聞こえるようになるという経験を経て、頑張って繰り返すようになりました。
また、多読と並行することで、こちらでは意味理解よりも知覚に集中できるようになったのも良かったです。
以前に比べれば耳の解像度が上がったんじゃないかなあとVersantを前後で受けて見て思えます。&lt;/p&gt;

&lt;p&gt;文章（単語）と音をつなぐ発話、発音は今回やっていません。
最初の面談で、まあ全く通じないというわけではないでしょうということで、上記のものを優先して進めました。
とはいえ、実際の発表ではやはりもう少しうまく発音できたらなあと思うこともあったので引き続きやっていこうと思います。&lt;/p&gt;

&lt;p&gt;また、オンライン英会話についても（少ししか）やっていません。
本当は実践が一番なのでしょうが、あまりにも引き出しが少ないと英会話の時間が苦痛になるため、英語学習がだれてきた時のカンフル剤としてたまにやる感じにして基礎を頑張りました。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;毎日3時間を確実に取れたわけではなく、発表前は資料作成の方へ専念したりもしましたが、それなりの時間を投入しながらも全然使いこなせる感じがしないので、英語学習は奥が深いなあと思います。
それでも続けることで成果は出るので地道にやっていきましょう。&lt;/p&gt;

&lt;h1 id=&#34;発表資料&#34;&gt;発表資料&lt;/h1&gt;

&lt;p&gt;資料は一ヶ月ぐらい前から作り始めました。
日本語の元となる資料があることだし十分余裕を持って着手したつもりでしたが、もう少し早くに着手しても良かったなというのが終わって見ての感想です。
理由は母国語に頼らず説明するためには、資料の刷新と英語スクリプトの準備が必要だったからです。
更には、発表練習についても日本語で行う時よりも何倍も時間をかける必要がありました。
ですので、国際カンファレンスに臨むにあたっては余裕を持った準備をお勧めします（実際には渡航のための準備ややるべき仕事もありますし）。&lt;/p&gt;

&lt;h2 id=&#34;発表資料-1&#34;&gt;発表資料&lt;/h2&gt;

&lt;p&gt;スライドの構成は、基本的にプロポーザルの内容に沿うことになります。
先ほどの例であれば、イントロダクション（現状、背景）、提案、評価、まとめの流れが王道でしょうか。&lt;/p&gt;

&lt;p&gt;大きなカンファレンスでの発表資料はイントロダクションを少し工夫すると良いかもしれません。
なぜなら同じカンファレンスであっても参加者が多い場合は個々のバックグラウンドや問題意識が多様であり、導入部分で揃えておかなければならないからです。
具体的には、トークの対象となるキーワードや問いなどを簡潔な形で伝えます。
GopherConでは、キーワードを端的に表す写真とともに、「〜のような経験はないか」のような共感を引く導入が多かったように思えました。
僕の資料では、少し前提が複雑だったので、最初の立てた問いをいくつかの実験結果を通して変化させていくような導入にして、より詳しい問題意識を共有するような作りにしました。&lt;/p&gt;

&lt;p&gt;また、各所の構成はやや冗長であっても、大枠を示してから詳細に移るのを意識しました。
これは聴衆が置いてけぼりになることを避けるためです。
もちろん母国語の資料であっても気をつけるべきところではありますが、残念ながら、英語力が足りない場合、細かなフォローアップがその場その場でできないこともあり、資料の時点でその工夫はしておいた方が良いと思われます。
簡単な例であれば、例えば解決したい課題が3つあるならば、先に列挙してそれらに番号を振っておくでもいいですし、解決編では先にゴールを述べておくでも良いと思います。
僕の資料では、簡単なアプローチから出発して少しづつ課題を解決していくようにすることで、比較的複雑な箇所の説明の際に飛躍がないよう気をつけました。&lt;/p&gt;

&lt;p&gt;図で説明できるものは図を用意する方が良いと思います。
ただし、図に頼って文章を考えなくていいわけではないので、あくまで聴衆の理解を助ける機会をできるだけ増やすという意識で用意します。&lt;/p&gt;

&lt;p&gt;細かい点ですが、ページ番号は必ずスライドテンプレートに組み込んでおきましょう。
質疑の時のやりとりがスムーズになります。
また、ページ番号もそうですが、グラフの凡例なども視認できる大きさのフォントにしておくのも大切です（僕のは凡例が小さかった）&lt;/p&gt;

&lt;p&gt;僕の発表資料はこちらです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://speakerdeck.com/monochromegane/optimization-for-number-of-goroutines-using-feedback-control&#34;&gt;Optimization for Number of goroutines Using Feedback Control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;発表者ノート-英語スクリプト&#34;&gt;発表者ノート（英語スクリプト）&lt;/h2&gt;

&lt;p&gt;英語に不慣れな場合は、一度、発表者ノート（英語スクリプト）を書き出しておくのをお勧めします。
発表者ノートを作成する利点は以下の通りです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;曖昧な箇所や飛躍がある点を潰すことができる&lt;/li&gt;
&lt;li&gt;原稿段階で英語話者に並行してチェックしてもらえる&lt;/li&gt;
&lt;li&gt;発表の再現性が高まる（特に時間）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;いずれも伝えるべきことを全て伝えられるようにするために必要なことだと思います。
そのため、暗記するにしても読み上げるにしても、英語スクリプトは作っておく方が良いでしょう。&lt;/p&gt;

&lt;p&gt;Keynoteであれば発表者ノート機能で手元に写しながら発表に臨むことができます。
ただし、演台があるか手元にPCが置けるかなどは事前に問い合わせて確認しておきましょう。&lt;/p&gt;

&lt;p&gt;発表原稿では以下を気をつけました。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;章や節の始めに、ここでは何を説明するのかを一言で伝える。&lt;/li&gt;
&lt;li&gt;章や節の終わりに、ここで伝えたかったことのサマリ、次に何を説明するかを一言入れる。&lt;/li&gt;
&lt;li&gt;1ページあたりの文章が多いのであればページの分割を検討する（発表時に発表者ノートをスクロールするのは結構大変）&lt;/li&gt;
&lt;li&gt;平易な文で記述する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最後の平易な文については、自分の理解できるレベルの文章でスクリプトを作っておくということです。
発表時は発表者ノートに釘付けで話すわけにはいかないため、さっと見て、ある程度自分自身で意味がわかる文法や単語で構成していないと、強調する文章なのか判断つかずに読み上げる不自然な感じになってしまいます。
不慣れな言語でも自分自身が納得して説明できるように書いておきましょう（残念ながらここの段階で急には英語力は伸びません）。&lt;/p&gt;

&lt;p&gt;また、できるだけ英語話者に原稿はチェックしてもらうと良いでしょう。
結構な分量になるので、知り合いに頼むとかよりもできるだけお金を払って英文校正サービスなどでチェックをすると良いと思います。
僕の場合は、先ほどのコーチが買って出てくれたのでお願いできました（コーチによるのでこれを期待してPROGRIT申し込まないように）&lt;/p&gt;

&lt;p&gt;僕の英語スクリプトはこちらです。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.monochromegane.com/blog/2019/08/10/gophercon_2019/&#34;&gt;GopherCon 2019: Optimization for Number of goroutines Using Feedback Control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;発表練習&#34;&gt;発表練習&lt;/h2&gt;

&lt;p&gt;英語に不慣れな場合、暗記かスクリプトの読み上げになってしまいますが、一本調子だと聴衆はどこで共感するか反応するかの情報量が少なくなり混乱してしまいます。
その余裕を持つために、英語スクリプトを自分自身で意味がわかる文法や単語で構成することを提案しました。
それでもまだ目が滑ってしまう場合は、文に区切りを入れるのも良いでしょう。
区切りは関係詞や節の間で適当な単語数のところで入れました（変なところで区切ると逆に不自然になるので気をつけます）&lt;/p&gt;

&lt;p&gt;僕の発表者ノートはこんな感じになっています。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-txt&#34;&gt;I am developing a fast grep tool / named &amp;quot;the platinum searcher&amp;quot;.
One day I conducted a measurement / of the optimal number of goroutines / to achieve good performance.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;そして、定型の言い回し（I found that など）なるべく流暢にしたり、強調したいところは少しゆっくり大きく言うような工夫を入れました。&lt;/p&gt;

&lt;p&gt;ただし、これはあくまで、僕の場合のネイティブの発音じゃない状態で文全体を早口で言うよりはこの方が伝わる可能性が高いねとコーチと試行錯誤した結果です。
つまり「今の」英語力でできるだけ伝えるための工夫であり、本来は継続的な英語の学習によって自然な状態に近づけていくようにすることが大切だと思います。&lt;/p&gt;

&lt;p&gt;あとは、英語話者もしくは読み上げ機能で録音した音源を繰り返し聞き、繰り返し練習します。
また、良く出てきたり重要な単語は個別に練習しておくと良いでしょう（僕の場合はperformanceやdetermineなど）&lt;/p&gt;

&lt;h2 id=&#34;資料のバックアップ&#34;&gt;資料のバックアップ&lt;/h2&gt;

&lt;p&gt;現地の環境がわからないので、資料は複数の手段でアクセスできるようにしておくべきです。
GopherConの場合は、持参したPCとプロジェクタとの接続がうまくいかない場合に備えて、USBメモリにファイルをバックアップしておくよう指示がありました。
僕は発表者ノートが見れない状況を想定して念のため日本でスクリプトを印刷してカバンに忍ばせておきました。
また現地の発表練習では、代替機がMacとは限らないのでPDFや画像ファイルといったポータブルな形式にしたり、クラウドストレージやSpeakerdeckにアップロードしておいたりスクリプトもクラウドストレージにアップロードしてiPhoneから見れるようにしておいてもいいかもねとコメントもらいました。&lt;/p&gt;

&lt;h1 id=&#34;渡航&#34;&gt;渡航&lt;/h1&gt;

&lt;p&gt;アメリカの場合、パスポートの他にESTAの申請が必要なので忘れないようにしましょう。
何もなければパスポートは10日間、ESTAは2週間ほどで発行・承認されますが、ギリギリにやると不測の事態に対応できないため、採択されたらすぐ申請ぐらいでいいと思います。
渡航前は発表練習であまり余裕ないので&amp;hellip;&lt;/p&gt;

&lt;p&gt;また、海外渡航に不慣れな人は時差ボケを解消する時間も込みで日程を組むことを忘れないようにしましょう。
僕は時差-16時間のサンディエゴで発表でしたが、現地時間の前日入り(日本の7/24 夕方発 現地7/24午前着)してしまい、翌日のお昼すぎ(&lt;sup&gt;7&lt;/sup&gt;&amp;frasl;&lt;sub&gt;25&lt;/sub&gt; 日本時間 午前6時)という時差ボケが激しい時間帯に発表になってしまいました。
@tenntennさんに「なんてやんちゃな日程だ」と言われてしまった&amp;hellip;
この場合は最低でももう一日前(日本の7/23 夕方発 現地7/23午前着)して、翌日(&lt;sup&gt;7&lt;/sup&gt;&amp;frasl;&lt;sub&gt;24&lt;/sub&gt;)で日中眠らずに現地時間に合わせて当日(&lt;sup&gt;7&lt;/sup&gt;&amp;frasl;&lt;sub&gt;25&lt;/sub&gt;)に合わせるぐらいがいいらしいです。
時差ボケは自分の発表だけでなく、他の発表を聞くときの集中力にも影響してくるのでできるだけ万全の体制で臨めるようにしたいものです。&lt;/p&gt;

&lt;p&gt;現地の移動はタクシーではなくUberを使いました。
Uberであれば、アプリから先に行き先を入力し、評価の高いドライバーを選択し、金額を確定しておくことができます。
Comfort系を選ぶとちょっと高いですがゆったりした車になるので複数名の場合はそちらを選ぶと良いみたいです。
サンディエゴだと大体10分ほどで来てくれます。
ドライバの現在地、車種とナンバーが事前に分かっているので、それを探します。
また、アプリは画面に色がつくので、その画面を振ってドライバに見つけてもらう感じです。
移動はアプリで現在地が分かるため安心です（そもそも事前に金額確定なので遠回りして稼ぐような動機がない）。
日本でアプリをインストールし、クレジットカードまで登録しておくと良いでしょう。
それから、自分のアカウントにきちんと顔写真登録しておく方が良いみたいです（ドライバーさん側への安心感かな？）
決済は到着後にプッシュ通知が来るのでチップの額を上乗せして終了です。便利便利。&lt;/p&gt;

&lt;h1 id=&#34;発表&#34;&gt;発表&lt;/h1&gt;

&lt;p&gt;あとはこれまでやって来たことを信じて発表するだけです。
せっかく自分の提案を国際カンファレンスで聞いてもらえる機会なので楽しんでいきましょう。
会場の雰囲気はとても良く、とても積極的に聞いてくれます。
なぜならカンファレンスに来ている人は、上手い下手をジャッジしに来てるのではなくて、僕たちの提案を経験をできるだけ聞きたいと言う姿勢で来てくれているからです。
どうしても緊張する人は、前方の10人だけをターゲットに最初の挨拶を元気に言うことだけ考えましょう。
あとは練習した通りに体と口が動いてくれます。&lt;/p&gt;

&lt;p&gt;発表後は、おそらく色々なところで質問や感想のために声をかけてもらえます。
これはスピーカーとしてカンファレンスに参加したときの特典なので是非とも活かしたいところです。
ですので、余裕があれば想定問答や提案のサマリ、自己紹介などを事前にまとめておくと良いと思います。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherCon 2019で初の海外カンファレンス登壇をしてきました</title>
      <link>https://blog.monochromegane.com/blog/2019/08/10/gophercon_2019/</link>
      <pubDate>Sat, 10 Aug 2019 20:52:57 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/08/10/gophercon_2019/</guid>
      <description>

&lt;p&gt;7/24から27にかけてアメリカ、サンディエゴで開催された&lt;a href=&#34;https://www.gophercon.com/home&#34;&gt;GopherCon 2019&lt;/a&gt;で人生初となる海外カンファレンスに登壇してきました。&lt;/p&gt;

&lt;p&gt;GopherConはGo関連で最大級の国際カンファレンスです。
6年目となる今年は世界中から1,800名のGopherが参加し、200名以上の応募の中から選ばれた36名がスピーカーとして登壇しました。
今回のGopherConではPre-Conference Workshopと呼ばれるカンファレンス前日に終日行われるワークショップと、カンファレンス期間中に行われる25分のキーノートセッション、そして45分のチュートリアルセッションがありました。
その中で、僕は「Optimization for Number of goroutines Using Feedback Control」というタイトルで45分の&lt;a href=&#34;https://www.gophercon.com/agenda/speakers/442434&#34;&gt;チュートリアルセッション&lt;/a&gt;を務めました。&lt;/p&gt;

&lt;h1 id=&#34;動画&#34;&gt;動画&lt;/h1&gt;

&lt;iframe width=&#34;560&#34; height=&#34;315&#34; src=&#34;https://www.youtube.com/embed/O_R7Nwsix1c&#34; frameborder=&#34;0&#34; allow=&#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture&#34; allowfullscreen&gt;&lt;/iframe&gt;

&lt;h1 id=&#34;スライド&#34;&gt;スライド&lt;/h1&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;aa53e4353d9b4efc9064eefba40e13b7&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;スピーカーノート&#34;&gt;スピーカーノート&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.monochromegane.com/blog/2019/07/25/gophercon_2019_kaburaya/&#34;&gt;GopherCon 2019: Optimization for Number of goroutines Using Feedback Control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;発表内容&#34;&gt;発表内容&lt;/h1&gt;

&lt;p&gt;今回の発表は以前東京で開催されたGo Conference 2018 Autumnで発表した&lt;a href=&#34;https://speakerdeck.com/monochromegane/optimization-of-goroutine-numbers-by-feedback-control&#34;&gt;フィードバック制御によるGoroutine起動数の最適化&lt;/a&gt;を英語化したものです。
また、今回向けに実際に&lt;a href=&#34;https://github.com/monochromegane/the_platinum_searcher&#34;&gt;The Platinum Searcher&lt;/a&gt;に組み込んで有効性を評価する実験結果を追加しています。&lt;/p&gt;

&lt;p&gt;発表資料については、45分という時間で母国語を使わずにできるだけわかりやすく伝えるため、結果的にほぼ刷新する形となりましたが、母国語の慣れに頼らずとも説明可能なわかりやすい資料になったのではないかと自分では思っています。
具体的には、まずイントロダクションとバックグラウンドの章を少し手厚くしました。
今回の手法は、フィードバック制御を用いてgoroutine数を継続的に最適に保つことを目的としています。
しかしながら、そもそもGo言語の並行処理においては、goroutineのコストの低さとランタイムがgoroutineを効果的に切り替えることから、その必要性はないのではないかと考えることができます。
そこで、リソース競合や枯渇などの影響も受けてしまう可能性があること、それらを考慮した汎用的な並行設計に対する難しさを、実際にプラチナサーチャーによるパフォーマンスチューニングの例を踏まえながら前提を合わせるようにしました。
また、手法の説明では、簡単なアプローチから出発して少しづつ課題を解決していくようにすることで、比較的複雑な箇所の説明の際に飛躍がないように気をつけました。&lt;/p&gt;

&lt;p&gt;発表について、普段は資料のみで臨んでもそれなりに話せると自負していますが、初の英語での登壇となるため今回は発表内容のスクリプトを用意して、伝えるべきことを全て伝えられるようにしました。
また、不慣れな言語でも自分自身が納得して説明できるように、できるだけ平易な文で説明することで、発表資料と同様に曖昧な箇所や飛躍がある点を潰すことができたと思います。&lt;/p&gt;

&lt;p&gt;本番の発表は、4スクリーンある300-400人規模の会場ではありましたが、とても熱心に頷いてくれる方がいたり日本から来たメンバが前に座っていたりして、幸いにも落ち着いて自分のペースで登壇することができたと思います。
発表では、あまり一本調子にならないように、文の中でも意味や文法上切れる箇所は間をおいたり、定型の言い回し（I found that など）なるべく流暢にしたり、強調したいところは少しゆっくり大きく言うなど、「今の」英語力でできる工夫をしていきました。
一方で、個別の単語の発音などはまだまだ課題意識があるので、今後、そちらも重点的に取り組んでいきたいと感じました。&lt;/p&gt;

&lt;p&gt;質疑の時間は登壇時間には含まれなかったのですが、終了して台を降りると同時に7人ぐらいに囲まれて質問責めに会い、発表に興味を持ってくれたことをとても嬉しく思いました。
質問としては、発表内容について理解があっているか確認するものと、実装上の質問などがあり、資料やKaburayaのコードを見ながら説明していきました。
それでも、今の英語力では、発表内容以外の部分については拙い説明になることも多々あり、これも今後改めて英語をやるモチベーションが高まりました。
また、発表後もカンファレンス期間中に何度も感想や質問をもらう機会があり、これがとても嬉しかったです。&lt;/p&gt;

&lt;h3 id=&#34;会場と発表の様子&#34;&gt;会場と発表の様子&lt;/h3&gt;

&lt;div class=&#34;parent_iframe&#34; style=&#34;position:relative;width:75%;height:0;padding-top:75%;&#34;&gt;
  &lt;iframe class=&#34;embed_iframe&#34; src=&#34;https://s.insta360.com/p/28b6fbdd988f775d97328c5179e8061a?e=true&amp;locale=en-us&#34; frameborder=&#34;0&#34; width=&#34;666&#34; height=&#34;413&#34; style=&#34;position:absolute;top:0;left:0;width:100%;height:100%;&#34;&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;.&lt;a href=&#34;https://twitter.com/monochromegane?ref_src=twsrc%5Etfw&#34;&gt;@monochromegane&lt;/a&gt; is giving talk about Go&amp;#39;s concurrency mechanism and his proposal to optimize the number of goroutine. &lt;a href=&#34;https://twitter.com/hashtag/gophercon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gophercon&lt;/a&gt; &lt;a href=&#34;https://t.co/LXnnx5vQ6D&#34;&gt;pic.twitter.com/LXnnx5vQ6D&lt;/a&gt;&lt;/p&gt;&amp;mdash; Yoshi Yamaguchi 🇯🇵 (@ymotongpoo) &lt;a href=&#34;https://twitter.com/ymotongpoo/status/1154500168181379072?ref_src=twsrc%5Etfw&#34;&gt;July 25, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&#34;発表に関する反応&#34;&gt;発表に関する反応&lt;/h3&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Thanks to Yusuke Miyake for speaking to us on the Optimization for Number of goroutines Using Feedback Control! The &lt;a href=&#34;https://twitter.com/hashtag/gophercon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gophercon&lt;/a&gt; tutorial sessions are killin&amp;#39; it! &lt;a href=&#34;https://t.co/4I5ihE1wKG&#34;&gt;pic.twitter.com/4I5ihE1wKG&lt;/a&gt;&lt;/p&gt;&amp;mdash; GopherCon (@GopherCon) &lt;a href=&#34;https://twitter.com/GopherCon/status/1154502084634406917?ref_src=twsrc%5Etfw&#34;&gt;July 25, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;This was a really good talk, &lt;a href=&#34;https://twitter.com/monochromegane?ref_src=twsrc%5Etfw&#34;&gt;@monochromegane&lt;/a&gt; is very smart! Also it was really interesting hearing about the fukuoka Golang community. I need to read slides again. &lt;a href=&#34;https://t.co/bdGZK7p6DX&#34;&gt;https://t.co/bdGZK7p6DX&lt;/a&gt; &lt;a href=&#34;https://t.co/82GKvlFseO&#34;&gt;pic.twitter.com/82GKvlFseO&lt;/a&gt;&lt;/p&gt;&amp;mdash; Jamal Yusuf (@JamalYusuf_) &lt;a href=&#34;https://twitter.com/JamalYusuf_/status/1154587450242502656?ref_src=twsrc%5Etfw&#34;&gt;July 26, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/monochromegane?ref_src=twsrc%5Etfw&#34;&gt;@monochromegane&lt;/a&gt; talking about dynamic concurrency scaling with a PID controller and dynamic semaphores. &lt;a href=&#34;https://twitter.com/hashtag/golang?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#golang&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/gophercon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gophercon&lt;/a&gt; &lt;a href=&#34;https://t.co/dufxZNhKEZ&#34;&gt;https://t.co/dufxZNhKEZ&lt;/a&gt; &lt;a href=&#34;https://t.co/5eyRazxg2g&#34;&gt;pic.twitter.com/5eyRazxg2g&lt;/a&gt;&lt;/p&gt;&amp;mdash; Andy Walker (@flowchartsman) &lt;a href=&#34;https://twitter.com/flowchartsman/status/1154503310327439360?ref_src=twsrc%5Etfw&#34;&gt;July 25, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;en&#34; dir=&#34;ltr&#34;&gt;Really interesting thoughts on controlling &lt;a href=&#34;https://twitter.com/hashtag/golang?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#golang&lt;/a&gt; concurrency dynamically while a program is running. Thanks to Yusuke Miyake for traveling from Japan to present this at &lt;a href=&#34;https://twitter.com/hashtag/gophercon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gophercon&lt;/a&gt;! &lt;a href=&#34;https://t.co/WWfsJo5nNi&#34;&gt;pic.twitter.com/WWfsJo5nNi&lt;/a&gt;&lt;/p&gt;&amp;mdash; Daniel Whitenack (@dwhitena) &lt;a href=&#34;https://twitter.com/dwhitena/status/1154500909713383424?ref_src=twsrc%5Etfw&#34;&gt;July 25, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;カンファレンス&#34;&gt;カンファレンス&lt;/h1&gt;

&lt;p&gt;会場はカリフォルニア サンディエゴのホテル &lt;a href=&#34;https://www.gophercon.com/page/1388212/hotel&#34;&gt;Marriott Marquis San Diego Marina&lt;/a&gt;でした。
サンディエゴが比較的温暖な気候であること、ホテルもいわゆるリゾートホテルのような感じであったことも手伝って、期間中はとても快適に過ごせました。&lt;/p&gt;

&lt;p&gt;GopherConのタイムテーブルは朝が早いものの（最初のセッションがAM9:00から）、2-3セッションごとに30-40分の空き時間が設けられており、この時間に登壇者とディスカッションしたり、ポップアップミーティングスペースやスポンサーブースでコミュニティや企業への関係を作ったりすることができました。
日本でも学術系のシンボジウムだとこういったタイムテーブルは見かけるものの、GopherConではより積極的に関係を作っていこう、そしてそのために運営がその接点を作る機会（場所、時間）やホスピタリティを提供していこうという気概が感じられました。
また、Welcome Partyが本物の空母の上で開催されたのはめちゃくちゃ驚きました。こういう「楽しんでるぞ」というのが一貫して感じられるのも良かったです。
実際に #gophercon ハッシュタグを追っていると、たくさんの知見や関係を得たという感想と合わせて一種のバケーションを楽しんだような満足感を持っている方が多かったようです。
ちょうど、GoCon福岡を2週間前に開催したところであったため、「カンファレンス」をどういう設計で進めるのかという観点はとても勉強になりました。&lt;/p&gt;

&lt;p&gt;トークについては、どれも最新の情報だけでなく、スピーカーの方の実際の経験に基づく興味深く、かつ面白いセッションばかりでとてもためになりました。
それでも、自分の発表前後の緊張や疲れ、時差ボケなどで万全の状態で全てを聞くことはできなかったのが悔やまれますが、幸い個別のトークについては今後動画も公開されるようです。
&lt;a href=&#34;https://www.gophercon.com/agenda&#34;&gt;Agenda&lt;/a&gt;を見て興味あるセッションを是非ご覧ください。&lt;/p&gt;

&lt;h1 id=&#34;スピーカーディナー&#34;&gt;スピーカーディナー&lt;/h1&gt;

&lt;p&gt;発表は7/25でしたが、実は7/26の夜にスピーカーディナーなるものが控えていました。
登壇者ばかりが集う3時間の立食パーティーを英語で乗り切るという、ある意味では登壇よりもプレッシャーのかかるイベントでした。
それでも、とてもよい機会であるし無駄にはしたくないと、できるだけ話に加わり自分の意見や要望を伝えることができたと思います。
特に日本や福岡のコミュニティ活動やカンファレンスに何人か興味を持ってもらうことができたのは非常に有意義でした。
また、ワークショップを担当したエンジニアの方とは日本に戻ってからも連絡を取り合っており、今後何か面白いことが一緒にできるといいなあと考えています。&lt;/p&gt;

&lt;p&gt;とにかくこの3時間は僕の英語に対する心理的な苦手意識を取り除いてくれる絶好の機会となりました。
同時にやはり英語力の足りなさを痛感したことで、引き続き英語もやっていきたいと強く思えました。&lt;/p&gt;

&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;

&lt;p&gt;2014年の東京のGoConference 2014 springで発表したのが僕にとって初めての全国区のカンファレンス登壇でした。
そこから、自分のキャリアや興味範囲が広がっていく中でも、Go言語はずっと相棒として付き合ってくれる言語でしたし、Go言語を中心に色々な付き合いができていると感じています。
また、ここ数年の研究職としての試行錯誤がなければ今回の発表内容はありませんでした。
その意味で、今回のGopherCon 2019は現時点の僕の集大成で臨んだカンファレンスとなりました。
幸いにも、発表に対して興味を持ってもらえたこと、一定の反響があったことを、非常に嬉しく思っています。
同時に、このような大きな海外のカンファレンスで発表できたことは（2014にGoConで発表した時と同じように）素直に自信につながりました。
（当日聞いたのですが、スピーカーのうち、ワークショップを行われた約10名の応募枠は別だったとのことで今回は改めて狭き門を抜けることができたんだなあと感じています）&lt;/p&gt;

&lt;p&gt;この登壇に向けてアドバイスや協力をいただいた皆様、本当に感謝いたします。
このカンファレンスで得た様々な知見や関係、そして至らなかった点は次へ活かし、この契機となったGoコミュニティの活発化に繋がるよう引き続き”楽しみながら“やっていきたいと思います。&lt;/p&gt;

&lt;h3 id=&#34;俺たちが日本代表だ&#34;&gt;俺たちが日本代表だ！&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gophercon_japan.jpg&#34; alt=&#34;gophercon_japan&#34; /&gt;&lt;/p&gt;

&lt;p&gt;LTセッションで登壇した&lt;a href=&#34;https://twitter.com/hajimehoshi&#34;&gt;@hajimehoshi&lt;/a&gt;さんと&lt;a href=&#34;https://twitter.com/hgsgtk&#34;&gt;@hgsgtk&lt;/a&gt;さんと共に。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;そして最後に、Russ Coxと隣に扱われる機会ってそうそうないので記念に&lt;a href=&#34;https://www.gophercon.com/page/1388210/speakers&#34;&gt;スピーカー一覧&lt;/a&gt;のスクショを置いておきます、えへへ。（ただのアルファベット順だけど）&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gophercon_russ.jpg&#34; alt=&#34;gophercon_russ&#34; /&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>福岡でGoConを開催した</title>
      <link>https://blog.monochromegane.com/blog/2019/08/02/gocon_fukuoka/</link>
      <pubDate>Fri, 02 Aug 2019 15:33:36 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/08/02/gocon_fukuoka/</guid>
      <description>

&lt;p&gt;7/13に&lt;a href=&#34;https://fukuoka.gocon.jp/&#34;&gt;Go Conference&amp;rsquo;19 Summer in Fukuoka&lt;/a&gt;を開催した。
諸々落ち着いたので、初めて200名規模の大きなカンファレンスを開催するまでに駆け抜けた日々を振り返っておく。&lt;/p&gt;

&lt;h1 id=&#34;準備&#34;&gt;準備&lt;/h1&gt;

&lt;p&gt;Fukuoka.goの主催の一人としてGoConの福岡開催は是非ともやりたい気持ちがあり、Go Conference 2018 Autumnで登壇した際の懇親会で盛り上がったのが去年の11/25。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ホテル到着。移動で朝早かったので懇親会途中までとさせていただきました。お誘いありがとうございます。色々な話が聞けて楽しかったです！ カンファレンスも濃い話から体系的な整理がなされたものまであり来れて良かったです。自分の登壇内容も反応いただけて嬉しい限り。次は福岡版どうですか &lt;a href=&#34;https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gocon&lt;/a&gt;&lt;/p&gt;&amp;mdash; モノクロメガネ研究員 (@monochromegane) &lt;a href=&#34;https://twitter.com/monochromegane/status/1066697776912691200?ref_src=twsrc%5Etfw&#34;&gt;2018年11月25日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;11/30にFukuoka.go運営でやっていきのIssue起票。&lt;/li&gt;
&lt;li&gt;12/04に会場と時期のおおまかなあたりがついたので正式にGoCon地方開催を東京GoCon運営に打診。&lt;/li&gt;
&lt;li&gt;12/14に企画書を元に関係者に一通り話しが通った状態へ。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と良い感じのスピード感で進み出し、後は運営スタッフ一同で&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1月はマスコットのデザインやらLPの準備やら&lt;/li&gt;
&lt;li&gt;2月はGo1.12のリリパでイベント開催を初めて告知。GoCon運営スタッフも増えた。&lt;/li&gt;
&lt;li&gt;3月はCfPをオープン。スポンサー内容や金額感について具体的な検討と募集を始めた&lt;/li&gt;
&lt;li&gt;4月はCfPへのアーリーフィードバック、CfP草の根宣伝活動、スポンサーとの個別やりとり&lt;/li&gt;
&lt;li&gt;5月はCfPの選考と結果通知、タイムテーブルと参加枠を決めてconnpassを公開。&lt;/li&gt;
&lt;li&gt;6月は集客草の根宣伝活動、Tシャツやバックパネル、会場の軽食や飲み物、スピーカーディナーなどについて検討・確認・発注&lt;/li&gt;
&lt;li&gt;7月は当日までの作業の整理をして確定していないものを一つづつ対応（受付方法、司会進行、会場レイアウトや設営日、名札作成、ノベルティ配布準備、アンケート、市長、段ボール、張り紙 etc）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;と、ひたすら準備を進めた。
大規模カンファレンス開催のノウハウがない中でも、準備は共同主催の&lt;a href=&#34;https://twitter.com/linyows&#34;&gt;@linyows&lt;/a&gt;が皆を引っ張った。
作業分担は、@linyowsが打ち出したデザインやおもてなしの世界観に皆がイイねをしながら、できる人が具体化を進めていく形に落ち着いた。
@linyows自身がガンガンとタスクをこなしていく（会社では傭兵と呼ばれている&amp;hellip;）ので、僕自身は具体化を担当する他、方針の見直し案や進捗整理からの抜け漏れ対応といった補佐役に徹した。
&lt;a href=&#34;https://twitter.com/seike460&#34;&gt;@seike460&lt;/a&gt;をはじめとする運営スタッフとSlackでワイワイしながらだんだんと形になっていく過程も含めて（大変だったけど）楽しめたと思う。
開催時期については会場都合で少し延ばして7月としたが、今思えばこれぐらいの準備期間がないと納得いく形にするのは無理だったかもしれない。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;個人的に大変だったのは、連絡まわりで、いくつかの連絡経路を使ってたくさんの関係者と個別または全体で効率よく相談、告知するのは骨が折れた。
他のカンファレンス運営でどういう風にやっているのかを聞いてみたい。
反対にCfPの選考は多様なプロポーザルを見る機会として有益であったと思う。
また、より良いプロポーザルにするためのアドバイスをアーリーフィードバックという形で進めることができたのも非常に良かった。
特に、このフィードバックを通してプロポーザルの説得力が格段に上がっていく例などを見るのは嬉しかった。&lt;/p&gt;

&lt;p&gt;準備は前日と当日の朝が一番大変であった。
会場のリニューアル直後であったことも手伝い、搬入されるスポンサー物品を含む会場設営などはその場で詳細を決定して進めなければならなかったため、開場までの時間がない中で慌てて進めた。
特に当日朝は雨がすごかったので準備頑張ってるぞ感がすごかった気がする。&lt;/p&gt;

&lt;h1 id=&#34;当日&#34;&gt;当日&lt;/h1&gt;

&lt;p&gt;当日は幸いなことに@linyowsと僕は専任のタスクを持たずに各種ジャッジや遊撃手的な動きをできたことで全体に柔軟に対応できたと思う。
受付がひと段落して、高島市長のスペシャルセッション前後の応対が終わって、ビールや生ハムの提供が軌道にのるまでは、イベントがスムーズに進むように、心地よく過ごしてもらえるように裏側では様々な物品や情報が行き交っており、とにかく忙しかった（けど何をやったかは覚えていない）みたいな感じだった。
これが16:00ぐらいで、ビールが入ったこともあって一瞬寝落ちしたのを写真に撮られてしまった。&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_00.jpg&#34; alt=&#34;gocon_00&#34; /&gt;&lt;/p&gt;

&lt;p&gt;この後、少しだけセッションを聞けたけども、楽しみにしていたセッションをほぼ聞けなかったのでここは次への課題だねと振り返りで話した。
セッションは最後まで盛況で、懇親会まで盛り上がっていたので嬉しい気持ちで眺めていた。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;経費精算用エビデンスはこちら &lt;a href=&#34;https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gocon&lt;/a&gt; &lt;a href=&#34;https://t.co/zCsDLKBXJW&#34;&gt;pic.twitter.com/zCsDLKBXJW&lt;/a&gt;&lt;/p&gt;&amp;mdash; L I N Y O W S 🤡 (@linyows) &lt;a href=&#34;https://twitter.com/linyows/status/1150059130633068544?ref_src=twsrc%5Etfw&#34;&gt;July 13, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;僕たちのソフトウェアの仕事は作った後に動く期間が長いので、こういった半年以上の準備とわずか1日のイベントという形式の経験はなかなか貴重だったし、大変ながらも充実した時間を過ごせて楽しかった。&lt;/p&gt;

&lt;h1 id=&#34;スピーカーディナー&#34;&gt;スピーカーディナー&lt;/h1&gt;

&lt;p&gt;カンファレンス後のスピーカーディナーでは豪華なメンバと素敵な料理に囲まれてこれまた楽しいひと時であったものの、各種支払いや幹事的な動きをしていたらあっという間に終わってしまったので、ちょっと残念だった。
ただ、テーブルの右も左もみんなが新しいつながりを作って飯食って酒飲んでGoの話して笑っているのを見て、「アーーーこれはやって良かったんではーーーーーー！！」と一人泣きそうになっていたのは秘密である。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/hashtag/spekerdinner?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#spekerdinner&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gocon&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/nulab?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#nulab&lt;/a&gt; マジすごい！圧倒的感謝！！！！ &lt;a href=&#34;https://t.co/oZi3hfXHON&#34;&gt;pic.twitter.com/oZi3hfXHON&lt;/a&gt;&lt;/p&gt;&amp;mdash; L I N Y O W S 🤡 (@linyows) &lt;a href=&#34;https://twitter.com/linyows/status/1150008128953413632?ref_src=twsrc%5Etfw&#34;&gt;July 13, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h1 id=&#34;カンファレンスを終えて&#34;&gt;カンファレンスを終えて&lt;/h1&gt;

&lt;p&gt;まず、@linyowsにスタッフ一同からお礼を伝えたいです。ありがとう！
今回のイベントは@linyowsなしでは考えられない。
@linyowsの行動力、大人力に対して尊敬の念が更に高まりました。Fukuoka.goを共同で主催してくれることが非常に心強いです。これからもよろしくお願いします。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;&lt;a href=&#34;https://twitter.com/monochromegane?ref_src=twsrc%5Etfw&#34;&gt;@monochromegane&lt;/a&gt; さん、&lt;a href=&#34;https://twitter.com/linyows?ref_src=twsrc%5Etfw&#34;&gt;@linyows&lt;/a&gt; さん、スタッフの皆様、スポンサーの皆様、発表者の皆様、参加者の皆様、お疲れ様でした＆ありがとうGoざいました！q@w@p &lt;a href=&#34;https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gocon&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/fukuokago?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#fukuokago&lt;/a&gt; &lt;a href=&#34;https://t.co/hzSWpgZ4ij&#34;&gt;pic.twitter.com/hzSWpgZ4ij&lt;/a&gt;&lt;/p&gt;&amp;mdash; Ryuji Iwata (@qt_luigi) &lt;a href=&#34;https://twitter.com/qt_luigi/status/1150069073427886080?ref_src=twsrc%5Etfw&#34;&gt;July 13, 2019&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;そして、改めてスタッフの皆様、スポンサーの皆様、発表者の皆様、参加者の皆様に感謝を伝えたいです。ありがとうございます！&lt;/p&gt;

&lt;h1 id=&#34;カンファレンスへの想い&#34;&gt;カンファレンスへの想い&lt;/h1&gt;

&lt;p&gt;どうして集う形の勉強会やカンファレンスにするかというのは、何度か聞かれていて、&lt;a href=&#34;https://pr.forkwell.com/2018-10-01-community_lovers/&#34;&gt;この辺り&lt;/a&gt;でも答えていたのだけど、まず単純に集まって楽しく話す仲間がいることの嬉しさがあって、その背景として「場やコミュニティは実在しないので。定期的にやることが大事」という考えがあった。
コミュニティというネットワークを継続させていくためには、接合点である参加者の間の接続を活性化する必要がある。
そのためにはネットワークが活性化するように情報を行き交いさせるんだけれども、均等な一方向の情報発信は刺激に乏しいこともある。
人間も単純な部分は残っているので、実際に会ったとか、その場の熱量とかに影響されて発信側も受信側も一時的に接続が活性化する。
こういう励起された状態は、例えばカンファレンスを地元でやろうとか、触発されてツールを作って見たとか、ネットワークへの新しい情報の元になってコミュニティに還元される。
勉強会やカンファレンスは、そういうやり方での重みの活性化を担っていると思う。&lt;/p&gt;

&lt;p&gt;今回のカンファレンスがGo言語コミュニティや福岡にとって上のような影響を与えることができたのであればとても嬉しい。
何より、カンファレンス運営を通して、スタッフみんながエキサイティングな経験を楽しんでいたことがとても嬉しい。
なぜなら、僕たちが楽しみ続けることがまず大事だから〜〜。お疲れ様でした！！！&lt;/p&gt;

&lt;p&gt;そしてオフィシャルのイベントレポートが非常によくまとまっています。こちらも是非ご覧ください！&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://fukuoka.gocon.jp/report/&#34;&gt;The Official event report of Go Conference &amp;lsquo;19 Summer in Fukuoka&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;フォトギャラリー&#34;&gt;フォトギャラリー&lt;/h1&gt;

&lt;p&gt;最後に、誰得 モノクロメガネ フォトギャラリーを置いておきます。いやぁ、楽しんでるなあ〜&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_01.jpg&#34; alt=&#34;gocon_01&#34; /&gt;
&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_02.jpg&#34; alt=&#34;gocon_02&#34; /&gt;
&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_03.jpg&#34; alt=&#34;gocon_03&#34; /&gt;
&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_04.jpg&#34; alt=&#34;gocon_04&#34; /&gt;
&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_05.jpg&#34; alt=&#34;gocon_05&#34; /&gt;
&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_06.jpg&#34; alt=&#34;gocon_06&#34; /&gt;
&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_07.jpg&#34; alt=&#34;gocon_07&#34; /&gt;
&lt;img src=&#34;https://blog.monochromegane.com/images/2019/08/gocon_08.jpg&#34; alt=&#34;gocon_08&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Photo by &lt;a href=&#34;https://twitter.com/atani&#34;&gt;@atani&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;𝝣Go&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>GopherCon 2019: Optimization for Number of goroutines Using Feedback Control</title>
      <link>https://blog.monochromegane.com/blog/2019/07/25/gophercon_2019_kaburaya/</link>
      <pubDate>Thu, 25 Jul 2019 14:00:00 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/07/25/gophercon_2019_kaburaya/</guid>
      <description>

&lt;p&gt;&lt;strong&gt;The slides and speaker-notes about optimization for the number of goroutines I talked at &lt;a href=&#34;https://www.gophercon.com/agenda/speakers/442434&#34;&gt;GopherCon 2019&lt;/a&gt;.&lt;/strong&gt;&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;aa53e4353d9b4efc9064eefba40e13b7&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;blockquote&gt;
&lt;p&gt;The design for the number of concurrency is important to achieve both speed and stability. To give a good performance without depending on platform and load conditions, it’s desirable for the number to be dynamic and rapidly controlled. In this talk, I will propose an architecture to solve this by utilizing feedback control.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&#34;1-title&#34;&gt;1. Title&lt;/h1&gt;

&lt;p&gt;Good afternoon, everyone.
Thank you very much for coming today.&lt;/p&gt;

&lt;h1 id=&#34;2-self-introduction&#34;&gt;2. Self-introduction&lt;/h1&gt;

&lt;p&gt;My name is Yusuke MIYAKE.
My social account is @monochromegane.
I am a researcher of internet and operation technology, as well as a web developer.&lt;/p&gt;

&lt;h1 id=&#34;3-go-and-i&#34;&gt;3. Go and I&lt;/h1&gt;

&lt;p&gt;Let me introduce the relation between Go and me.
I am a Japanese gopher who loves writing OSS using Go.
My popular repositories are here (the_platinum_searcher is a fast grep tool).
And I am an organizer of the local Go community in Fukuoka, Japan.
So, we held Go Conference’19 summer in Fukuoka on &lt;sup&gt;7&lt;/sup&gt;&amp;frasl;&lt;sub&gt;13&lt;/sub&gt; which was 2 weeks ago.
200 gophers in Japan gathered and enjoyed 30 sessions.
It was a lot of fun!
This is our conference gopher.
He has ramen which is a Japanese famous food on his head.
Isn&amp;rsquo;t he good?&lt;/p&gt;

&lt;h1 id=&#34;4-agenda&#34;&gt;4. Agenda&lt;/h1&gt;

&lt;p&gt;Today I am here to talk to you about optimization for the number of goroutines.
My talk has 5 parts.
I’ll start by talking about why there is a need for optimization for the number of goroutines through the introduction and background section.
After that, I&amp;rsquo;ll introduce my proposal that optimizes the number using feedback control.
And I will evaluate the efficacy of the method.
Finally, I will conclude about possible and some issues of the method.&lt;/p&gt;

&lt;h1 id=&#34;5-introduction&#34;&gt;5. Introduction&lt;/h1&gt;

&lt;p&gt;To begin with let’s speak to my experience of performance tuning of my OSS tool.&lt;/p&gt;

&lt;h1 id=&#34;6-how-many-are-the-optimal-number-of-goroutines&#34;&gt;6. How many are the optimal number of goroutines?&lt;/h1&gt;

&lt;p&gt;I am developing a fast grep tool named &amp;ldquo;the platinum searcher&amp;rdquo;.
One day I conducted a measurement of the optimal number of goroutines to achieve good performance.&lt;/p&gt;

&lt;h1 id=&#34;7-performance-tuning-in-case-of-pt&#34;&gt;7. Performance tuning in case of pt&lt;/h1&gt;

&lt;p&gt;&amp;ldquo;the platinum searcher&amp;rdquo; uses many goroutines to search string matching to pattern from files.
So, I measured performance while bounding concurrency using a semaphore.
Here is a result.
The X-axis represents the number of goroutines.
It is a log scale.
The Y-axis represents the speedup of processing time against sequential processing.
The result shows 8 or 32 goroutines make performance good.
This is 2 or 8 times more than the number of CPUs.&lt;/p&gt;

&lt;h1 id=&#34;8-performance-tuning-in-case-of-pt&#34;&gt;8. Performance tuning in case of pt&lt;/h1&gt;

&lt;p&gt;However, measurement in different environments showed a different result.
The result shows 16 goroutines make performance good.
This is 2 times more than the number of CPUs.
But I found that more goroutines cause performance degradation.
In this environment, the real-time virus scan process was running at the same time.
The process turns system-call of opening file slow and consumes CPU resources.
As a result, performance is degraded when searching for many files at the same time.&lt;/p&gt;

&lt;h1 id=&#34;9-performance-tuning-in-case-of-pt&#34;&gt;9. Performance tuning in case of pt&lt;/h1&gt;

&lt;p&gt;Besides, there were other results.
When the real-time virus scan process stops, 4 goroutines made performance good.
This is half times less than the number of CPUs.
I don&amp;rsquo;t know how many the optimal number of goroutines are?&lt;/p&gt;

&lt;h1 id=&#34;10-performance-tuning-in-case-of-pt&#34;&gt;10. Performance tuning in case of pt&lt;/h1&gt;

&lt;p&gt;Currently, &amp;ldquo;the platinum searcher&amp;rdquo; is bounding concurrency using the number of CPUs.
Namely, I am choosing a safer way.
But it isn&amp;rsquo;t the fastest.&lt;/p&gt;

&lt;h1 id=&#34;11-how-many-are-the-optimal-number-of-goroutines-in-each-case&#34;&gt;11. How many are the optimal number of goroutines in each case?&lt;/h1&gt;

&lt;p&gt;So, that concludes this part of my talk on my experience of performance tuning.
Achieving both speed and stability, we have to decide optimum number of goroutines through our experiences and continuous tuning.
And, in most case, the environment on which the program is tuned and the environment on which it will be executed are different.
Thus, I&amp;rsquo;d like to consider optimization for number of goroutines without depending on environments.&lt;/p&gt;

&lt;h1 id=&#34;12-background&#34;&gt;12. Background&lt;/h1&gt;

&lt;p&gt;In this section, I will organize the issues about design for concurrency.&lt;/p&gt;

&lt;h1 id=&#34;13&#34;&gt;13.&lt;/h1&gt;

&lt;p&gt;I’m going to organize these issues in the following order;
Let us start with the first, which is the complexity of concurrency.
Then we come to the next, which is the contribution of Go to solve the complexity.
We will find an approach to solve the remaining issues, finally.&lt;/p&gt;

&lt;h1 id=&#34;14-concurrency-and-complexity&#34;&gt;14. Concurrency and complexity&lt;/h1&gt;

&lt;p&gt;In this page, I will organize the relation of concurrency and complexity.&lt;/p&gt;

&lt;p&gt;We introduce concurrency to improve performance.
Concurrency brings our application good performance and complexity.
Because concurrent processing is often considered as compared to simple serial processing.
This figure shows the common issues of concurrency.
We have to consider efficient thread management from a parallelism of view.
And we have to avoid race conditions and synchronize memory access.
And we have to design to be scalable.
Like this, we are dealing with many issues to improve performance.&lt;/p&gt;

&lt;h1 id=&#34;15&#34;&gt;15.&lt;/h1&gt;

&lt;p&gt;Then, I will organize the contribution of Go to solve the complexity.&lt;/p&gt;

&lt;h1 id=&#34;16-concurrency-and-go&#34;&gt;16. Concurrency and Go&lt;/h1&gt;

&lt;p&gt;This is one of the reasons why we are interested in Go.
&amp;ldquo;Go&amp;rdquo; hides some complexities.
Because Go has rich features that support concurrency.
For example, we are freed from managing thread by runtime scheduler of Go.
And we also can avoid race conditions by using a channel.
In other words, Go decouples between your code and the complexity of parallelism.&lt;/p&gt;

&lt;h1 id=&#34;17-runtime-scheduler-of-go&#34;&gt;17. Runtime scheduler of Go&lt;/h1&gt;

&lt;p&gt;In this page, I&amp;rsquo;ll explain how Go&amp;rsquo;s runtime hide the complexity.
This figure shows Go’s scheduler workflow.
Go’s scheduler has three basic concepts.
G is goroutine.
M is an OS thread.
P is a processor.
P handles multiplexing some goroutines onto some OS threads.&lt;/p&gt;

&lt;p&gt;So, We can think of Goroutines as application-level threads. 
OS thread behaves like a worker for goroutine using a run queue.
What is important is P uses a smart scheduling strategy called a work-stealing algorithm.
Therefore P efficiently schedules available goroutines onto OS threads.
As Go&amp;rsquo;s runtime automatically dose these, we don&amp;rsquo;t need to consider the complexity of parallelism.&lt;/p&gt;

&lt;h1 id=&#34;18-new-g&#34;&gt;18. New “g”&lt;/h1&gt;

&lt;p&gt;Besides, lightweight goroutines make Go&amp;rsquo;s scheduler more practical.
Creating a goroutine is cheap.
Because a newly created goroutine is allocated only 2kB stack.
Switching a goroutine is also cheap.
Because goroutine has only minimal context.
These points show that many goroutines can run at the same time.
As this practical runtime gives the illusion of parallelism more than the actual number of CPUs, we don&amp;rsquo;t need to consider the complexity of parallelism.&lt;/p&gt;

&lt;h1 id=&#34;19&#34;&gt;19.&lt;/h1&gt;

&lt;p&gt;Finally, I will organize the remaining issues and find an approach to solve them.&lt;/p&gt;

&lt;h1 id=&#34;20-concurrency-and-application&#34;&gt;20. Concurrency and application&lt;/h1&gt;

&lt;p&gt;Due to Go hides the complexity of parallelism, we can focus on concurrency issues in our application.
One of them is the design of the number of concurrency.
The reason is that the number of concurrency affects the performance depending on the characteristics of the application.
Certainly, the cost of generating and switching goroutines is very cheap.
On the other hand, when tasks on goroutine use shared resources, the upper limit of shared resources become a bottleneck.
Therefore, in this case, it is necessary to find the optimal number of concurrency to improve performance.&lt;/p&gt;

&lt;h1 id=&#34;21-concurrency-and-application&#34;&gt;21. Concurrency and application&lt;/h1&gt;

&lt;p&gt;But the design for the number of concurrency is difficult.
Because the optimal number depends on app, environments and load condition.
And, in most cases, the environment in which the program is tuned and the environment in which it will be executed is different.
Thus, I&amp;rsquo;d like to consider optimization for the number of goroutines without depending on environments.
In order to achieve this, it&amp;rsquo;s desirable for the number of concurrency to be determined dynamically and be controlled rapidly by detection the bottleneck on running program.&lt;/p&gt;

&lt;h1 id=&#34;22-proposal&#34;&gt;22. Proposal&lt;/h1&gt;

&lt;p&gt;In this section, I&amp;rsquo;ll introduce my proposal that optimizes the number of concurrency.&lt;/p&gt;

&lt;h1 id=&#34;23-goal&#34;&gt;23. Goal&lt;/h1&gt;

&lt;p&gt;The proposed method&amp;rsquo;s goal is here.
The optimal number of concurrency to be determined dynamically and be controlled rapidly.&lt;/p&gt;

&lt;h1 id=&#34;24-basic-idea&#34;&gt;24. Basic idea&lt;/h1&gt;

&lt;p&gt;To begin with let’s speak to the basic idea of the method.
At first, It increases the number of goroutines to performance target.&lt;/p&gt;

&lt;h1 id=&#34;25-basic-idea&#34;&gt;25. Basic idea&lt;/h1&gt;

&lt;p&gt;After that, it stops increasing the number of goroutines if it meets the performance target.&lt;/p&gt;

&lt;h1 id=&#34;26-basic-idea&#34;&gt;26. Basic idea&lt;/h1&gt;

&lt;p&gt;After a while, it attempts to decrease the number of goroutines.
If it fails to meet the performance target, it backs to step 1.&lt;/p&gt;

&lt;h1 id=&#34;27-issues-to-solve-for-the-realization&#34;&gt;27. Issues to solve for the realization&lt;/h1&gt;

&lt;p&gt;We have two issues to solve for the realization of the idea.&lt;/p&gt;

&lt;p&gt;First, Selection of performance metrics
Next, finding how to control rapidly and continuously&lt;/p&gt;

&lt;p&gt;In the following subsections, I try to realize the proposal while solving these problems.&lt;/p&gt;

&lt;h1 id=&#34;28-performance-metrics&#34;&gt;28. Performance metrics&lt;/h1&gt;

&lt;p&gt;In this subsection, I will consider performance metrics that are without depending on application characteristics.&lt;/p&gt;

&lt;h1 id=&#34;29-performance-metrics&#34;&gt;29. Performance metrics&lt;/h1&gt;

&lt;p&gt;In the basic idea subsection, I was assuming that there is a performance target.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s desirable for the performance target not to depend on resource type whom task use.
Because different applications have different bottlenecks.
For example, I/O, Capacity of memory and processing load due to the external process.
If we find an ideal performance target, it will allow us to use the proposed method in as many applications as possible.&lt;/p&gt;

&lt;p&gt;I think that CPU usage or throughput suits for the purpose.
Go&amp;rsquo;s scheduler turns blocking tasks into as CPU bound as possible by switching tasks continuously.
Thus, I adopt the CPU usage of the Go application as the performance target.&lt;/p&gt;

&lt;h1 id=&#34;30-performance-metrics&#34;&gt;30. Performance metrics&lt;/h1&gt;

&lt;p&gt;But the performance upper limit is different for each application.
In other words, we don&amp;rsquo;t know the actual value of the target.
Thus, it is calculated on running.&lt;/p&gt;

&lt;p&gt;At first, it sets the target value high.
It increases the number of goroutines to performance targets.&lt;/p&gt;

&lt;h1 id=&#34;31-performance-metrics&#34;&gt;31. Performance metrics&lt;/h1&gt;

&lt;p&gt;If it doesn&amp;rsquo;t meet the performance target, it regards the point as metrics upper limit.
After that, it gradually adjusts it to the new upper limit value.&lt;/p&gt;

&lt;p&gt;So, that concludes this part of my talk on performance metrics.
The summary is the following:
The proposed method uses CPU usage upper limit as the performance target.
And the value is calculated on running.&lt;/p&gt;

&lt;h1 id=&#34;32-determining&#34;&gt;32. Determining&lt;/h1&gt;

&lt;p&gt;In this subsection, I will consider how to determine the number of concurrency rapidly, continuously and accurately.&lt;/p&gt;

&lt;h1 id=&#34;33-determine-the-number-of-goroutines&#34;&gt;33. Determine the number of goroutines&lt;/h1&gt;

&lt;p&gt;In the previous subsection, we defined performance metrics and dynamic value.
Next, we have to consider how to determine the number of goroutines to meet the target value.
In the basic idea subsection, we increased goroutine one by one
But it has to determine rapidly, continuously, accurately to adjust the number of goroutines to rapid changes in the actual environment.
I think that feedback control is a good way to meet these conditions.&lt;/p&gt;

&lt;h1 id=&#34;34-feedback-control&#34;&gt;34. Feedback control&lt;/h1&gt;

&lt;p&gt;In this page, I will explain the basis of feedback control.&lt;/p&gt;

&lt;p&gt;This figure shows the structure of a feedback loop.
There is a system with input and output.
The output is sent back and compared to the set-point to calculate a new input.
The error is a deviation of the output from the set-point.
The controller calculates how much to increase (or decrease) based on the error.&lt;/p&gt;

&lt;p&gt;Feedback control applies an automatic correction continuously.
Determining set-point and Identifying suitable input/output is important.
Instead, Feedback control does not need to know the detail of the system.
I think that the robustness of feedback control is effective for rapid changes in the actual environment.&lt;/p&gt;

&lt;h1 id=&#34;35-pid-controller-1-2&#34;&gt;35. PID Controller (&lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;)&lt;/h1&gt;

&lt;p&gt;In this page, I will explain a controller used frequently.&lt;/p&gt;

&lt;p&gt;As I mentioned before, the job of controllers is to calculate the value of new input based on the error.
PID Controller applies a correction rapidly and accurately.
The controller has three sub-controllers inside.
The output is a combination of its proportional, integral and derivative subcontrol.&lt;/p&gt;

&lt;p&gt;Now I’d like to look at the strategy of each sub-controller.&lt;/p&gt;

&lt;h1 id=&#34;36-pid-controller-2-2&#34;&gt;36. PID Controller (&lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;2&lt;/sub&gt;)&lt;/h1&gt;

&lt;p&gt;The proportional control output is proportional to the error.
Namely, a large error will lead to a large adjustment.
KP is the controller gain.&lt;/p&gt;

&lt;p&gt;The integral control output is proportional to the integral of the error over time.
The output becomes a cumulative sum of the error if it is a computer implementation.
KI is the controller gain.
The I controller deal with the small error that the P controller loses its effectiveness.&lt;/p&gt;

&lt;p&gt;The derivative control output is proportional to the derivative of the error.
The output becomes the amount that has changed since the previous time step if it is a computer implementation.
KD is the controller gain.
The D controller encourages converge using the output.&lt;/p&gt;

&lt;p&gt;So, that concludes this part of my talk on basic of PID controller.
The controller is intended to take the system closer to a set-point.
However, the set-point has to be determined beforehand.
In the proposed method, the value of the set-point is calculated on running.&lt;/p&gt;

&lt;p&gt;Now I’d like to consider the structure of the controller to meet this condition.&lt;/p&gt;

&lt;h1 id=&#34;37-dynamic-target-controller&#34;&gt;37. Dynamic Target Controller&lt;/h1&gt;

&lt;p&gt;This figure shows the structure of the controller of the proposed method.
This controller has two nested control loops.
The inner loop is the PID controller which we have learned just before.
The inner loop&amp;rsquo;s input is current CPU usage and its output is the number of goroutines.
The inner loop attempts to increase goroutine until CPU usage upper limit which is a set-point.
However, the value of the set-point needs to be calculated on running.
The job of the outer loop is to calculate this value.
The outer loop&amp;rsquo;s input is current CPU usage as same as the inner loop.
Its output is a new set-point of the inner loop.
Namely, the inner loop&amp;rsquo;s set-point is changed by the outer loop&amp;rsquo;s output.&lt;/p&gt;

&lt;p&gt;The outer loop behavior has been mentioned at the performance metrics subsection.
When CPU usage reached the upper limit by many goroutines, the outer loop begins to use its value as a new set-point.
In the current implementation, the outer loop sets a new set-point when CPU usage changes significantly.
Because Go&amp;rsquo;s scheduler attempts to consume CPU resources incessantly by switching goroutines.
Namely, CPU usage stays on the upper limit in most cases.
Therefore, I figured it would be easier to detect change points in short-term observations than to detect stability in long-term observations.&lt;/p&gt;

&lt;p&gt;(If time remains)
Indeed the design for the controller is pretty hard.
The current controller version is 11.
I published past designs and their evaluation.
if you have an interest in it, let&amp;rsquo;s conversation about a better way during this conference.&lt;/p&gt;

&lt;p&gt;So, that concludes this talk of my talk on dynamic target controller.
Now, we should be able to determine the optimal number of goroutines rapidly, continuously, accurately.
Finally, I’d like to consider how to bound concurrency with the determined number.&lt;/p&gt;

&lt;h1 id=&#34;38-bounding&#34;&gt;38. Bounding&lt;/h1&gt;

&lt;p&gt;In this subsection, I will explain about bounding concurrency dynamically.&lt;/p&gt;

&lt;h1 id=&#34;39-to-bound-concurrency&#34;&gt;39. To bound concurrency&lt;/h1&gt;

&lt;p&gt;This is a Go code that appeared after a long time.
We often write such code to bound concurrency in Go.
We usually use the buffered channel as a semaphore.
In this example, the buffer for the channel is 3.
Therefore, only three goroutines run at the same time.&lt;/p&gt;

&lt;p&gt;On the other hand, in the proposed method the optimal number of goroutines will be different in every iteration of the feedback loop.
However, we can&amp;rsquo;t change the buffer size of the channel later.
Therefore, we need a dynamic semaphore for the method.&lt;/p&gt;

&lt;h1 id=&#34;40-elastic-semaphore&#34;&gt;40. Elastic semaphore&lt;/h1&gt;

&lt;p&gt;This figure shows the elastic semaphore.
This elastic semaphore provides &amp;ldquo;wait&amp;rdquo; and &amp;ldquo;signal&amp;rdquo; operations as same as a semaphore.
&amp;ldquo;wait&amp;rdquo; operation decrements the value of the semaphore variable.
If the new value of the semaphore variable is negative, it is blocked.
&amp;ldquo;signal&amp;rdquo; operation increments the value of the semaphore variable.
&amp;ldquo;incrementLimit&amp;rdquo; changes upper of the semaphore variable.
The value of the limit is determined by the feedback controller in the proposed method.
This elastic semaphore ensures the atomicity of these operations.&lt;/p&gt;

&lt;p&gt;(If time remains)&lt;/p&gt;

&lt;p&gt;This semaphore is not strict.
Because it allows that goroutines more than the upper limit run temporarily.
For example, 10 goroutines are running when the upper limit is 10.
After that, if the upper limit turns 5, 10 goroutines are still running until they finish their every task.
Of course, generating new goroutine is blocked.
Therefore, a long term goroutine like a worker process is not suitable for the elastic semaphore.
Fortunately, generating goroutine is cheap in Go.
So, we can generate it each time.&lt;/p&gt;

&lt;h1 id=&#34;41-kaburaya&#34;&gt;41. Kaburaya&lt;/h1&gt;

&lt;p&gt;In this subsection, I will explain kaburaya as the implementation of the proposed method.&lt;/p&gt;

&lt;h1 id=&#34;42-architecture-of-kaburaya&#34;&gt;42. Architecture of kaburaya&lt;/h1&gt;

&lt;p&gt;As I mentioned before, the goal of the proposed method is here.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to determine the number of concurrency dynamically.
I&amp;rsquo;d like to control the number of concurrency rapidly.&lt;/p&gt;

&lt;p&gt;For the purpose,&lt;/p&gt;

&lt;p&gt;Firstly, we decided to use CPU usage upper limit as performance metrics.
The value is calculated on running.
Secondly, we decided to determine the optimal number of goroutine using the metrics.
The value is determined rapidly, continuously, accurately using feedback control.
Finally, we decided to bound concurrency using the number.
The concurrency is bounded using elastic semaphore dynamically.&lt;/p&gt;

&lt;p&gt;I am developing this implementation as OSS named kaburaya.
The URL is here.&lt;/p&gt;

&lt;p&gt;As a side note, Kaburaya is the name of a Japanese arrow with a whistle.&lt;/p&gt;

&lt;h1 id=&#34;43-monochromegane-kaburaya&#34;&gt;43. monochromegane/kaburaya&lt;/h1&gt;

&lt;p&gt;This code is the usage of kaburaya.
It is very similar to the code of bounding concurrency with buffered channels.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;NewSem&amp;rdquo; specifies the period for feedback control and creates a new semaphore.
We can use &amp;ldquo;Wait&amp;rdquo; and &amp;ldquo;Signal&amp;rdquo; like a send or receive of a channel.
Kaburaya changes the limit of semaphore variables automatically and continuously.
So, we don&amp;rsquo;t need the &amp;ldquo;incrementLimit&amp;rdquo; operation.
Lastly, if the tasks finished, we have to stop kaburaya to stop the feedback loop.&lt;/p&gt;

&lt;p&gt;So, that concludes this part of my talk on the proposed method and its implementation.
I’d like to speak about the evaluation of kaburaya.&lt;/p&gt;

&lt;h1 id=&#34;44-evaluation&#34;&gt;44. Evaluation&lt;/h1&gt;

&lt;p&gt;In this section, I will explain the evaluation of kaburaya.&lt;/p&gt;

&lt;h1 id=&#34;45-evaluation&#34;&gt;45. Evaluation&lt;/h1&gt;

&lt;p&gt;There are 6 patterns of environments.
I evaluated the efficacy of kaburaya in each environment.
There are 3 contents.
They are speedup of processing, CPU usage based on time series, and limit of semaphore on time series.
I found good and not so good points in each environment accordingly.&lt;/p&gt;

&lt;h1 id=&#34;46-pt-mac-scan&#34;&gt;46. pt_mac-scan&lt;/h1&gt;

&lt;p&gt;At first, I will explain this environment and task.&lt;/p&gt;

&lt;p&gt;In this environment, &amp;ldquo;the platinum searcher&amp;rdquo; runs on Mac with a real-time virus scan.
The number of CPU is 8 and the memory size is 16GB.
GOMAXPROCS is set 8.&lt;/p&gt;

&lt;p&gt;The graph represents performance against the number of goroutines.
The X-axis represents the number of goroutines.
It is a log scale.
The Y-axis represents the speedup of processing time against sequential processing.
The result shows 16 goroutines make performance itself good.
This task is more degradation of performance due to increased goroutines&lt;/p&gt;

&lt;p&gt;Next, I’d like to take a look at the experiment result of kaburaya.&lt;/p&gt;

&lt;h1 id=&#34;47-pt-mac-scan&#34;&gt;47. pt_mac-scan&lt;/h1&gt;

&lt;p&gt;This is a good pattern.
Because kaburaya achieved both speed and stability.&lt;/p&gt;

&lt;p&gt;These figures show the results of the evaluation in the environment.
The number of the left graph which is 11 represents the median value of goroutine number determined by kaburaya.
As a consequence, kaburaya let processing time 6 times faster than sequential processing.&lt;/p&gt;

&lt;p&gt;There are 3 plots based on time series in the right graph.
The blue dash line represents the set-point of CPU usage.
The blue line represents the actual value of CPU usage.
And the green line represents the number of semaphores determined by kaburaya.&lt;/p&gt;

&lt;p&gt;In this environment and task, Kaburaya found good set points and adjust numbers within the ideal range.
Kaburaya was able to avoid performance degradation by determining the minimum number of the semaphore to meet the performance metrics.
As a result, not the best, but it achieved a good speedup.
Namely, kaburaya achieved both speed and stability.&lt;/p&gt;

&lt;h1 id=&#34;48-task-pt-mac-no-scan&#34;&gt;48. Task: pt_mac-no-scan&lt;/h1&gt;

&lt;p&gt;This is also a good pattern.
In this environment, I stopped the real-time virus scan process and ran &amp;ldquo;the platinum searcher&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The result shows 4 goroutines make performance good.
This task is less degradation of performance due to increased goroutines.&lt;/p&gt;

&lt;h1 id=&#34;49-task-pt-mac-no-scan-good&#34;&gt;49. Task: pt_mac-no-scan (Good)&lt;/h1&gt;

&lt;p&gt;In this environment and task, Kaburaya found good set points and adjust numbers within the ideal range.&lt;/p&gt;

&lt;p&gt;Please pay attention to the blue dash line in the right graph.
This shows that the feedback controller continued to set a new set-point when CPU usage changed significantly.
As a result, kaburaya adjusted the number of semaphore within a good range.
Not the best, but it achieved a good speedup as few concurrency as possible.&lt;/p&gt;

&lt;h1 id=&#34;50-task-pt-mac-no-scan-bad&#34;&gt;50. Task: pt_mac-no-scan (Bad)&lt;/h1&gt;

&lt;p&gt;Unfortunately, there is a bad pattern.
This is the same as the previous environment.
But the number of semaphores continued to increase.
Because kaburaya failed to reset the set point.
Therefore actual CPU usage was always lower than set-point.&lt;/p&gt;

&lt;p&gt;The cause is the range of change rate is too large.
It is used as a condition of determining set-point.&lt;/p&gt;

&lt;p&gt;So, I have to adjust the value in order to improve the controller.&lt;/p&gt;

&lt;p&gt;#51. Task: pt_linux&lt;/p&gt;

&lt;p&gt;This is not so bad pattern.&lt;/p&gt;

&lt;p&gt;In this environment, &amp;ldquo;the platinum searcher&amp;rdquo; runs on Linux.
The number of CPU is 4 and the memory size is 4GB.
GOMAXPROCS is set 4.&lt;/p&gt;

&lt;p&gt;The result shows 8 or 32 goroutines make performance good.
This task is less degradation of performance due to increased goroutines.&lt;/p&gt;

&lt;h1 id=&#34;52-task-pt-linux-not-so-bad&#34;&gt;52. Task: pt_linux (Not so bad)&lt;/h1&gt;

&lt;p&gt;The number of the left graph which is 15 represents the median value of goroutine number determined by kaburaya.
As a consequence, kaburaya let processing time 3.5 times faster than sequential processing.&lt;/p&gt;

&lt;p&gt;In this environment and task, Kaburaya found good set points and adjust numbers within the ideal range.
However, at the end of the period, the number of semaphores increased due to the failure to reset the set point.&lt;/p&gt;

&lt;p&gt;The cause is the same as before.
So, I have to adjust the range of change rate.&lt;/p&gt;

&lt;h1 id=&#34;53-task-mem-4096000-10000&#34;&gt;53. Task: mem_4096000_10000&lt;/h1&gt;

&lt;p&gt;Here is another task.
The task uses the memory of a shared resource.
In this case, the size is 4MB.
Many concurrencies will cause starvation of resources.&lt;/p&gt;

&lt;p&gt;The number of CPU is 4 and the memory size is 4GB.
GOMAXPROCS is set 4.&lt;/p&gt;

&lt;p&gt;Better concurrent is 512.
This task leads to more degradation of performance (swap out) due to increased goroutines.&lt;/p&gt;

&lt;h1 id=&#34;54-task-mem-4096000-10000-good&#34;&gt;54. Task: mem_4096000_10000 (Good)&lt;/h1&gt;

&lt;p&gt;The number of the left graph which is 63 represents the median value of goroutine number determined by kaburaya.
As a consequence, kaburaya let processing time 3 times faster than sequential processing.
So, Kaburaya found good set points and adjust numbers within the ideal range.&lt;/p&gt;

&lt;p&gt;What is important is that it avoided the starvation of resources.
These results show the good set-point keep an ideal number of semaphore.&lt;/p&gt;

&lt;h1 id=&#34;55-task-mem-40960-1000000&#34;&gt;55. Task: mem_40960_1000000&lt;/h1&gt;

&lt;p&gt;This is also a good pattern.&lt;/p&gt;

&lt;p&gt;I changed memory size to 40kb from 4MB.
The environment is the same as before.
Better concurrent are from 4 to 64.&lt;/p&gt;

&lt;h1 id=&#34;56-task-mem-40960-1000000-good&#34;&gt;56. Task: mem_40960_1000000 (Good)&lt;/h1&gt;

&lt;p&gt;The number of the left graph which is 19 represents the median value of goroutine number determined by kaburaya.
As a consequence, kaburaya let processing time 2.5 times faster than sequential processing.
So, Kaburaya found good set points and adjust numbers within the ideal range.&lt;/p&gt;

&lt;h1 id=&#34;57-task-mem-409600-100000&#34;&gt;57. Task: mem_409600_100000&lt;/h1&gt;

&lt;p&gt;At last, I will show you an interesting pattern.&lt;/p&gt;

&lt;p&gt;I changed memory size to 400kB.
The environment is the same as before.&lt;/p&gt;

&lt;p&gt;Although when the number of the semaphore is 16 it seemed performance reached the limit, more goroutines made performance good.
Perhaps better concurrent will be over 1024.&lt;/p&gt;

&lt;h1 id=&#34;58-task-mem-409600-100000-not-so-good&#34;&gt;58. Task: mem_409600_100000 (Not so good)&lt;/h1&gt;

&lt;p&gt;The number of the left graph which is 29 represents the median value of goroutine number determined by kaburaya.
As a consequence, kaburaya let processing time 2 times faster than sequential processing.&lt;/p&gt;

&lt;p&gt;The results show kaburaya solved this task with a local solution.
Certainly, Kaburaya found set points and adjusted the numbers within a range.
But it didn&amp;rsquo;t reach the upper of performance metrics.&lt;/p&gt;

&lt;p&gt;So, I think that Kaburaya has to explore the set-point aggressively when the set-point is too low.&lt;/p&gt;

&lt;h1 id=&#34;59-experimental-results&#34;&gt;59. Experimental results&lt;/h1&gt;

&lt;p&gt;In this page, I conclude experimental results.&lt;/p&gt;

&lt;p&gt;Kaburaya finds a good set point and adjusts numbers within ideal range by feedback control and elastic semaphore continuously.&lt;/p&gt;

&lt;p&gt;On the other hand, we found some key factors to improve kaburaya.&lt;/p&gt;

&lt;p&gt;The most important is the prediction accuracy of the set point.
The improvement will avoid that the number of the semaphore is too much or too less.&lt;/p&gt;

&lt;p&gt;And finding optimal parameters is also important.
Based on my experience, I got good results in most cases when the gain of the feedback controller is from 0.1 to 0.3 and the range of change rate is 0.3.
However, I think that we have to tune the parameters as necessary.&lt;/p&gt;

&lt;p&gt;I expect that there is a solution in the related researches on feedback control.&lt;/p&gt;

&lt;h1 id=&#34;60-conclusion&#34;&gt;60. Conclusion&lt;/h1&gt;

&lt;p&gt;OK, This is a conclusion.&lt;/p&gt;

&lt;h1 id=&#34;61-conclusion&#34;&gt;61. Conclusion&lt;/h1&gt;

&lt;p&gt;I proposed kaburaya to control the number of goroutines without depending on the platform, runtime, and current load.
Experimental results show possible and some issues of kaburaya.
In particular, improvement in detecting performance upper limit of the task is important.
In the future, I will also consider the application to auto-scaling of cloud computing.&lt;/p&gt;

&lt;h1 id=&#34;62-appendix&#34;&gt;62. Appendix&lt;/h1&gt;

&lt;p&gt;This is the Appendix.&lt;/p&gt;

&lt;h1 id=&#34;63-reference&#34;&gt;63. Reference&lt;/h1&gt;

&lt;p&gt;Here is Reference.
If you want to learn more about kaburaya, you can jump to the link.
Sorry, some texts are in Japanese.&lt;/p&gt;

&lt;h1 id=&#34;64-go-gopher&#34;&gt;64. Go gopher&lt;/h1&gt;

&lt;p&gt;The Go gophers in this slide were drawn by Keita Kawamoto.&lt;/p&gt;

&lt;h1 id=&#34;65-thank-you&#34;&gt;65. Thank you!&lt;/h1&gt;

&lt;p&gt;Thank you for listening.
It was a pleasure being here today.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Ebira: アクセス負荷に応じて継続的にスケーリング基準を最適化する汎用オートスケーリング機構</title>
      <link>https://blog.monochromegane.com/blog/2019/04/14/wsa_4_ebira/</link>
      <pubDate>Sun, 14 Apr 2019 17:33:09 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/04/14/wsa_4_ebira/</guid>
      <description>

&lt;p&gt;このエントリは、&lt;a href=&#34;https://websystemarchitecture.hatenablog.jp/entry/2019/02/26/100725&#34;&gt;第四回 Web System Architecture 研究会 (WSA研)&lt;/a&gt;の予稿です。&lt;/p&gt;

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;Webサービスの運用において，急激なアクセス頻度の上昇に対する安定性を保つため，Webアプリケーションにスケーラビリティの仕組みが一般的に求められるようになった．
これを支援するためにWebアプリケーションを稼働させるクラウドサービスやオーケストレーションツールから，オートスケーリング機能が提供されている．
しかしながら，機能を利用するためのスケーリング契機となる指標や基準値は，運用するWebサービスの特性を考慮して個別に決定する必要がある．
ホスティングサービスのように個々の運用対象に対する特性が不明かつ多様な環境においては，Webサービスの特性に依存しない汎用的なスケーリング戦略を備えた機構を
横断的に適用できることが，運用効率化並びに運用対象全体での安定化のために重要である．&lt;/p&gt;

&lt;p&gt;Webサービスの特性に依存しない汎用的なスケーリング戦略のためには，汎用的な指標や基準値が必要である．&lt;/p&gt;

&lt;p&gt;Webアプリケーションにおけるアプリケーションサーバは通常，複数のロールのサーバに処理を依頼し，これを統合してリクエストを返すことから，
CPUやメモリといった単一サーバにおけるプリミティブな指標からはその負荷状態を表すことが難しい．
三宅らは&lt;a href=&#34;https://www.ipsj.or.jp/event/fit/fit2018/FIT2018_program_web/data/html/abstract/CL-002.html&#34;&gt;仮想サーバの予測的オートスケーリング&lt;/a&gt;において，
アプリケーションの処理内容ではなく運用経験から得られたサーバ単位のスループットを指標として，これを予測するモデルによってサーバ台数調整機能を実現した．&lt;/p&gt;

&lt;p&gt;一方で基準となる値は運用経験から得られたものであり，運用対象に対する特性が不明な環境では用いることができない．
そこで，この特性を明らかにするために，&lt;a href=&#34;https://blog.mirakui.com/entry/2013/02/20/003401&#34;&gt;「全自動パラメータチューニングさん」&lt;/a&gt;のような探索的なアプローチ，
または，予測的なアプローチが採用される．
しかしながら，ホスティングのような環境では学習データの蓄積を含め，負荷の発生しうる操作の実施には慎重にならざるを得ない．
クラウドサービスやオーケストレーションツールで利用可能な指標の基準値はCPU使用率や秒間クエリ数，コネクション数などシステムが許容可能とみなせる値であり，これらを導くための負荷検証も同様である．&lt;/p&gt;

&lt;p&gt;三宅は&lt;a href=&#34;https://blog.monochromegane.com/blog/2018/11/25/wsa_3_kaburaya/&#34;&gt;Kaburaya: CPU負荷に応じて継続的に上限値を最適化する動的セマフォ&lt;/a&gt;において，
最適な並行数を継続的に求めるために処理対象の負荷の均衡点を目標とする方式を提案した．
この方式では，目標値を動的に変更しフィードバック制御を用いることで，並行数が増えすぎないようにすることができるためオートスケール機能への転用も可能であると述べた． しかしながら，CLIツールを対象とした実装のため，目標値をCPU使用率と定めたこと，一定の負荷が継続的に発生することを前提としたことから，目標値への追従のため継続的に負荷が発生する．&lt;/p&gt;

&lt;p&gt;Webサービスの特性に依存しない汎用的なスケーリング戦略のためには，汎用的な指標として外形的な指標を用いながら，特性に依存しない基準値をWebサービスへの負担なく求めたい．
本研究では，アクセス負荷に応じて継続的にスケーリング基準を最適化する汎用オートスケーリング機構を提案する．
実装には，Kaburayaのうち，ダイナミックターゲットコントローラの仕組みをCPU負荷ではなくWebサービスのレスポンスタイムに対して適用する．
すなわち，直近のレスポンスタイムが均衡する点に収束するような台数調整が行う．
なお，算出する理想台数と実際に追加する台数は分離可能とすることで，ホストのコンピューティングリソースの限界を加味した運用が可能となる．&lt;/p&gt;

&lt;h1 id=&#34;評価&#34;&gt;評価&lt;/h1&gt;

&lt;p&gt;本報告では，提案手法を算出エンジンに用いたシミュレーション環境で評価する．&lt;/p&gt;

&lt;p&gt;シミュレーションは，同時アクセス数によってレスポンスタイムが変化するサーバーによって，水平スケーリングがリニアに有効な状況と
同様の傾向を持つ後段サーバーへのアクセスによるボトルネックが発生し，水平スケーリングがリニアには有効とならない状況を用意した．
これらの環境において，単純なPID制御と比較して，提案手法が前提とする環境において有効であることを示す．&lt;/p&gt;

&lt;h2 id=&#34;シミュレーション環境&#34;&gt;シミュレーション環境&lt;/h2&gt;

&lt;p&gt;同時アクセス数によってレスポンスタイムが変化するサーバーは以下のようにモデル化した．&lt;/p&gt;

&lt;p&gt;$exp(c/el)-1+r$&lt;/p&gt;

&lt;p&gt;ここで，cは同時アクセス数，rは最小レスポンスタイムである．
elは伸長用の定数であり，これが大きければ同時アクセス数の増加に対してレスポンスタイムの増加が繰り延べされる．前段は100，後段は300とした．
なお，後段は水平スケーリングが行われず，前段からのアクセス数の合計が後段に対するアクセス数となり，レスポンスタイムはこれを合算したものとする．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/56059986-804a1500-5da0-11e9-8916-10b66ae6e0ba.png&#34; alt=&#34;expm1&#34; /&gt;&lt;/p&gt;

&lt;p&gt;それぞれのシミュレーション環境の最低な台数とレスポンスタイムを示す．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/56057806-bedcd100-5d9a-11e9-947e-0424283270c9.png&#34; alt=&#34;scalable-noope&#34; /&gt;
&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/56057928-10855b80-5d9b-11e9-8085-b518bfeebdc2.png&#34; alt=&#34;non_scalable-noope&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;水平スケーリングがリニアに有効な場合&#34;&gt;水平スケーリングがリニアに有効な場合&lt;/h2&gt;

&lt;p&gt;PID制御と提案手法の比較を示す．
PID制御は最小レスポンスタイムを平常時の運用において把握したとする．
なお，提案手法では内部にPID制御を用いるが，最適値を動的に求めるため最小レスポンスタイムの把握は不要である．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/56058043-5a6e4180-5d9b-11e9-80af-da6add2d8acd.png&#34; alt=&#34;scalable-pid&#34; /&gt;
&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/56058136-8e496700-5d9b-11e9-9847-2d497f0664ec.png&#34; alt=&#34;scalable-kaburaya&#34; /&gt;&lt;/p&gt;

&lt;p&gt;レスポンスタイムとスケーリングの台数が単純な関係である場合，実装は簡単である．
PID制御は最小レスポンスタイムさえ取得できれば綺麗な適応をする．
一方で提案手法は下げ幅が不足して供給過剰な状態が発生した．
これは目標値の変更を止めるための判定が早期に行われたためであり，間接的には変化率を直前との比較でしか行なっていないことが理由となる．
実運用では，この期間を延伸，さらには移動平均のような形で平滑化してこの精度を向上させる必要がある．&lt;/p&gt;

&lt;h2 id=&#34;ボトルネックがある場合&#34;&gt;ボトルネックがある場合&lt;/h2&gt;

&lt;p&gt;PID制御と提案手法の比較を示す．
最小レスポンスタイムに関する注釈は上記と同じである．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/56058547-a077d500-5d9c-11e9-8c8d-41da2ba4dfdc.png&#34; alt=&#34;non_scalable-pid&#34; /&gt;
&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/56058588-beddd080-5d9c-11e9-9b34-ad8812f8f025.png&#34; alt=&#34;non_scalable-kaburaya&#34; /&gt;&lt;/p&gt;

&lt;p&gt;このシミュレーションではボトルネックに達したことでPID制御によるスケーリングが最小レスポンスに到達しないことで永遠に台数を追加している．
実際にはシステムに最大上限が設けられるが，その最適な上限値についてもWebサービスの特性に依存することから容易に決定することはできない．
一方，提案システムでは，これらの情報を知らずとも目標値の修正によってこれに対処する．
下げ幅の不足については上記と同じ方法での解決が見込める．&lt;/p&gt;

&lt;h1 id=&#34;発表スライド&#34;&gt;発表スライド&lt;/h1&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;70c79a7d33df43f59cb4c9a75aed39df&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;発表を終えて&#34;&gt;発表を終えて&lt;/h1&gt;

&lt;p&gt;今回の発表は前回のアイディアであるKaburayaの具体的な適用箇所を想定したものとした．
個人的な最近の一番の変化だと思っているのが，長期間付き合えるアイディアが出てくるようになったことだ．
長期間付き合えるというのは，1. ビジョンがあって長期間かけてそれらを実現していくもの，2. 汎用的なアイディアがあってそれらの適用先を広げていくもの，の2つがあると思う．
1.については，研究テーマであるなめらかなマッチングに対して一歩づつ進めており，2.についてはWSA研を始めとした個人の興味発のプロダクトがそのようになっている．
特に研究に携わるまでの個人の興味発のプロダクトはたくさんOSSとして公開していたものの，その場限りのもも多く，実際の適用や発展が少なかったように思う．
Kaburayaを始めとする最近のプロダクトでは，なるべく実装から切り離して目的，妥当性，そして背景を整理しながらアーキテクチャ，機構，システムとしての骨組みを整え，自分なりにその本質に迫るようになった．
そして，どのような評価をすればこれらの有効性を示せるかを踏まえた上で実装をする．
これはまさに研究の論文的アプローチであり，これから生まれたプロダクトは以前と比べて芯があり発展性が増してきたように思える．
実際にKaburayaは，WSA研#3での発表を皮切りに東京のGoConで発表し今年サンディエゴであるGopherConにも採択された．そして今回のWSA#4ではオートスケーリングへの転用の可能性も示せた．&lt;/p&gt;

&lt;p&gt;周りを見れば具体と抽象を自在に素早く行き来し，自由闊達かつ高度な意見を交わす人々ばかりで自信を失いかけるけれども，己だけを見た時には多少の成長も感じられるようにはなったと思う．
研究職になってレベルが0になった時期もあったけれども，エンジニアとしての具体化能力との相乗効果が出せるようにこれからも精進して行きたい．&lt;/p&gt;

&lt;p&gt;普段の研究から少し離れながらも研究的なアプローチを進めることができているのはWSA研によるところも大きい．
予稿をブログで書いておけばあとは当日の議論がメインであり，色々な観点からアイディアを練ることができる．このスピード感と濃密感は，エンジニア向けのカンファレンスと学会のいいとこ取りになっている．
定期的にあるところも大変良くて，強制的にアイディアが形になり，進んでいく．&lt;/p&gt;

&lt;p&gt;総じて第四回もとても良い会であった．興味がある方は9月福岡で開催の第五回への参加を検討してみてはいかがだろうか．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>なめらかなシステムの見据えるもの。個人的考察</title>
      <link>https://blog.monochromegane.com/blog/2019/03/01/the-things-coherently-fittable-system-looks-ahead-to/</link>
      <pubDate>Fri, 01 Mar 2019 16:47:54 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/03/01/the-things-coherently-fittable-system-looks-ahead-to/</guid>
      <description>

&lt;p&gt;ペパボ研究所ではシステムの利用や運用における様々な障壁を取り除いた、なめらかな利用や運用を目指して研究を行っている。
本稿では、なぜなめらかでなければならないかの問いを端緒とし、定義の解釈を試みることで、なめらかなシステムの見据える未来について考察する。
考察を通して、なめらかなシステムの見据えるシステム観を再認識し、システム設計の道標にするとともにそれらの普及した場合への対処としてのなめらかなシステムの有用性を確認する。&lt;/p&gt;

&lt;h1 id=&#34;なめらかなシステムを解釈する&#34;&gt;なめらかなシステムを解釈する&lt;/h1&gt;

&lt;h2 id=&#34;なめらかなシステムを構成する要件&#34;&gt;なめらかなシステムを構成する要件&lt;/h2&gt;

&lt;p&gt;ペパボ研究所では、システムの利用や運用における様々な障壁（ゴツゴツ）を取り除き、利用の快適さや運用における生産性の向上に繋げるため、以下の「なめらかなシステム」を提案、実現に向けた取り組みを進めている。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;「なめらかなシステム」とは、情報システムのことをいうのみならず、互いに影響を及ぼし合う継続的な関係にある利用者（ユーザーおよび開発運用者）と情報システムとからなる総体としてのシステムであり、以下の要件を満たします：

1. 利用者と情報システムとが継続的な関係を取り持つ過程において、利用者それぞれに固有のコンテキストを見出したり、新たなコンテキストを創出したりできること
2. 要件1.を、利用者による明示的な操作を課すことなく実現できること
3. 要件1.および2.によって得られたコンテキストに基づき、情報システムが利用者に対して最適なサービスを自動的に提供できること

ref: https://rand.pepabo.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;すなわち、システム総体における要素の状態、状況、条件といった「文脈」が暗黙的に認識され、文脈ごとに最適な振る舞いが提供されるシステムである。
ここで、なめらかなシステムは上記の要件をすべて満たす必要があることに注意したい。
特定指標の予測や限定的な自動化はなめらかなシステムを構成する基礎技術ではあるがそれ単体ではなめらか足り得ない。&lt;/p&gt;

&lt;h2 id=&#34;なぜなめらかでなければならないか&#34;&gt;なぜなめらかでなければならないか&lt;/h2&gt;

&lt;p&gt;なめらかなシステムを実現するにあたっては、文脈をシステムで利用可能な指標に落とし込み、これを暗黙的に獲得し、この文脈指標に適応した振る舞いを定義しなければならない。
このように、なめらかなシステムは利用者や運用者への利益をもたらすが、同時に複雑性も持ち込む（システム操作に含まれない過去の経験や状況まで含めた文脈と指標の紐付けが困難であり、そのためのログ基盤、機械学習基盤、予測フィードバック機構の整備が大変なことは同意いただけるだろう）。&lt;/p&gt;

&lt;p&gt;そのため、なぜなめらかでなければならないかを明確にし、その必然性から適用を検討すべきであると考える。
我々は&lt;a href=&#34;http://tsys.jp/dicomo/2018/program/4B_abst.html&#34;&gt;なめらかなシステムの論文化&lt;/a&gt;(&lt;a href=&#34;https://rand.pepabo.com/article/2018/07/25/dicomo2018/&#34;&gt;論文と発表資料&lt;/a&gt;)にあたり、従来の定義を洗練し、システムの利便を得るべき人間の存在をシステム総体のうちに組み込むことを明示した。
これにより、このような人間は、様々な文脈を持つこと、そして情報要求がコミュニケーションによって逐次変化していくことに着目し、情報システム側もこれに追従する仕組みが必要であると述べた。
すなわち、様々な文脈を持ち、変化し続ける対象としての人間の存在を以って、これに対応するためのなめらかなシステムの必要性を主張した。&lt;/p&gt;

&lt;p&gt;一方で、なめらかなシステムでは、利用者やシステムコンポーネントなどは振る舞いを持って役割とし、本質的には等価にみなすことができると考える。
であれば、様々な文脈を持ち、変化し続ける対象としての人間の存在を解釈し直すことで、なめらかなシステムを適用すべき対象を定義することができるのではないか、というのが本稿の主旨である。&lt;/p&gt;

&lt;h1 id=&#34;利用者を解釈する&#34;&gt;利用者を解釈する&lt;/h1&gt;

&lt;h2 id=&#34;個性を持つ存在として捉える&#34;&gt;個性を持つ存在として捉える&lt;/h2&gt;

&lt;p&gt;ここでは、様々な文脈を持ち、変化し続ける対象としての人間を「個性」という観点で汎用化を試みる。
そのために、利用者が様々な文脈を持つことと複雑性の関係について見直したい。
様々な文脈を持つことを何らかの方法でシステム的に取り扱える指標に変換できた場合、それは多次元の特徴量として表現されるだろう。
これらを以って振る舞いを定義する必要がある場合に、必ずしもすべての特徴量の組み合わせに対処するように定義しなければならないかといえばそうではない。
情報要求の満足度に対する各次元の寄与度は均等ではないはずで、一定のパターン数での対応で現実的には可能であるように思える。
実際、少なくとも現状のシステムは部分的には制御可能なパラメタのもと、ヒューリスティックな対処がまだ有効な範囲内で行われていることからも言えるだろう。
もちろん、様々な文脈としての特徴量の次元数が多いことは複雑さの増加には繋がる。
しかしながら、複雑であるとしてみなさなければならないのは対応パターン数ではなかろうか。&lt;/p&gt;

&lt;p&gt;本稿では、このような対応パターン数を増加させる対象を「個性を持つ」と表現したい。
ここで、「個性を持つ」とは、ある面では同じクラスタに属しながらも同じ入力に対して異なる振る舞いを行うことだと定義する。
これには、人間はもちろんのこと、クラスとインスタンスの関係のように、異なるデータで学習した機械学習のモデルなどがあるだろう。
このような対象に対するコミュニケーションは傾向はあるとしても正解はなく、対象や文脈を仮定しながら試行を繰り返し歩み寄っていく必要があるはずだ。
そして、そのような歩み寄りの過程こそがなめらかなシステムの構成要件であると言える。&lt;/p&gt;

&lt;h2 id=&#34;概念の獲得が個性をもたらす&#34;&gt;概念の獲得が個性をもたらす&lt;/h2&gt;

&lt;p&gt;集団における共通項として概念が獲得されることで概念を満たす内部実装が多様化し得るのではないか。
共通のインターフェースを持ちながらに、別の面では振る舞いに差が現れる。
人間は自身の感覚器からの情報を生で知覚するのではなく、（おそらく）多層の抽象化、概念化を通した結果として知覚する。
また、個々が理解している概念の表層として言葉を操り、（おそらく）同じような理解をしているであろう対象とコミュニケーションを行う。&lt;/p&gt;

&lt;p&gt;これまで機械としてのシステムは、個性が生まれるように設計されたものがそのように振舞っていた。
しかしながら機械としてのシステムが互いに共通インターフェースである概念や定義を獲得し、それを満たす実装や解釈を行うようになれば個性の爆発が起きるのではないかと思う。&lt;/p&gt;

&lt;h2 id=&#34;わからないものとして扱う&#34;&gt;わからないものとして扱う&lt;/h2&gt;

&lt;p&gt;ここではなめらかなシステムの実現にあたっての実装寄りのアプローチについて検討する。
個性を持つシステム要素はその性質上、相互にわかり合うことはできないため、なめらかなシステムのようなアプローチを通して歩み寄らなければならない。
このような「わからない状況」をシステムとして扱うためには、単体の手法ではなく状況に応じたいくつかの方法論の組み合わせが有効であろう。
まず入力の大局や傾向については回帰や機械学習などからなる予測的なアプローチをとり、予想外の入力変化に対しては例えばフィードバック制御などの脊髄反射的な対応が求められる。
次に、入力に応じたパターンの選定では、なめらかなシステムが前提とする対象において、無限のパターンが想定されることから、実運用環境での最適化が必要である。
具体的には多腕バンディット問題として取り扱ってもよいだろうし、進化的、遺伝的アルゴリズムを用いた解法も選択肢に入るだろう。
このパターン選定のための最適化アプローチは多くの試行を要するが、対象をシステム要素とみなす場合はその労苦は考慮不要であるし、
人間を対象とする場合であってもシステム利用者全体の操作を束ねたものを利用すればよいだろう。&lt;/p&gt;

&lt;h1 id=&#34;なめらかなシステム再考&#34;&gt;なめらかなシステム再考&lt;/h1&gt;

&lt;p&gt;ここまでの考察から、なめらかなシステムは個性を持つ対象とのコミュニケーションが発生する状況において求められ、これに継続的に適応可能なアーキテクチャのことを指すと考えられる。
例えば、推薦システムは、人間を対象とし提示した推薦結果に対する反応が異なることことから、なめらかなシステムの適用先の事例として考えやすいであろう。
では、なめらかなオートスケーリングはありうるか。
特定サービスの単一メトリクスに基づいてルールベースの増減するような場合、例え入力に多様性があっても、システムとしては決められた挙動を行うだけであり、動的制御であってもなめらかではないことは自明である。
一方で、オートスケーリングの指標において、より抽象的な概念である、キツい、ダルい、調子良いのような言葉を以って、いい感じに振る舞うことができるとすれば、そこには解釈の余地が生まれ、入力への対処の自由度、すなわち個性を持った対応が必要になる。
また、非常に複雑なシステムにおいて増減自体が他へ与える影響が読めないような場合にいい感じに落とし所を見つけなければならないのであれば、そのような状況も個性を前提としたものであろう。
このような対応パターンの増加に対するアプローチは先に述べた通りであるが、概念の創出とパターンに対する最適化は相互に洗練していくことになるだろう。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;本稿では、なぜなめらかでなければならないかを問いの発端とし、システムの利便を得るべき人間について個性の観点から再解釈することで、なめらかなシステムの見据える未来を明確化した。
なめらかなシステムについての考察は、完全にこれを実現した突出したシステムが突然表出するわけではなく、システム総体に含まれる要素が相互に徐々に複雑化していく過程で、これに対応する必然性から最適化が行われ、
さらにその複雑性が、個性を育てるというような、今後のシステムの進化そのものを想起させる。
であれば、システム設計において進化の方向性としてこれを意識することで、従前の単なる自動化や動的制御の先を見据えた発想になるのではないか、その環境においてどのように対応すべきかを考える道標となるのではないか。
本考察が、その一助となれば幸いである。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>わかるとわからないの間</title>
      <link>https://blog.monochromegane.com/blog/2019/02/25/entrance-of-research/</link>
      <pubDate>Mon, 25 Feb 2019 23:41:04 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/02/25/entrance-of-research/</guid>
      <description>&lt;p&gt;元来が完璧主義である．理解できない場合にはレイヤが異なっていたとしても大部分がソースコードやプロトコルとして定義されていて掘り下げて調べていくことで挙動が把握できるようになるソフトウェアエンジニアは性に合っていた．
ところがここ数年は推薦システムに興味を持ち，あまつさえ研究として取り組もうとしたものだから，人間の認知プロセス解釈の果てしない旅に途方に暮れてしまった．
理解できていない状態が自信の無さを招き，自説を守りきれずに論文を落とした．&lt;/p&gt;

&lt;p&gt;それでも対象の推薦システムの実装やKaburayaの構想を進める中で，現状把握できる部分的な情報や結果を元に適応していくアプローチが十分有効になり得るのではないかと思え始めた．
このようにある意味「わからない」を取り扱うアプローチは，工学的な方法だと一般的なのかもしれないが，多くの部分を把握できる可能性があるソフトウェア分野の経験からは新鮮であった．&lt;/p&gt;

&lt;p&gt;今は，とにかく提案システムの有用性を示していく段階ではある．ただ，「わからないから進めない」を脱することができたことが素直に嬉しい．
さらには，起点を作れたことで「わからない」分野に対して挑む方針も固まってきた．「わかるために進む」のは気持ちが良いものだ．&lt;/p&gt;

&lt;p&gt;わからない場所に踏み込む．本当にいつも遠回りばかりしている気がするが，ようやっと研究の入り口に立てたのかもしれない．&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;もちろんソフトウェアだからわかる，人間だからわからないというのはいささか短絡的である．
単純なものから複雑なものへの発展の経過を追うことが可能であるがゆえに理解ができているのであって，ソフトウェアであっても巨大で変化の激しいシステムは経緯を含めた全容の理解は困難になる．
反対に人間の認知であっても高次の抽象レベルのみで正確な疎通が可能な概念であれば相互理解は可能であろう．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>拠点間勉強会を接続するリモート勉強会への誘い</title>
      <link>https://blog.monochromegane.com/blog/2019/02/23/remote-study-group/</link>
      <pubDate>Sat, 23 Feb 2019 17:26:50 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/02/23/remote-study-group/</guid>
      <description>

&lt;p&gt;主催する&lt;a href=&#34;https://fukuokago.tech/&#34;&gt;Fukuoka.go&lt;/a&gt;は今月2回のリモート勉強会を実施しました。リモート勉強会に関心のある主催者の参考になればと思い、このエントリではリモート勉強会の開催に関するハウツーと利点、課題を整理します。タイトルは&amp;rdquo;いざない&amp;rdquo;と読んでください。雅ですね。&lt;/p&gt;

&lt;h1 id=&#34;経緯&#34;&gt;経緯&lt;/h1&gt;

&lt;p&gt;私は福岡在住です。前回の&lt;a href=&#34;https://gocon.jp/&#34;&gt;GoCon&lt;/a&gt;で東京に&lt;a href=&#34;https://speakerdeck.com/monochromegane/optimization-of-goroutine-numbers-by-feedback-control&#34;&gt;発表&lt;/a&gt;しに行った際に、岡山の&lt;a href=&#34;https://twitter.com/qt_luigi&#34;&gt;岩田プロ&lt;/a&gt;とお話しする機会がありました。
知り合えたのも何かの縁、福岡と岡山で何か面白いことやりましょうとふわっと約束したのを覚えています。
福岡への帰路、イベントのアイディアを考えながら、やはり物理的な距離の制約が面倒だなと思い至りました。
幸い、所属するGMOペパボでは東京オフィスと福岡オフィス間を繋いだ&lt;a href=&#34;https://tech.pepabo.com/2018/09/11/pepabo-tech-friday/&#34;&gt;勉強会（PTF）&lt;/a&gt;を定期的に開催しており、この方式を社外の勉強会に転用するという着想を得ました。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://fukuokago.connpass.com/event/112073/&#34;&gt;Fukuoka.go#13+Okayama.go&lt;/a&gt;と銘打ったイベントの準備は順調に進み、当日は、&lt;a href=&#34;https://togetter.com/li/1318568&#34;&gt;両会場からの発表を行い&lt;/a&gt;会場を挟んだ質疑応答のコールアンドレスポンスも楽しめました。
気を良くして数日後に東京で行われた&lt;a href=&#34;https://fukuokago.connpass.com/event/118377/&#34;&gt;Go1.12 Release Party&lt;/a&gt;にも接続させてもらい、東京会場の発表を聞いたり、福岡からも&lt;a href=&#34;https://speakerdeck.com/monochromegane/understanding-go-language-server&#34;&gt;発表&lt;/a&gt;を行いました。当日は大阪会場も接続していたようです。
各回、各会場とも満足度が高く成功だったと言えるでしょう。&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;いやあ，大成功じゃないですか〜楽しかった〜また繋いでやりましょう〜〜！！ &lt;a href=&#34;https://twitter.com/hashtag/fukuokago?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#fukuokago&lt;/a&gt; &lt;a href=&#34;https://twitter.com/hashtag/okayamago?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#okayamago&lt;/a&gt;&lt;/p&gt;&amp;mdash; モノクロメガネ研究員 (@monochromegane) &lt;a href=&#34;https://twitter.com/monochromegane/status/1095307409428340736?ref_src=twsrc%5Etfw&#34;&gt;2019年2月12日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;以下では、これらのリモート勉強会を通して得たハウツーや考察を紹介します。リモート勉強会の開催に興味を持った方は良ければ参考にしてください。&lt;/p&gt;

&lt;h1 id=&#34;1-リモート勉強会とは&#34;&gt;1. リモート勉強会とは&lt;/h1&gt;

&lt;p&gt;このエントリでは、勉強会を、一定人数が会場に集まり発表者の登壇を参加者が聴講し、必要に応じて質疑応答がなされる形式のものとします。
そして、リモート勉強会とは、そのような複数の勉強会会場がインターネット越しに音声と映像を双方向に中継され、同期したタイムテーブルの下で進行される形式のものとします。&lt;/p&gt;

&lt;h1 id=&#34;2-接続方式と構成&#34;&gt;2. 接続方式と構成&lt;/h1&gt;

&lt;h2 id=&#34;接続&#34;&gt;接続&lt;/h2&gt;

&lt;p&gt;拠点間接続にはビデオ会議サービスを利用します。音声、映像、そして画面共有ができるものが必要です。
さらに参加時の敷居を下げるため特定のアプリケーションに依存せずブラウザ単体で動作するものが望ましいと考えます。
今回はこれらの要件を満たす、&lt;a href=&#34;https://gsuite.google.co.jp/intl/ja/products/meet/&#34;&gt;Google Hangouts Meet&lt;/a&gt;を利用しました。&lt;/p&gt;

&lt;p&gt;Hangouts MeetはG Suite利用者のみミーティングを作成することができますが、Googleアカウントを持っていれば（許可制ではありますが）G Suite利用者以外のアカウントも参加することが可能です。&lt;/p&gt;

&lt;h2 id=&#34;構成&#34;&gt;構成&lt;/h2&gt;

&lt;p&gt;会場ごとに少なくとも1台のPCから会議に参加している状態とします。会場参加者の映像や音声を伝えるのはこのPC（と外部接続のカメラやマイク）が担当します。
また発表資料のあるPC上（一般には発表者の個人PC）からも同様に会議に参加しておきます。会場の音声が重複することを避けるため、発表者PCではマイクをオフにしておきます。
映像は自由ですが、だいたい他の人の発表を聞いている時の間抜け面が全会場に配信されるため、特に理由がない限りカメラもオフにしておくと良いでしょう。
発表時は、発表者のPCから画面共有を行い、資料を全会場で閲覧できるようにします。&lt;/p&gt;

&lt;p&gt;小さい会場の場合は会場のPCと発表者のPCが兼業することになり、より直感的に準備が進むと思います。
大きな会場の場合は、会場のPCとカメラやマイクの外部接続が必要になります。ここについては共同主催者の&lt;a href=&#34;https://twitter.com/linyows&#34;&gt;@linyows&lt;/a&gt;が別途、「リモート勉強会を支えるオーディオ技術」としてエントリを書いてくれるはずです。読みたい！&lt;/p&gt;

&lt;p&gt;なお、これまでの開催を通して、各会場のカメラは、登壇者を写すもの、会場の様子を写すものの2つがあると一体感が増すように感じました。
そのため各会場からはこれを担う2つのPCが会議に参加していると良さそうです（マイクは一台のみオンとする）。&lt;/p&gt;

&lt;h1 id=&#34;3-リモート勉強会におけるリモート会議サービスの実用性&#34;&gt;3. リモート勉強会におけるリモート会議サービスの実用性&lt;/h1&gt;

&lt;p&gt;現在のリモート会議サービスであれば十分リモート勉強会で利用することは可能だと考えます。&lt;/p&gt;

&lt;p&gt;特に、このエントリで定める勉強会方式、つまり情報の向きが単方向でシーケンシャルに制御されている、登壇と質疑応答のような方式にはビデオ会議サービスは非常に適していると思えました。
個人的には現実の会議ではリモート会議越しだと視線や挙動をうまくつかめずに同時に話してしまったり逆に沈黙があったりとまだ少しだけ違和感を感じますが、登壇形式であればそのような状況はあまり発生しません。&lt;/p&gt;

&lt;p&gt;また、別会場の音声が聞き取りにくいとストレスを感じますが、少なくともGoogle Hangouts Meetを使用している限りでは接続は非常に安定しており、ここを課題と感じることはありませんでした。
ただ、音声機器に関してはPC内蔵マイク/スピーカーと外付け機器を比較した場合、品質向上はもちろんのことボリューム調整なども容易になるため、予算に応じて良いものを手配した方が良いと思います。
関連して、Google Hangouts Meetの設定で外付け機器が適切に選択されていることも確認する操作も準備の際に忘れないようしたいところです（今まで二回ともこれでハマっている）&lt;/p&gt;

&lt;p&gt;準備についても初回こそ念のため別日に接続リハーサルを行いましたが、2回目からは初めての会場同士であっても開始1時間前に接続して音量チェックを行う程度で十分間に合いました。&lt;/p&gt;

&lt;h1 id=&#34;4-リモート勉強会-実施時の課題&#34;&gt;4. リモート勉強会、実施時の課題&lt;/h1&gt;

&lt;h2 id=&#34;別会場からの質問が届かない場合がある&#34;&gt;別会場からの質問が届かない場合がある&lt;/h2&gt;

&lt;p&gt;これは発表者のいる会場側でも同時に質問が上がった場合に発生します。おそらく音声が被って聞こえなかったのだと思われます。
会場間で情報をシーケンシャルに制御できないことに起因するものであり、例えば各会場の司会が明示的に会場を指定した質問の募集をする等、質疑応答の進め方を事前に相談しておくと良さそうです。&lt;/p&gt;

&lt;h2 id=&#34;発表者は-別会場のリアクションを知ることができない&#34;&gt;発表者は、別会場のリアクションを知ることができない&lt;/h2&gt;

&lt;p&gt;発表者のPCはスライドモードで全画面が占められていることから、他の会場の映像を見ることができません。そのため渾身のネタがスベったのか笑いが発生したのか、今の説明が聴衆を置いてけぼりにしていないかなどの反応を知るためには自分の会場の聴衆をサンプルとする必要があります。
実際の発表中は、前の方の十数名ぐらいしか見ていないので問題はないのですが、例えば別会場の笑い声などをうまく伝えられるようにしたり、発表者が見ることができる別のディスプレイに他の会場の様子が映されていたりするのも良いかもしれません（嗚呼、どんどん設備が豪華になっていく&amp;hellip;）&lt;/p&gt;

&lt;p&gt;反対に、会場間の聴衆側の雰囲気の共有については他のツールに移譲してしまって良いと思っています。
具体的にはTwitterのハッシュタグを共有するなどして実況ツイートが流れれば十分、会場間の一体感が感じられました。&lt;/p&gt;

&lt;h2 id=&#34;google-hangouts-meetとkeynoteの画面共有で発表者ディスプレイモードが利用できない&#34;&gt;Google Hangouts MeetとKeynoteの画面共有で発表者ディスプレイモードが利用できない&lt;/h2&gt;

&lt;p&gt;これはリモート勉強会というよりはGoogle Hangouts MeetとKeynoteの使い方の問題ですが、発表者ディスプレイモード（発表者の手元の表示が次のスライドや経過時間がわかるようになる）が利用できなかったため発表が若干やりにくかったです。
ウィンドウの共有からKeynoteを選択し、スライドを開始すると手元のディスプレイが真っ黒になるため、画面全体を共有してスライドを開始していますが、手元のディスプレイが発表者ディスプレイモード（次のスライドや経過時間がわかる表示）ではなく参加者が見ているのと同じ状態になってしまいます。&lt;/p&gt;

&lt;p&gt;ただ、ここに関しては、&lt;code&gt;外部モニターを接続し、外部モニターを画面共有先にすることで回避が可能&lt;/code&gt;と検証していただいていたので次回試してみようと思います。&lt;/p&gt;

&lt;h1 id=&#34;5-なぜ勉強会会場を接合点としたか&#34;&gt;5. なぜ勉強会会場を接合点としたか&lt;/h1&gt;

&lt;p&gt;リモート会議サービスへ参加すればよい環境となっていることから、勉強会会場に行かずとも家やオフィスから見たいという声も聞くようになりました。
これについては、極端な場合、接合点を参加者とするような、会場という概念がない勉強会は開催はできても継続はできないのではないかなと考えます。
ただ、最終的には勉強会ごとのポリシーに沿うでしょうし、絶対的な正解はないことから、ここでは個人としての考えを述べます。&lt;/p&gt;

&lt;h2 id=&#34;サービスの制限&#34;&gt;サービスの制限&lt;/h2&gt;

&lt;p&gt;単純にサービスの制限として同時接続数が定められている（Google Hangouts Meetだと50ぐらい）ために接続を会場と発表者に限定したい。
ですので制限が緩和されたり制限未満の参加者であれば勉強会開催はもちろん可能です。&lt;/p&gt;

&lt;h2 id=&#34;発表者のモチベーション&#34;&gt;発表者のモチベーション&lt;/h2&gt;

&lt;p&gt;本エントリで述べる形式の勉強会で発表する方のモチベーションはプレゼンス向上や議論による提案のレベルアップ、便利情報の共有によるコミュニティへの還元など様々ですが、一定の人数を相手に一定の時間、注目をしてもらうために少なからず時間を投資してクオリティを確保した資料と発表準備を行なっています。&lt;/p&gt;

&lt;p&gt;これに応じるようなある種の熱量は、たとえ数が揃っていたとしても個人の集まりでは発生させるのは難しいと思っていて、やはり目的や時間を共有しているような集団とこれをオーガナイズする人がいてこそだと思います。
この熱量を相互に期待することで会が成り立ち、活発な議論やスパイク的な反応が生まれる、これを満たす集団が各会場の勉強会にあたると考えています。
また、家やオフィスだとどうしても&amp;rdquo;ながら見&amp;rdquo;になりますし、発表者にとっても自分の前に実際に誰もいない状態での発表というのは（発表に慣れた人であるほど）逆にやりにくいものです。
これらの理由から、どうしても最寄りの会場への移動が困難である等の個人接続は許容した上で、勉強会会場単位での接続が良いのではないかと考えます。&lt;/p&gt;

&lt;h2 id=&#34;そもそも集うことが目的でもある&#34;&gt;そもそも集うことが目的でもある&lt;/h2&gt;

&lt;p&gt;特にFukuoka.goは、単純に集まって&lt;a href=&#34;https://press.forkwell.com/entry/2018/10/01/community_lovers&#34;&gt;興味関心を同じくする人と知的好奇心をくすぐる話題を肴に同じ時間を過ごしたい&lt;/a&gt;というのが源流としてあり、普段はバラバラに活動している人たちが集まってワイワイするのが目的だったりします。&lt;/p&gt;

&lt;p&gt;コミュニティは実在するものではなく活動が継続していることでのみ存在を維持できると思っており、主催側自体も楽しめること、新しい参加者や知識、提案が吹き込まれることを常時望んでいます。
そのため、志を同じくする熱量のある集団として別地域の勉強会と知り合えることはお互いに利がありますし、単純に嬉しいものです。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;いくつかの理由を述べましたが、上述の通り何が正解というわけではなく、今後、色々試してみてより楽しんで楽にできるやり方を探したいところです。&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;福岡在住の技術者として、リモート勉強会を通して、距離の制約から解放され、興味ある分野の勉強会に参加して発表をリアルタイムに聞けること、さらに自分のノウハウや提案をより多くの人に聞いてもらえる機会が広がったことを嬉しく思います。
また、勉強会の主催者としても、知らないうちに出来上がるコミュニティの枠に対して新規の参加者同士が交流しやすくなることによって、停滞感が払拭され結果的に各勉強会自身の活発化が促されるであろう利点にも注目しています。
今後もリモート勉強会を通して、地域の勉強会が等価に柔軟に接続し合うことで一層のコミュニティ発展に繋がることを願っています。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>OSS Gateにサポーターとして参加した（東京・福岡）</title>
      <link>https://blog.monochromegane.com/blog/2019/01/17/oss-gate-as-supporter/</link>
      <pubDate>Thu, 17 Jan 2019 23:01:13 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2019/01/17/oss-gate-as-supporter/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;https://oss-gate-fukuoka.connpass.com/event/111602/&#34;&gt;OSS Gate Fukuoka&lt;/a&gt;にサポーターとして参加した．サポーターとしての二度目の参加で前回は&lt;a href=&#34;https://oss-gate.doorkeeper.jp/events/76041&#34;&gt;OSS Gate東京ワークショップ2018-10-27
&lt;/a&gt;だった．&lt;/p&gt;

&lt;p&gt;OSS Gateは&lt;code&gt;「OSSの開発に参加する」を実際に体験するワークショップ&lt;/code&gt; である．
元々，OSS開発に関するノウハウなどを共有するためのOSS道場という個別相談会を社内でやっており，その関連でサポーター役を紹介をしてもらったという経緯がある．
OSS道場が自分のOSSを作ることを通してエンジニアリングに必要な各種スキルを高める目的としているのに対して，OSS GateはOSS世界への参加の敷居を下げるために実際に既存のOSSプロジェクトに参加貢献するところを一緒にやっていきましょうというものになっている．&lt;/p&gt;

&lt;p&gt;カリキュラム自体は非常に洗練されており，OSS未経験者であるビギナーはもちろんのこと，手伝う側のサポーターもOSS Gate自体が初めてでもいきなり参加できるようになっている．
具体的な内容は&lt;a href=&#34;https://github.com/oss-gate/workshop/blob/master/tutorial/scenario.md#%E3%82%B7%E3%83%8A%E3%83%AA%E3%82%AA&#34;&gt;こちら&lt;/a&gt;を見ていただくとして，対象のOSSを見つけて実際にIssueやPullRequestを送るまで一連の流れを経験できる．&lt;/p&gt;

&lt;p&gt;前回の東京開催の後に福岡開催できればなあと考えていたところ，同僚のうづらさんなどがうまい事引っ張ってきてくれたので渡りに船だった．福岡での開催も和気あいあいと良い雰囲気で進んだと思う．&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;うづらさんも言っていたが，福岡でOSS Gateに参加してくれた人は，次にぜひFukuoka.rbやFukuoka.goなどのコミュニティに参加してほしい．
どのコミュニティも技術を楽しんでいるところばかりで，OSSへの参加や自分のOSSを作ろうというモチベーションにきっと繋がると思う．&lt;/p&gt;

&lt;p&gt;ちなみに&lt;a href=&#34;https://fukuokago.connpass.com/event/112073/&#34;&gt;Fukuoka.go#13&lt;/a&gt;は2月ですよ！&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Go Conference 2018 Autumnで発表してきた(3年ぶり3回目)</title>
      <link>https://blog.monochromegane.com/blog/2018/11/27/go-conference-2018-autumn/</link>
      <pubDate>Tue, 27 Nov 2018 16:58:11 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2018/11/27/go-conference-2018-autumn/</guid>
      <description>

&lt;p&gt;11/25に&lt;a href=&#34;https://gocon.jp/&#34;&gt;Go Conference 2018 Autumn&lt;/a&gt;というイベントで&lt;code&gt;フィードバック制御によるGoroutine起動数の最適化&lt;/code&gt;を発表してきました．&lt;/p&gt;

&lt;p&gt;Goでの開発時に常に悩んでいたGoroutine起動数に関してフィードバック制御という切り口でKaburayaアーキテクチャと題して解決策を検討したものです．
直前に&lt;a href=&#34;https://blog.monochromegane.com/blog/2018/11/25/wsa_3_kaburaya/&#34;&gt;WSA研向けに研究として再定義した&lt;/a&gt;ことでGoroutineにこだわらない，より汎用的な問題に対するアプローチとして検討し直すことができ，まだ最適解は模索中ですが，面白いと思っていただける発表ができたのではと考えています．&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;3fb10a250cd44b8799eac767baec5cc9&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;iframe src=&#34;//hatenablog-parts.com/embed?url=https%3A%2F%2Fgithub.com%2Fmonochromegane%2Fkaburaya&#34; title=&#34;monochromegane/kaburaya&#34; class=&#34;embed-card embed-webcard&#34; scrolling=&#34;no&#34; frame border=&#34;0&#34; style=&#34;width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;&#34;&gt;&amp;lt;a href=&#34;https://github.com/monochromegane/kaburaya&#34;&amp;gt;monochromegane/kaburaya&amp;lt;/a&amp;gt;&lt;/iframe&gt;

&lt;p&gt;歴史ある制御工学という分野の手法を用いることで蓄積されたノウハウを活用できると考えていましたが，発表後に早速有意義なアドバイスなど頂くことができ，今後の精度，速度向上並びに汎用化に向けて面白くなってきそうです．&lt;/p&gt;

&lt;p&gt;ちなみに開発にあたってGoランタイムを調べていた時の資料も&lt;code&gt;#gocon&lt;/code&gt;ハッシュタグで放流したところ，こちらも好評でしたので改めて置いておきます．&lt;/p&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;4046d92f81c545ab99e5b974c874d4e0&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;h2 id=&#34;発表を終えて&#34;&gt;発表を終えて&lt;/h2&gt;

&lt;p&gt;GoConでの登壇は今回で3回目となりました．ここ数年，自分のキャリアや興味範囲が広がっていく中でも，Go言語はずっと相棒として付き合ってくれる言語でしたし，Go言語を中心に色々な付き合いができていると感じています．
そしてその契機となったGoConと，これを継続して開催してくれている運営の方々に本当に感謝いたします．&lt;/p&gt;

&lt;p&gt;主催するFukuoka.goでも微力ながらコミュニティの活発化に繋がるよう引き続き&amp;rdquo;&lt;a href=&#34;https://press.forkwell.com/entry/2018/10/01/community_lovers&#34;&gt;楽しみながら&lt;/a&gt;&amp;ldquo;やっていきたいと思います．&lt;/p&gt;

&lt;p&gt;次は海外カンファレンスで登壇するぞう．&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;ホテル到着。移動で朝早かったので懇親会途中までとさせていただきました。お誘いありがとうございます。色々な話が聞けて楽しかったです！ カンファレンスも濃い話から体系的な整理がなされたものまであり来れて良かったです。自分の登壇内容も反応いただけて嬉しい限り。次は福岡版どうですか &lt;a href=&#34;https://twitter.com/hashtag/gocon?src=hash&amp;amp;ref_src=twsrc%5Etfw&#34;&gt;#gocon&lt;/a&gt;&lt;/p&gt;&amp;mdash; モノクロメガネ研究員 (@monochromegane) &lt;a href=&#34;https://twitter.com/monochromegane/status/1066697776912691200?ref_src=twsrc%5Etfw&#34;&gt;2018年11月25日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;blockquote class=&#34;twitter-tweet&#34; data-lang=&#34;ja&#34;&gt;&lt;p lang=&#34;ja&#34; dir=&#34;ltr&#34;&gt;GoConお疲れ様でした！いわたプロと知り合えたので何か一緒にやりたいなと思ってマス．Fukuoka.goはいつも10名ほどが発表してまして，例えば岡山のコミュニティの皆さんへ中継もしくは双方向の合同トーク大会とか一回どうでしょうか？ お気軽にご検討いただければ &lt;a href=&#34;https://twitter.com/qt_luigi?ref_src=twsrc%5Etfw&#34;&gt;@qt_luigi&lt;/a&gt;&lt;/p&gt;&amp;mdash; モノクロメガネ研究員 (@monochromegane) &lt;a href=&#34;https://twitter.com/monochromegane/status/1067258144995201024?ref_src=twsrc%5Etfw&#34;&gt;2018年11月27日&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src=&#34;https://platform.twitter.com/widgets.js&#34; charset=&#34;utf-8&#34;&gt;&lt;/script&gt;&lt;/p&gt;

&lt;h2 id=&#34;gopherくん&#34;&gt;Gopherくん&lt;/h2&gt;

&lt;p&gt;今回で登壇特典のGopherくん全色コンプリート！！&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://blog.monochromegane.com/images/2018/11/gophers.jpg&#34; alt=&#34;gophers&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;過去の発表&#34;&gt;過去の発表&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.monochromegane.com/blog/2014/06/08/go-conference-2014-spring/&#34;&gt;Go Conference 2014 spring で発表してきた&lt;/a&gt; - &lt;a href=&#34;https://speakerdeck.com/monochromegane/pt-and-goroutines&#34;&gt;発表資料: pt &amp;amp; Goroutine&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.monochromegane.com/blog/2015/06/23/go-conference-2015-summer/&#34;&gt;Go Conference 2015 summer で発表してきた&lt;/a&gt; - &lt;a href=&#34;https://speakerdeck.com/monochromegane/generative-programming-in-go&#34;&gt;発表資料: Generative Programming in Go&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kaburaya: CPU負荷に応じて継続的に上限値を最適化する動的セマフォ</title>
      <link>https://blog.monochromegane.com/blog/2018/11/25/wsa_3_kaburaya/</link>
      <pubDate>Sun, 25 Nov 2018 01:28:54 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2018/11/25/wsa_3_kaburaya/</guid>
      <description>

&lt;p&gt;このエントリは、&lt;a href=&#34;https://websystemarchitecture.hatenablog.jp/entry/2018/10/09/231937&#34;&gt;第三回 Web System Architecture 研究会 (WSA研)&lt;/a&gt;の予稿です。&lt;/p&gt;

&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;

&lt;p&gt;マルチコア時代において，単一のマシンで処理性能を最大化するため処理の並行化が行われる．
ノンブロッキングな処理方式の採用によってCPUを効率的に使用する場合には最適な並行数はCPUコア数と等しくなる．
しかしノンブロッキングを実現するランタイム実装の限界から，もしくはノンブロッキングを採用していない場合のような，全体的もしくは部分的にブロッキングが発生する状況においては，最適な並行数の決定は依然として開発者の経験と地道なチューニングに依存している．
このような最適な並行数を求める例としてnginx, unicornのworker_processes，Sidekiqのconcurrency，Goroutineの起動数などが挙げられる．
これらは、実行される処理の負荷や特性がアプリケーションごとに異なるため実行される処理の特性とランタイムやスケジューリングの特性を考慮したチューニングが必要になる．
このような複雑な系に対する普遍的なチューニング手法の発見は困難であることから，これらをブラックボックスとして扱い汎用的に調整できる手法が求められる．&lt;/p&gt;

&lt;p&gt;三宅らは&lt;a href=&#34;https://www.ipsj.or.jp/event/fit/fit2018/FIT2018_program_web/data/html/abstract/CL-002.html&#34;&gt;仮想サーバの予測的オートスケーリング&lt;/a&gt;において，アプリケーションの処理内容ではなく運用経験から得られたサーバ単位のスループットを指標として，これを予測するモデルによってサーバ台数調整機能を実現した．
また，&lt;a href=&#34;https://blog.mirakui.com/entry/2013/02/20/003401&#34;&gt;「全自動パラメータチューニングさん」&lt;/a&gt;ではメトリクスを一点に絞りスループットが最大化する値を探索的に求める．
これらの手法は指標を限定しても充分な成果が得られることを示した．一方でその求め方は予測的または探索的であり，Webサーバープロセスのように比較的長期稼働する場合に適用可能である．
しかしながらCLIのような短期稼働かつ性能が求められるようなプロセスにおいては予測や探索は利用できない．
これらの利用用途に対応するため，指標の限定に加え，反応的かつ誤差が少なく指標へ追従する手法が必要である．&lt;/p&gt;

&lt;p&gt;本研究では，処理やランタイムの特性に依存せずに，マシンの負荷に応じて反応的かつ継続的に，並行数を最適化する手法を検討する．
まず，最適な並行数を求めるために，最適化の手法としてフィードバック制御を用いる．指標にはノンブロッキングな処理方式がCPUを効率的に利用することに着目し，CPU使用率を採用する．
次に，並行数の制御にはセマフォを採用することで提案手法に汎用性を持たせる．
本報告では，ノンブロッキングな処理方式をランタイムとして採用するGo言語において，CPU負荷に応じて継続的に上限値を最適化する動的セマフォを実現するライブラリを開発し，これを評価する．&lt;/p&gt;

&lt;h1 id=&#34;実装&#34;&gt;実装&lt;/h1&gt;

&lt;p&gt;フィードバック制御を用いてGoroutineの起動数を動的に調整する手法を実装するためには，ある時点で最適なGoroutineの起動数をフィードバック制御によって決定する仕組みと，その起動数を制約としてGoroutineの起動数を制御する仕組みが必要となる．
このような並行処理の起動数を制御する仕組みには一般的にセマフォが利用される．Go言語ではセマフォとしてバッファ付きチャンネルを用いるのが定石となっている．
そこで本研究では，最適なセマフォの値をフィードバック制御によって動的に変更可能な仕組みを構築した．なおこの実装はOSSの&lt;a href=&#34;https://github.com/monochromegane/kaburaya&#34;&gt;kaburaya&lt;/a&gt;として公開している．&lt;/p&gt;

&lt;h2 id=&#34;制御器&#34;&gt;制御器&lt;/h2&gt;

&lt;p&gt;本研究では，ある時点で最適なGoroutineの起動数をフィードバック制御によって決定する仕組みを制御器と呼ぶ．
今回，制御器の設計についてはGoroutine起動数が制御可能な入力となる．これによって対象のスループットを最大化するのが目的である．しかしながら実行される処理の負荷や特性が異なっても共通に採用できる固定値のスループット値は事前に求めることはできないため別の指標を用いる必要がある．
本研究ではいくつかの制御器の評価を通して効果的な制御器を求める．
以降，Go言語ランタイムがI/Oブロッキングな処理についてもGoroutineの切り替えにより、その負荷をCPU側に移動させることから，CPU負荷が安定になることが一つの上限とみなせると仮定していくつかの制御器を設計する．&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;初期値からワーカー数を変えないFixController (比較用)&lt;/li&gt;
&lt;li&gt;CPU使用率100%を目標値とし，不足した場合は workerを1ずつ増加させる SimpleController&lt;/li&gt;
&lt;li&gt;CPU使用率100%を目標とし，目標との差分のK倍を加える PController(比例制御)&lt;/li&gt;
&lt;li&gt;3.のCPU使用率の目標値を90%としたもの&lt;/li&gt;
&lt;li&gt;直近3観測点の平均を目標値として3観測ごとにPControllerの目標値を変化させるDynamicController&lt;/li&gt;
&lt;li&gt;一定期間のCPU使用率の標準偏差をとってそれが一定の値以下だったら安定したとみなして，workerを減らしていくStabilityController&lt;/li&gt;
&lt;li&gt;CPU使用率ではなくてCPU使用率の変化率を元に制御するRateController&lt;/li&gt;
&lt;li&gt;5.のDynamicControllerを元に定期ではなく大きな変動ごとに目標値を見直す方式&lt;/li&gt;
&lt;li&gt;8.のDynamicControllerを元に定常時の不要なworkerを削減する方式&lt;/li&gt;
&lt;li&gt;9.のDynamicControllerを元に変動の精度と速度を向上させるために積分微分制御を導入する方式&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;セマフォ&#34;&gt;セマフォ&lt;/h2&gt;

&lt;p&gt;本研究では，制御器によって決定された起動数を制約としてGoroutineの起動数を制御する仕組みをセマフォと呼ぶ．
今回のセマフォの要件としてはセマフォの上限値が動的に変更可能であること，そして通常のセマフォと同様にP操作において値が負になる場合に実行がブロックされる．またこれらの値の変更がアトミックに行われる必要がある．&lt;/p&gt;

&lt;p&gt;これらはGo言語では二つのチャンネルを組み合わせることで実現可能である．すなわち，それぞれのチャンネルからの入力と出力でセマフォの値を更新し，必要に応じて内部でチャンネルへの操作の有効無効を切り替えることで結果的に利用者側に対するブロック処理を実現する．&lt;/p&gt;

&lt;h1 id=&#34;評価&#34;&gt;評価&lt;/h1&gt;

&lt;p&gt;本研究では，設計した制御器の出力する起動数が最適であることを検証する．ここで最適であるとは，処理対象のタスク全体を，最低限の，のべ起動数で，最短の時間で処理できる起動数を指す．
評価には，汎用性と再現可能性を高めるため，以下の機能を持つシミュレーターを用いる．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;シミュレータは実時間ではなく，単位時間をステップとみなす&lt;/li&gt;
&lt;li&gt;JobはWorkloadを持ち，ステップごとのCPU利用率を定義する&lt;/li&gt;
&lt;li&gt;Workloadが0のステップはブロッキング処理を表現する&lt;/li&gt;
&lt;li&gt;シミュレータはステップごとに任意の数のジョブを投入する&lt;/li&gt;
&lt;li&gt;シミュレータはステップごとに起動可能なワーカー数を制御器から取得する&lt;/li&gt;
&lt;li&gt;ワーカーはシミュレータで利用可能なCPU利用率までジョブの該当ステップのWorkloadを消費する&lt;/li&gt;
&lt;li&gt;消費できなかったWorkloadは次回のステップに回される&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Workloadが0のステップはCPU資源を消費しないため無条件にステップを進める&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;現状はスイッチングコストがシミュレータに反映できていない．&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;JobにはCPUビジーとなる処理，多くのシステムコールが発生する処理，ネットワークのような長期間のブロッキングが発生する処理などを再現したものを投入する．&lt;/p&gt;

&lt;p&gt;設計した制御器に対する主な評価結果は以下のとおり&lt;/p&gt;

&lt;h2 id=&#34;シミュレーション1&#34;&gt;シミュレーション1&lt;/h2&gt;

&lt;p&gt;初期値からワーカー数を変えないFixControllerによって固定値での最適なワーカー数を求めた．今回のシミュレーションではworker:7 ぐらいが最適と考えられる．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/48418118-d4bc7a80-e797-11e8-8ec1-7eb3456aedc5.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;シミュレーション2&#34;&gt;シミュレーション2&lt;/h2&gt;

&lt;p&gt;CPU使用率100%を目標値とし，不足した場合はworkerを1ずつ増加させるSimpleControllerでは，ジョブが多く投入される初期段階においてワーカー数の増加が追いつかないことからジョブ全体の処理がシミュレーション1と比較して長くなってしまっている．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/48418271-3250c700-e798-11e8-884b-0b7ba7be65ff.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;シミュレーション4&#34;&gt;シミュレーション4&lt;/h2&gt;

&lt;p&gt;CPU上限を目標値とした場合に制御器の出力が負にならないため，ワーカー数を削減することができない．そこでCPU使用率90%を目標とした．CPU上限に達した場合に不要なワーカー数を削減する一方で，目標値が固定のため，ジョブが完了し，CPU使用率が低下した場合にも反応してしまった．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/48418723-57920500-e799-11e8-8cf8-4a06837bfb1e.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;シミュレーション5&#34;&gt;シミュレーション5&lt;/h2&gt;

&lt;p&gt;目標値が固定であることからジョブ完了後にワーカー数を増加し続けてしまう問題に対応するためCPU使用率の目標値自体を変動させることとする．
本シミュレーションでは，CPU使用率が均衡する時点をワーカー数の上限であると仮定し，直近3観測点の平均を目標値として3観測ごとに制御器の目標値を変化させるDynamicControllerを実装評価した．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/48453796-39a7bd00-e7f8-11e8-9d00-5332f3a94450.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;シミュレーション9&#34;&gt;シミュレーション9&lt;/h2&gt;

&lt;p&gt;CPU使用率やジョブ実行状況にできるだけ速く追従するため，一定間隔ごとに目標値を見直すのではなく，CPU使用率の変動があった時点で目標値を変更する．
大きな増減を契機に調整していく仕組みになったことで，CPU安定時に積極的にワーカーを削減することができるようになった&lt;/p&gt;

&lt;p&gt;以下では目標値の変動を赤でプロットしている．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/48612283-e9815400-e9cb-11e8-884a-955a73006986.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;シミュレーション11&#34;&gt;シミュレーション11&lt;/h2&gt;

&lt;p&gt;頻繁に変更される目標値に高速かつ誤差が少なく適応していくため古典的制御手法であるPID制御を導入した．
調整の結果，本シミュレーションではPID制御のゲインとしてKp: 0.1, Ki: 0.5, Kd: 0.5が有効であった．&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/48614179-ff454800-e9d0-11e8-8c39-ad66450984f8.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://user-images.githubusercontent.com/1845486/48614371-6ebb3780-e9d1-11e8-84f3-8a73dc4670e3.png&#34; alt=&#34;result&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;その他のシミュレーション&#34;&gt;その他のシミュレーション&lt;/h2&gt;

&lt;p&gt;検討段階の各シミュレーション結果については&lt;a href=&#34;https://gist.github.com/monochromegane/5e9fc94371a9b2385eedd38d98341e6b#gistcomment-2758500&#34;&gt;こちら以降のコメント欄&lt;/a&gt;を参照のこと．
制御器の実装の番号とシミュレーション番号が同じにしている．&lt;/p&gt;

&lt;p&gt;また，実環境で同様のジョブを用いた評価結果について今回は間に合わず未評価である．&lt;/p&gt;

&lt;h1 id=&#34;まとめ&#34;&gt;まとめ&lt;/h1&gt;

&lt;p&gt;本研究では，処理やランタイムの特性に依存せずに，マシンの負荷に応じて反応的かつ継続的に，並行数を最適化する手法として，CPU負荷に応じて継続的に上限値を最適化する動的セマフォを提案した．
また，シミュレーション環境においてではあるが，ノンブロッキングな処理方式を前提とする場合に有効なCPU使用率の目標値を負荷情報に応じて変動させる制御器として設計することができた．
本方式はCPU使用率とセマフォというランタイムや実装に依存しない方式を採用しているため，並行数を求めなければならない様々な場面に適用可能であると考える．
今後の課題として，実環境での評価としてGo言語のGoroutineの起動数に対する評価が必要である．
また，制御器のパラメタ設計も課題として挙げられるが，フィードバック制御という歴史ある分野の蓄積を有効的に活用することで解決したい．&lt;/p&gt;

&lt;h1 id=&#34;発表スライド&#34;&gt;発表スライド&lt;/h1&gt;

&lt;script async class=&#34;speakerdeck-embed&#34; data-id=&#34;b5541b4887f14681ab89e2bd97f13bdd&#34; data-ratio=&#34;1.77777777777778&#34; src=&#34;//speakerdeck.com/assets/embed.js&#34;&gt;&lt;/script&gt;

&lt;h1 id=&#34;発表を終えて&#34;&gt;発表を終えて&lt;/h1&gt;

&lt;p&gt;第三回のWSA研も様々な観点からの提案と活発な議論が交わされる有意義な場であったと思う．
特にrrreeeyyyさんの&lt;a href=&#34;https://speakerdeck.com/rrreeeyyy/a-survey-of-anomaly-detection-methodologies-for-web-system&#34;&gt;A survey of anomaly detection methodologies for web system&lt;/a&gt;は業務で得た知識をサーベイ論文と組み合わせて再体系化していく非常に興味深い試みで，サービス運用者が参考にしていくべき取り組みだと思えた．
自分自身の研究発表では，個人的な開発時の課題であるGoroutine起動数のチューニングという課題から，研究を意識して問いを抽象化することで，実装に囚われない多角的な解決策を講じることができた点が良かったと思う．質疑では本手法が活きる場面を整理できていなかったことに気づけたことでもう一段先に進めた．
自身のアイディアや実装など狭い範囲から視点を広げるのは難しいことではあるが，こうして研究会を契機に継続的に訓練していくことで少しづつでも前に進んでいると思えるのはとても嬉しい．&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>理性の人</title>
      <link>https://blog.monochromegane.com/blog/2018/08/16/reason/</link>
      <pubDate>Thu, 16 Aug 2018 18:04:00 +0900</pubDate>
      
      <guid>https://blog.monochromegane.com/blog/2018/08/16/reason/</guid>
      <description>&lt;p&gt;思えばこの一年半は自分の感情に振り回された期間だった．
エンジニアとして新しい道が見えながらも，そこに近づけない不甲斐なさと焦り．
自己肯定感が著しく下がったために価値基準がだんだんと外部へ移り，余計に道を見失う．
局所的には努力しているけれども，不安解消や短期的な承認に囚われて殻にこもりがちになる．
愚痴や相談で一時的に心は軽くなれどもいつのまにか焦りが高まる．&lt;/p&gt;

&lt;p&gt;いい加減，自分との向き合い方について考えなければならない時期だと思った．&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;幸いにもここ最近，何人かの自分の尊敬する人とまとまった時間話す機会があり，自分との考え方の違いなどを意識して比較してみた．
元から，皆一様に論理的で理路整然と自他の意見の要点や本質を掴んだ議論ができる能力の面で見習いたいと感じていたのだが，
最も自分と違っていたのは，客観性をもって自分がなすべきことを検討し続け，そこに向けて邁進している点だと思えた．&lt;/p&gt;

&lt;p&gt;すなわち，彼らは理性的であった．
理性とは，手元の辞書によると「感情に動かされたりしないで，論理的に考えをまとめたり物事を判断したりする頭の働き」とある．&lt;/p&gt;

&lt;p&gt;自分も感情に振り回されないようになれば，先に進めるのかと思いつつも，思考から感情を分離することはとても難しいことではないかと思えた．
なぜなら自分は極度の負けず嫌いである．自分にも他人にも負けたくないというのが心根にある．勝っていたり承認されている状態というのは素直に嬉しいし，この動機付けが今まで自分を成長させてきたとさえ思っている．
しかしながら，この主観的で感情的な動機は上手くいくうちは良いが，失敗すると簡単に歪んでしまうというのもまた事実である．
誰かに勝つため，負けないため，舐められないため，価値を認めてもらうため．往往にしてなすべきことではないものを目指し始める．さらには引け目があるから，それらを貫き通すことも難しくなる．&lt;/p&gt;

&lt;p&gt;ただ，このようなことを悶々と考えるうち，自分の中で感情的である状態と理性的である状態というのを区別し現状を俯瞰できるようになってきた．
ここで，理性的な人は，感情を抑え込むのではなく，感情とうまく付き合い，感情に動かされないための方法論をそれぞれ持っているのではないかと考えた．
自分の場合，承認欲求は強く自己と結びついてしまっていてこれを無視することはできない．であれば二つの状態があることを認識し，これを行き来するための方法論を見つけることで理性的に振る舞えるようになるのではないか．&lt;/p&gt;

&lt;p&gt;理性の人でありたい．&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;理性の人は，感情を抑え込むのではなく感情に動かされないための方法論を持つ．&lt;/li&gt;
&lt;li&gt;理性の人は，論理的になすべきことを定める．&lt;/li&gt;
&lt;li&gt;理性の人は，なすべきことを解決するため，己を高める．&lt;/li&gt;
&lt;li&gt;理性の人は，なすべきことを解決するため，周りと協力する．&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;何も感情を無くそうというのではない．自分の性質のため視野が狭くなりがちなことを認めて，目的を客観的に定めたのち，楽しい手段を見つけたい．行動方針における優先順位を明確にしただけである．
結果的に相対的な価値観の世界からも脱却し，より大きなことを成せるのではないかと思う．
もちろん，理性の人になるためには多くの努力が必要であり，今後も継続して努力していく．技術力も思考力に対してもやるべきことはたくさんある．ただ，局所的であろうが今までの努力も無駄ではない．うまく活かして一気に花開きたい．&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
