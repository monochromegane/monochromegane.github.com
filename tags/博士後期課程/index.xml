<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>博士後期課程 on THINKING MEGANE</title><link>https://blog.monochromegane.com/tags/%E5%8D%9A%E5%A3%AB%E5%BE%8C%E6%9C%9F%E8%AA%B2%E7%A8%8B/</link><description>Recent content in 博士後期課程 on THINKING MEGANE</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 30 Dec 2023 10:23:08 +0900</lastBuildDate><atom:link href="/tags/%E5%8D%9A%E5%A3%AB%E5%BE%8C%E6%9C%9F%E8%AA%B2%E7%A8%8B/" rel="self" type="application/rss+xml"/><item><title>社会人大学院生の七転び八起き国際会議奮闘記</title><link>https://blog.monochromegane.com/blog/2023/12/30/international-conference-struggles/</link><pubDate>Sat, 30 Dec 2023 10:23:08 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2023/12/30/international-conference-struggles/</guid><description>&lt;p>2023年10月に初めてのアカデミックな国際会議での発表を終えました。
社会人博士課程に進学後、2021年5月の初投稿から丸2年、7回目の挑戦にしてようやくの採択ということで、自慢できるものではないのですが、同様に博士課程において日々挑戦している方々に何かの参考になればと思い、まとめておきます。&lt;/p>
&lt;h1 id="略歴と背景">略歴と背景&lt;/h1>
&lt;p>2017年から&lt;a href="https://rand.pepabo.com/">ペパボ研究所&lt;/a>で研究開発職に従事しています。
情報システムの自律適応等の研究に取り組み、&lt;a href="https://blog.monochromegane.com/blog/2020/09/21/isee-kyushu-u/">2020年10月に社会人博士課程に進学&lt;/a>しました。
博士課程では、多様かつ継続的に変化する環境に適応する実用的な情報システムの実現に向けて、多腕バンディット方策を用いる機構の研究を進めています。&lt;/p>
&lt;p>修士を飛ばした進学であったこともあり、進学時の実績としては&lt;a href="https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/">国内ジャーナル論文1本&lt;/a>のみでしたので、博士号取得に向けてはジャーナル論文をもう1本と、水準を満たす国際会議での採択1本を目指しての挑戦となりました。&lt;/p>
&lt;h1 id="年表">年表&lt;/h1>
&lt;p>以下に挑戦した国際会議とその結果について時系列にまとめました。&lt;/p>
&lt;h2 id="recsys2021-reject">RecSys2021 (Reject)&lt;/h2>
&lt;p>2021/05投稿。
提案手法において変化する環境への適応能力を向上させるべく進学後に試行錯誤した結果をまとめたものを投稿。&lt;/p>
&lt;p>2021/07不採択通知。
Review結果は5点中、1点4点2点2点2点と散々でした。
総評としてはアイディアやアプローチの萌芽は理解できるが、それらを納得させるような位置付けや妥当性の説明が不十分であるというもの。
この時点では、国際会議に向けての&lt;a href="https://blog.monochromegane.com/blog/2021/05/15/survey-method/">集中的サーベイ&lt;/a>や、初めての英語論文を書き上げるのに精一杯で、論文としてまだ議論の土台に立てていなかったと思います。&lt;/p>
&lt;h2 id="wsdm2022-reject">WSDM2022 (Reject)&lt;/h2>
&lt;p>2021/08投稿。
前回のRecSys2021の指摘事項を踏まえ、記述を見直して投稿。
当初は前回投稿に対するレビュアーからの指摘事項を個別に反映しただけでしたが、指導教官より、研究の位置付けが明確になるよう全体を通した見直しはどうですかとアドバイスをいただき、導入や関連研究を中心に大幅にリライトして投稿。&lt;/p>
&lt;p>2021/10不採択通知。
Review結果は、Weak rejectが3名、Rejectが1名でまだまだ採択には遠かったです。
それでも、総評には、サーベイの充実度や記述の了解性に対する前向きなコメントが多く、前進が感じられました。
なお、分野のexpertからは、提案の新規性や理論的な裏付け、もう一歩踏み込んだ評価の必要性などが指摘されています。&lt;/p>
&lt;h2 id="sac2022-rs-track-reject">SAC2022 RS Track (Reject)&lt;/h2>
&lt;p>2021/10投稿。
前回のWSDM2022の指摘のうち、提案手法を維持したまま対応できる部分を記述面で更新して投稿。&lt;/p>
&lt;p>2021/12不採択通知。
Review結果は、スコアが明記されていないもののReject寄りのコメントが2名、Accept寄りのコメントが1名でした。
採択に多少は近づいたように感じられるものの、総評としては前回とほぼ同様であり、次の提案方式の検討も進んでいたことから、この方式での国際会議への挑戦はここで一旦終えています。&lt;/p>
&lt;p>なお、この方式については、国内の論文誌に投稿し、無事採択されました（2本目の国内ジャーナル論文の実績）。
その査読においても新規性・有用性に関しての議論は行われ、採録条件に応える中で、これらを向上させることができたと思います。&lt;/p>
&lt;h2 id="cikm2022-reject">CIKM2022 (Reject)&lt;/h2>
&lt;p>2022/05投稿。
提案手法において変化する環境への適応能力とオンライン性能を両立させるための方式を検討したものを投稿。
先んじて国内研究会で途中経過をまとめる機会があったこと、前年の執筆経験が蓄積されていることもあり、同様に新規書き下ろしであったRecSys2021の時よりも短い期間で投稿できました。&lt;/p>
&lt;p>2022/08不採択通知。
Review結果は、Weak rejectが1名、Weak acceptが2名で、メタの判断によっては採択されていたかもしれず、惜しいと感じました。
総評は、研究の位置付けやアプローチの妥当性、記述の了解性に対しては一定の水準を満たすものの、手法の有効性を示すための評価方法の改善を求める指摘が多くありました。
前年と比べて手法自体の新規性の観点では認められつつあるなと感じるものの、その有用性を示すための工夫をどうするべきか考えあぐねていた時期だったと思います。&lt;/p>
&lt;h2 id="aamas2023-reject">AAMAS2023 (Reject)&lt;/h2>
&lt;p>2022/10投稿。
前回のCIKM2022の通知を待つ間に、提案手法に関連するサーベイが進んだこともあり、位置付けの補強を兼ねて、それらを盛り込み、イントロダクションと関連研究を中心にリライトして投稿。&lt;/p>
&lt;p>2023/01不採択通知。
Review結果は、Weak paperが1名、Decent paperが2名。
総評としては、やや厳し目で、了解性や位置付けに関する指摘が再発してしまいました。
おそらく追加的なサーベイを自身で消化しきれておらず、結果的に解決したい課題に対して不要に広い議論となってしまったのではないかと考えています。
また、前回の有用性をどう示すかという指摘についても、具体的な解決策を検討できないまま、記述で頑張ろうとしてしまったのも不明瞭になった遠因かもしれません。&lt;/p>
&lt;p>この時期は、なかなか国際会議に採択されないため、博論執筆に向けた実績を満たせないことに対する焦りが募っていきました。&lt;/p>
&lt;h2 id="pakdd2023-reject">PAKDD2023 (Reject)&lt;/h2>
&lt;p>2022/12投稿。
AAMAS2023への投稿と並行して、提案手法のもう一つの要素技術についてコンセプト的な実装と評価を進めていたものを投稿。&lt;/p>
&lt;p>2023/02不採択通知。
Review結果は、Weak rejectが2名、Weak acceptが2名でした。
総評は、課題と提案の位置付けや妥当性は納得できるものの、提案の新規性に関する疑問があるとのことで、課題に対する提案手法の検討の甘さが見透かされたように思えます。&lt;/p>
&lt;h2 id="smc2023-accept">SMC2023 (Accept!)&lt;/h2>
&lt;p>2023/04投稿。
研究としてはAAMAS2023の手法とPAKDD2023の手法が二つ並行している状態でしたが、まずは提案として完成しているAAMAS2023の手法を着地させるべく投稿。
一度、PAKDD2023の研究で離れたことが功を奏したのか、改めて関連文献を読み込む機会を通して知識の再整理が進み、提案手法の課題設定と採用するアプローチにおいて無理なく接続できるような定式化と説明ができたと喜んだ記憶があります。
また、執筆中に最新のサーベイで類似手法が見つかって焦る場面もありましたが、提案手法との差異を検討する中で結果的に提案の新規性の主張が明確にできたのでよかったです。&lt;/p>
&lt;p>2023/06採択通知。
Review結果は、スコアが明記されていないもののAccept寄りのコメントが3名、Reject寄りのコメントが1名でした。
総評では、研究や提案の位置付け、記述の明快さなどについて前向きなコメントがあり、新規性の多寡についての議論も若干ありました。
一方で、有用性や評価に関する不足のコメントがほぼ見られなかったのは興味深かったです。
これは定式化を進め、課題設定や解決する部分についての曖昧性が減少したことで、最小限の記述で過不足ない評価内容について、査読者と認識を揃えることができたためではないかと考えています。
この論文の執筆を通して、改めて、査読者のコメントを局所的に解釈するのではなく、その疑問が発生する根本について対局的にみて解決していくことの重要性を感じました。
これは2度目のWSDM2022への投稿時に指導教官からのアドバイスそのものであり、ようやく自分のものとすることができた時だったのかなと思えます。&lt;/p>
&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>国際会議への長い挑戦を通して、研究を世界的な基準で議論できる水準まで押し上げていくのは一朝一夕にできるものではないのだなあと感じました。
自分の場合は、自身の研究の発展はもちろんのこと、研究を推し進めていく力を高めたいと考え、博士後期課程へ挑戦したこともあり、研究自体と研究力を同時に前進させる必要があり、特に時間がかかってしまっているのだろうと思います。
すぐ成果が出るものではないと頭では分かっているつもりでしたが、やはり2年間全く結果が出なかったというのは心理的な負担が大きかったです。
特に、研究開発員として、事業への貢献も求められる中、不採択による論文執筆期間の延長は、各種施策のスケジュールにも影響するため、とても心苦しい思いをしました。&lt;/p>
&lt;p>そのような中でも、最初の国際会議の採択に漕ぎ着けることができたのは、ひとえに指導教官、研究所の仲間、そして会社の皆様の支援のおかげだと考えています。
本当にありがとうございます。&lt;/p>
&lt;p>最後に、自分にとって研究は「&lt;a href="https://blog.monochromegane.com/blog/2017/12/31/2017/">自分の思い描く世界に至るための過程&lt;/a>」であり、そのためには問題に向き合い続けることが大切だと考えています。
問題に向き合い続けるには、行き詰まらないよう多面的に見ることが重要です。
とは言え、博士課程の進学前は、多面的にあれこれ手を出すことはできていたものの、どこかでやりきれなかったり発散してしまっていたように思えます。
しかし、博士課程の進学後は、指導教官からの指導の中で、絶対に止まらない方法、収束させる方法というのを体得できているように感じます。
それは例えば、「難しいものと認識した上でそれに挑戦する喜び」であったり「ダメだった場合は改善してただ次に行くだけ」であったり、「自分で決めて悔いのないように進む」こと、そして「結果に対して本質的な面白さを見出して言語化し、これまでの取り組みと有機的に関連づけていくこと」などです。
これらはつまり、研究という最短ルートはない道程において、同じ道を回ることなく、常に何かしらの前進という成果を得るための能力です。
現在は、2回目の国際会議に向けてPAKDD2023に挑戦した時の手法を一層発展させたものを投稿中です。
この論文の取り組みは、国際会議の実績を得た後に更に取り組んだもので、継続的な研究が常態となったことを示すものなのかなと思っています。&lt;/p>
&lt;p>来年はおそらく博論に着手できる状態ですので、4年目に突入してしまいましたが博士号を確実に取得できるよう精一杯頑張ります。
そして、このように時間をかけて体得してきた研究と研究力の、支えてくれた皆様への還元を始めていきたいです。&lt;/p></description></item><item><title>カーネルリッジ回帰 入門</title><link>https://blog.monochromegane.com/blog/2022/09/11/kernel-ridge-regression/</link><pubDate>Sun, 11 Sep 2022 12:00:00 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2022/09/11/kernel-ridge-regression/</guid><description>&lt;p>基底関数を用いた線形回帰モデルのように入力に非線形な変換を施してモデルの表現力の向上を図る手法では、以下の2つの問題が発生する。&lt;/p>
&lt;ol>
&lt;li>特徴ベクトルの次元数の増加に伴う計算量の増加&lt;/li>
&lt;li>予測に有用な基底関数の選定&lt;/li>
&lt;/ol>
&lt;p>カーネルリッジ回帰は、カーネル関数を用いて上記の課題を解決する。
このエントリは、このカーネルリッジ回帰を最初に学んだ際の内容を自分なりにまとめたものである。&lt;/p>
&lt;p>以下では、はじめに、記法の整理を兼ねて基本的な線形回帰モデルを説明する。
次に、カーネル法を用いた線形回帰であるカーネルリッジ回帰の説明を通して上記の課題の解決アプローチを学ぶ。
最後に、カーネル法における計算量の課題を解決するためのアプローチである、Random Fourier Featuresも紹介する。&lt;/p>
&lt;h2 id="1-線形回帰モデル">1. 線形回帰モデル&lt;/h2>
&lt;p>線形回帰モデルの問題設定と解法について述べる。
いま、$N$個の入力$X=(\boldsymbol{x}_1,\ldots,\boldsymbol{x}_N)^{\top} \in \mathbb{R}^{N \times D}$と出力$\boldsymbol{y}=(y_1,\ldots,y_N)^{\top} \in \mathbb{R}^{N}$が与えられている。
このとき、$y$は$\boldsymbol{x}$を入力とした線形回帰モデル$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$の出力として得られると仮定する。
ここで、$\boldsymbol{\phi}(\boldsymbol{x}) = (\phi_1(\boldsymbol{x}),\ldots,\phi_F(\boldsymbol{x}))^{\top} \in \mathbb{R}^{F}$は$F$個の基底関数$\phi: \mathbb{R}^{D} \rightarrow \mathbb{R}$からなる特徴ベクトル、$\boldsymbol{w} \in \mathbb{R}^{F}$はこれに対応する係数ベクトルである。
このとき、この係数ベクトル$\boldsymbol{w}$を推定することが本問題の目標である。&lt;/p>
&lt;p>推定には最小二乗法を用いる。
なお、実用上は汎化性能の考慮から正則化を施すことが多いと思われるので、これを適用した&lt;strong>リッジ回帰&lt;/strong>を行う。
すなわち、$\Phi = (\boldsymbol{\phi}(\boldsymbol{x}_1),\ldots,\boldsymbol{\phi}(\boldsymbol{x}_N))^{\top} \in \mathbb{R}^{N \times F}$としたとき、学習データに対する誤差の二乗和（に正則化項を加えたもの）$E(\boldsymbol{w}) = \| \Phi \boldsymbol{w} - \boldsymbol{y} \|^2 + \lambda \| \boldsymbol{w} \|^2$を最小化する$\boldsymbol{w}$を求める。&lt;/p>
&lt;p>このために、まず$E(\boldsymbol{w})$を次のように整理する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
E(\boldsymbol{w}) &amp;amp;= (\Phi \boldsymbol{w} - \boldsymbol{y})^{\top}(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w} \\
&amp;amp;= ((\Phi \boldsymbol{w})^{\top} - \boldsymbol{y}^{\top})(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&amp;amp;= ( \boldsymbol{w}^{\top}\Phi^{\top} - \boldsymbol{y}^{\top})(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&amp;amp;= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} - \boldsymbol{y}^{\top}\Phi\boldsymbol{w} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&amp;amp;= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&amp;amp;= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - 2\boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}.
\label{eq:ew}
\end{split}
\end{align}&lt;/p>
&lt;p>整理には、行列の定理$(AB)^{\top}=B^{\top}A^{\top}$と、スカラーは転置しても値が同じであることを利用した（$\boldsymbol{y}^{\top}\Phi\boldsymbol{w} = (\boldsymbol{y}^{\top}\Phi\boldsymbol{w})^{\top} = \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y}$）。&lt;/p>
&lt;p>次に、$E(\boldsymbol{w})$を最小化する$\boldsymbol{w}$を求めるために$\boldsymbol{w}$について偏微分して0とおく。&lt;/p>
&lt;p>\begin{align}
\frac{\partial E(\boldsymbol{w})}{\partial \boldsymbol{w}} &amp;amp;= 2\Phi^{\top}\Phi\boldsymbol{w} -2\Phi^{\top}\boldsymbol{y} + 0 + 2\lambda\boldsymbol{w} = 0.
\end{align}&lt;/p>
&lt;p>偏微分には、対称行列（$A=\Phi^{\top}\Phi=A^{\top}$）に対する二次形式（$\boldsymbol{w}^{\top}A\boldsymbol{w}$）の$\boldsymbol{w}$の偏微分が$(A + A^{\top})\boldsymbol{w} = 2A\boldsymbol{w}$であること、$\boldsymbol{w}^{\top}\boldsymbol{a}, \boldsymbol{a}=\Phi^{\top}\boldsymbol{y}$としたときの$\boldsymbol{w}$の偏微分が$\boldsymbol{a}$であることを利用した。&lt;/p>
&lt;p>最後に、$\boldsymbol{w}$について整理する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
2\Phi^{\top}\Phi\boldsymbol{w} -2\Phi^{\top}\boldsymbol{y} + 2\lambda\boldsymbol{w} &amp;amp;= 0\\
2\Phi^{\top}\Phi\boldsymbol{w} + 2\lambda\boldsymbol{w} &amp;amp;= 2\Phi^{\top}\boldsymbol{y}\\
\Phi^{\top}\Phi\boldsymbol{w} + \lambda\boldsymbol{w} &amp;amp;= \Phi^{\top}\boldsymbol{y}\\
(\Phi^{\top}\Phi + \lambda I_F)\boldsymbol{w} &amp;amp;= \Phi^{\top}\boldsymbol{y}\\
\boldsymbol{w} &amp;amp;= (\Phi^{\top}\Phi + \lambda I_F)^{-1}\Phi^{\top}\boldsymbol{y}.
\label{eq:w}
\end{split}
\end{align}&lt;/p>
&lt;p>ここでは、行列のサイズが$F \times F$の単位行列を$I_{F}$と表記した。&lt;/p>
&lt;p>新しい入力$\boldsymbol{x}$に対する出力は推定した$\boldsymbol{w}$を用いて、$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$と予測できる。&lt;/p>
&lt;h2 id="2-カーネル法による線形回帰モデル">2. カーネル法による線形回帰モデル&lt;/h2>
&lt;p>上述の線形回帰モデルを利用する際には、基底関数を増やし多くの特徴量の候補から予測に有用なものに重み付けできれば良いと考えられることから、特徴ベクトルの次元数$F$を増やすアプローチが検討される。
しかしながら、この場合、パラメータ$\boldsymbol{w}$の推定や出力$\hat{y}$の予測に必要な計算量も同時に増加してしまう。
そこで、カーネル法による線形回帰モデルでは、パラメータの次元数を$N$に抑えるようなアプローチをとる。
これは、学習データ数$N$が特徴ベクトルの次元数$F$よりも少ない場合に有効である。
また、線形回帰モデルにはもう一つ、予測に対して有用な基底関数の種類や数が明らかではないという課題がある。
これに対しカーネル法による線形回帰モデルは、カーネル関数を導入することで、基底関数の選定を省略することができる。&lt;/p>
&lt;p>以下、上述のリッジ回帰にカーネル法を適用した&lt;strong>カーネルリッジ回帰&lt;/strong>を説明する。&lt;/p>
&lt;h3 id="21-線形回帰モデルの双対表現">2.1. 線形回帰モデルの双対表現&lt;/h3>
&lt;p>パラメータの次元数を$N$に抑えるため、$F$次元の$\boldsymbol{w}$についての線形モデル$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$を、$N$個の学習データ$\Phi$に対応するパラメータ$\boldsymbol{\alpha} \in \mathbb{R}^{N}$で表現することを考える。&lt;/p>
&lt;p>そのために、式\eqref{eq:w}の3行目以降の変形を以下のように進める。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\Phi^{\top}\Phi\boldsymbol{w} + \lambda\boldsymbol{w} &amp;amp;= \Phi^{\top}\boldsymbol{y}\\
\lambda\boldsymbol{w} &amp;amp;= - \Phi^{\top}\Phi\boldsymbol{w} + \Phi^{\top}\boldsymbol{y}\\
\lambda\boldsymbol{w} &amp;amp;= - \Phi^{\top}(\Phi\boldsymbol{w} - \boldsymbol{y})\\
\boldsymbol{w} &amp;amp;= - \frac{1}{\lambda} \Phi^{\top}(\Phi\boldsymbol{w} - \boldsymbol{y}).
\end{split}
\end{align}&lt;/p>
&lt;p>ここで$\boldsymbol{\alpha} = - \frac{1}{\lambda}(\Phi\boldsymbol{w} - \boldsymbol{y})$とすると、$\boldsymbol{w} = \Phi^{\top}\boldsymbol{\alpha}$となる。
これにより、元の線形回帰モデルを$\hat{y} = (\Phi^{\top}\boldsymbol{\alpha})^{\top}\phi(\boldsymbol{x})$と、（右辺にも$\boldsymbol{w}$は含まれるが）見かけ上は$\boldsymbol{w}$を含まない形で表現できるようになった（&lt;strong>双対表現&lt;/strong>）。&lt;/p>
&lt;p>この双対表現の線形回帰モデルについて、最小二乗法を用いて$\boldsymbol{\alpha}$を推定する。
これは上述の$E(\boldsymbol{w})$を双対表現の線形回帰モデルで記述し、解を求めることと同等である。&lt;/p>
&lt;p>このために、式\eqref{eq:ew}に$\boldsymbol{w} = \Phi^{\top}\boldsymbol{\alpha}$を代入し$\boldsymbol{\alpha}$についての関数$E(\boldsymbol{\alpha})$とした上で、以下のように整理する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
E(\boldsymbol{\alpha}) &amp;amp;= (\Phi^{\top}\boldsymbol{\alpha})^{\top}\Phi^{\top}\Phi(\Phi^{\top}\boldsymbol{\alpha}) - 2(\Phi^{\top}\boldsymbol{\alpha})^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda(\Phi^{\top}\boldsymbol{\alpha})^{\top}(\Phi^{\top}\boldsymbol{\alpha})\\
&amp;amp;= \boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\Phi\Phi^{\top}\boldsymbol{\alpha} - 2\boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\boldsymbol{\alpha}\\
&amp;amp;= \boldsymbol{\alpha}^{\top}KK\boldsymbol{\alpha} - 2\boldsymbol{\alpha}^{\top}K\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{\alpha}^{\top}K\boldsymbol{\alpha}.
\end{split}
\end{align}&lt;/p>
&lt;p>なお、
\[
K = \Phi\Phi^{\top} =
\begin{pmatrix}
\boldsymbol{\phi}(\boldsymbol{x}_1)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_1) &amp;amp; \ldots &amp;amp; \boldsymbol{\phi}(\boldsymbol{x}_1)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_N) \\
\vdots &amp;amp; \ddots &amp;amp; \vdots \\
\boldsymbol{\phi}(\boldsymbol{x}_N)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_1) &amp;amp; \ldots &amp;amp; \boldsymbol{\phi}(\boldsymbol{x}_N)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_N)
\end{pmatrix} =
\begin{pmatrix}
k(\boldsymbol{x}_1,\boldsymbol{x}_1) &amp;amp; \ldots &amp;amp; k(\boldsymbol{x}_1,\boldsymbol{x}_N) \\
\vdots &amp;amp; \ddots &amp;amp; \vdots \\
k(\boldsymbol{x}_N,\boldsymbol{x}_1) &amp;amp; \ldots &amp;amp; k(\boldsymbol{x}_N,\boldsymbol{x}_N)
\end{pmatrix}
\in \mathbb{R}^{N \times N}
\]
とした。
ここで、入力$\boldsymbol{p}$と$\boldsymbol{q}$を$\boldsymbol{\phi}$によって特徴ベクトルに変換し内積をとる操作である$k(\boldsymbol{p},\boldsymbol{q})$をカーネル関数と呼ぶ。
また、学習データ$X$に対する全ての組み合わせである$K$をグラム行列と呼ぶ。&lt;/p>
&lt;p>次に、$E(\boldsymbol{\alpha})$を最小化する$\boldsymbol{\alpha}$を求めるために$\boldsymbol{\alpha}$について偏微分して0とおく。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\frac{\partial E(\boldsymbol{\alpha})}{\partial \boldsymbol{\alpha}} &amp;amp;= 2KK\boldsymbol{\alpha} - 2K\boldsymbol{y} + 0 + 2\lambda K\boldsymbol{\alpha}= 0.
\end{split}
\end{align}&lt;/p>
&lt;p>最後に、$\boldsymbol{\alpha}$について整理する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
2KK\boldsymbol{\alpha} - 2K\boldsymbol{y} + 2\lambda K\boldsymbol{\alpha} &amp;amp;= 0\\
KK\boldsymbol{\alpha} - K\boldsymbol{y} + \lambda K\boldsymbol{\alpha} &amp;amp;= 0\\
KK\boldsymbol{\alpha} + \lambda K\boldsymbol{\alpha} &amp;amp;= K\boldsymbol{y}\\
K\boldsymbol{\alpha} + \lambda \boldsymbol{\alpha} &amp;amp;= \boldsymbol{y}\\
(K + \lambda I_N)\boldsymbol{\alpha} &amp;amp;= \boldsymbol{y}\\
\boldsymbol{\alpha} &amp;amp;= (K + \lambda I_N)^{-1}\boldsymbol{y}.
\label{eq:alpha}
\end{split}
\end{align}&lt;/p>
&lt;p>新しい入力$\boldsymbol{x}$に対する出力は、推定した$\boldsymbol{\alpha}$を用いて以下のように予測できる。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\hat{y} &amp;amp;= (\Phi^{\top}\boldsymbol{\alpha})^{\top}\boldsymbol{\phi}(\boldsymbol{x}) \\
&amp;amp;= \boldsymbol{\alpha}^{\top}\Phi\boldsymbol{\phi}(\boldsymbol{x}) \\
&amp;amp;= \sum_{n=1}^{N} \alpha_n \boldsymbol{\phi}(\boldsymbol{x}_n)^{\top}\boldsymbol{\phi}(\boldsymbol{x}) \\
&amp;amp;= \sum_{n=1}^{N} \alpha_n k(\boldsymbol{x}_n, \boldsymbol{x}).
\label{eq:yk}
\end{split}
\end{align}&lt;/p>
&lt;p>すなわち、$F$次元の$\boldsymbol{w}$を用いず、学習データ数$N$を次元とする$\boldsymbol{\alpha}$で予測できるようになった。&lt;/p>
&lt;h3 id="22-カーネル関数の構成">2.2. カーネル関数の構成&lt;/h3>
&lt;p>ここまで、$F$個の基底関数$\phi$を用いた特徴ベクトルとしての$\boldsymbol{\phi}$同士の内積として、カーネル関数をボトムアップ的に定義した。&lt;/p>
&lt;p>この場合、どのような基底関数を選定するかという線形回帰モデルのもう一つの課題が残る。
カーネル法を用いた線形回帰モデルでは、発想を逆転させ、カーネル関数をトップダウン的に先に直接定義することで、その内部の基底関数を陽に知らずにすませるというアプローチをとる。&lt;/p>
&lt;p>ただし、この場合は定義したカーネル関数が正定値性を満たす必要がある。
すなわち、任意の$M$個の点から計算される、定義したカーネル関数による$M \times M$のグラム行列$K$の2次形式が常に非負（任意の$\boldsymbol{\mu} \in \mathbb{R}^M$に対して$\boldsymbol{\mu}^{\top}K\boldsymbol{\mu} \geq 0$）となる必要がある。&lt;/p>
&lt;p>このような条件を満たすカーネル関数を直接定義できたならば、これはなんらかの特徴ベクトル同士の内積と考えることができる。
ありがたいことに、式\eqref{eq:yk}は基底関数$\phi$を使わず全てカーネル関数$k$で表現できているため、直接定義したカーネル関数があれば、基底関数の選定が不要となる（&lt;strong>カーネルトリック&lt;/strong>）。&lt;/p>
&lt;p>幸い、さまざまなカーネル関数が考案されているため、まずはそれらのカーネル関数を利用することとなる。
以下、多項式カーネルとガウスカーネルを紹介する。&lt;/p>
&lt;h4 id="多項式カーネル">多項式カーネル&lt;/h4>
&lt;p>多項式カーネルは$k(\boldsymbol{p}, \boldsymbol{q}) = (\boldsymbol{p}^{\top}\boldsymbol{q} + c)^{m}$の形をとるカーネル関数である。
上述のカーネルリッジ回帰を利用するにあたってはどのような特徴ベクトルが利用されているのかを陽に知る必要はないが、例えば$m=2,\boldsymbol{p},\boldsymbol{q} \in \mathbb{R}^2$であれば次のような特徴ベクトルが対応することが分かる。&lt;/p>
&lt;p>対応する特徴ベクトルを調べるために、多項式カーネルを特徴ベクトルの内積$\boldsymbol{\phi}(\boldsymbol{p})^{\top}\boldsymbol{\phi}(\boldsymbol{q})$に変形する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
k(\boldsymbol{p}, \boldsymbol{q}) &amp;amp;= (\boldsymbol{p}^{\top}\boldsymbol{q} + c)^{2} \\
&amp;amp;= ((p_1, p_2)^{\top}(q_1, q_2) + c)^2 \\
&amp;amp;= (p_1q_1 + p_2q_2 + c)^2 \\
&amp;amp;= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + 2p_1q_1p_2q_2 + 2cp_2q_2 + 2cp_1q_1\\
&amp;amp;= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + 2p_1p_2q_1q_2 + 2cp_2q_2 + 2cp_1q_1\\
&amp;amp;= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + \sqrt{2}p_1p_2\sqrt{2}q_1q_2 + \sqrt{2c}p_2\sqrt{2c}q_2 + \sqrt{2c}p_1\sqrt{2c}q_1\\
&amp;amp;= (p_1^2, p_2^2, c, \sqrt{2}p_1p_2, \sqrt{2c}p_2, \sqrt{2c}p_1)^{\top}(q_1^2, q_2^2, c, \sqrt{2}q_1q_2, \sqrt{2c}q_2, \sqrt{2c}q_1).
\end{split}
\end{align}&lt;/p>
&lt;p>つまり、今回の例では、特徴ベクトルが$\boldsymbol{\phi}(\boldsymbol{x}) = (x_1^2, x_2^2, c, \sqrt{2}x_1x_2, \sqrt{2c}x_2, \sqrt{2c}x_1)$として扱われていたことが分かる。
言葉を返せば、多項式カーネルを用いると、このような変換を行う6つの基底関数を明示的に選定して地道に内積を取った場合と同様の結果を得られる。&lt;/p>
&lt;p>なお、多項式カーネルの$m=1,c=0$の場合、これを線形カーネルと呼び、この時の特徴ベクトルは入力と等しい（$\boldsymbol{\phi}(\boldsymbol{x}) = \boldsymbol{x}$）。&lt;/p>
&lt;h4 id="ガウスカーネル">ガウスカーネル&lt;/h4>
&lt;p>ガウスカーネルは$k(\boldsymbol{p}, \boldsymbol{q}) = \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2})$の形をとるカーネル関数である。&lt;/p>
&lt;p>以下では、ガウスカーネルにどのような特徴ベクトルが対応するかを確認する。
まず、ガウスカーネルを以下のように展開、変形する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
k(\boldsymbol{p}, \boldsymbol{q}) &amp;amp;= \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{(\boldsymbol{p} - \boldsymbol{q})^{\top}(\boldsymbol{p} - \boldsymbol{q})}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{(\boldsymbol{p}^{\top} - \boldsymbol{q}^{\top})(\boldsymbol{p} - \boldsymbol{q})}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - \boldsymbol{q}^{\top}\boldsymbol{p} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - (\boldsymbol{q}^{\top}\boldsymbol{p})^{\top} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - \boldsymbol{p}^{\top}\boldsymbol{q} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - 2\boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2} + \frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2} + \frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2})\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2})\exp(\frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \rho\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2})\psi \\
&amp;amp;= \rho\psi\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2}).
\end{split}
\end{align}&lt;/p>
&lt;p>最後の2行では以降の展開を見やすくするため、$\rho=\exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2}), \psi=\exp(\frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2})$とおいた。&lt;/p>
&lt;p>次に、$e^x$のマクローリン展開の公式（$e^x = \sum_{i=0}^{\infty} \frac{x^i}{i!} = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + \cdots$）を使い、特徴ベクトルの内積$\boldsymbol{\phi}(\boldsymbol{p})^{\top}\boldsymbol{\phi}(\boldsymbol{q})$に変形する。&lt;/p>
&lt;p>簡単のため$\sigma=1$とすると、次のような式が得られる。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\rho\psi\exp(\boldsymbol{p}^{\top}\boldsymbol{q}) &amp;amp;= \rho\psi \left(1 + (\boldsymbol{p}^{\top}\boldsymbol{q})^1 + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^2}{2} + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^3}{6} + \ldots \right).
\end{split}
\end{align}&lt;/p>
&lt;p>これは$c=0$の多項式カーネルを次数$m$を増やしながら無限回足したものである。
よって例えば、$\boldsymbol{p},\boldsymbol{q} \in \mathbb{R}^2$では、次のような&lt;strong>無限次元&lt;/strong>の特徴ベクトルが対応することが分かる。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\rho\psi\exp(\boldsymbol{p}^{\top}\boldsymbol{q}) &amp;amp;= \rho\psi \left(1 + (\boldsymbol{p}^{\top}\boldsymbol{q})^1 + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^2}{2} + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^3}{6} + \ldots \right) \\
&amp;amp;= \rho\psi \left(1 + (p_1q_1 + p_2q_2) + \frac{p_1^2q_1^2 + p_2^2q_2^2 + \sqrt{2}p_1p_2\sqrt{2}q_1q_2}{2} + \frac{p_1^3q_1^3 + p_2^3q_2^3 + \sqrt{3}p_1^2p_2\sqrt{3}q_1^2q_2 + \sqrt{3}p_1p_2^2\sqrt{3}q_1q_2^2}{6} + \ldots \right) \\
&amp;amp;= \rho\left(1, p_1, p_2, \frac{p_1^2}{\sqrt{2}}, \frac{p_2^2}{\sqrt{2}}, \frac{\sqrt{2}p_1p_2}{\sqrt{2}}, \frac{p_1^3}{\sqrt{6}}, \frac{p_2^3}{\sqrt{6}}, \frac{\sqrt{3}p_1^2p_2}{\sqrt{6}}, \frac{\sqrt{3}p_1p_2^2}{\sqrt{6}}, \ldots \right)^{\top}\psi\left(1, q_1, q_2, \frac{q_1^2}{\sqrt{2}}, \frac{q_2^2}{\sqrt{2}}, \frac{\sqrt{2}q_1q_2}{\sqrt{2}}, \frac{q_1^3}{\sqrt{6}}, \frac{q_2^3}{\sqrt{6}}, \frac{\sqrt{3}q_1^2q_2}{\sqrt{6}}, \frac{\sqrt{3}q_1q_2^2}{\sqrt{6}},\ldots \right) \\
&amp;amp;= \rho\left(1, p_1, p_2, \frac{p_1^2}{\sqrt{2}}, \frac{p_2^2}{\sqrt{2}}, p_1p_2, \frac{p_1^3}{\sqrt{6}}, \frac{p_2^3}{\sqrt{6}}, \frac{p_1^2p_2}{\sqrt{2}}, \frac{p_1p_2^2}{\sqrt{2}}, \ldots \right)^{\top}\psi\left(1, q_1, q_2, \frac{q_1^2}{\sqrt{2}}, \frac{q_2^2}{\sqrt{2}}, q_1q_2, \frac{q_1^3}{\sqrt{6}}, \frac{q_2^3}{\sqrt{6}}, \frac{q_1^2q_2}{\sqrt{2}}, \frac{q_1q_2^2}{\sqrt{2}},\ldots \right).
\end{split}
\end{align}&lt;/p>
&lt;p>ガウスカーネルでは、このような無限個の基底関数を用意して内積を地道に計算した結果が、$k(\boldsymbol{p}, \boldsymbol{q}) = \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2})$のみの計算から得られるとも考えられる。&lt;/p>
&lt;h2 id="3-random-fourier-features乱択化フーリエ特徴">3. Random Fourier Features（乱択化フーリエ特徴）&lt;/h2>
&lt;p>カーネルリッジ回帰による入力$\boldsymbol{x}$に対する予測は式\eqref{eq:alpha}\eqref{eq:yk}より、$\hat{y} = \sum_{n=1}^{N} \alpha_n k(\boldsymbol{x}_n, \boldsymbol{x}), \boldsymbol{\alpha} = (K + \lambda I_N)^{-1}\boldsymbol{y}$となるのであった。
カーネルリッジ回帰では、$F \gg N$となるような学習データ数$N$に対し十分大きい$F$個の基底関数を用いる場合に、双対表現によってパラメータ数を$N$に抑えつつ、カーネル関数の導入によって$F$次元の特徴ベクトルの直接的な算出を回避できた。&lt;/p>
&lt;p>しかしながら、カーネルリッジ回帰は、学習データ数$N$に対して計算量が指数的に増加してしまう課題がある。
これは、グラム行列$K$のサイズが$N \times N$であるため、$\boldsymbol{\alpha}$の計算にあたって、必要なカーネル関数の計算が$N^2$のオーダーで増加することからも分かる。
また、逆行列の計算も$K$のサイズに応じて計算量が増加する。
加えて、$\hat{y}$の計算にあたっても、新しい入力$\boldsymbol{x}$に対して$N$回のカーネル関数の計算が都度必要となってしまう。&lt;/p>
&lt;p>&lt;strong>Random Fourier Features&lt;/strong>は、ある確率分布からのサンプリング結果でカーネル関数とグラム行列を近似することで、上述の課題を解決する、高速化のための手法である。&lt;/p>
&lt;p>この手法では、$\mathbb{R}^D$上のカーネル関数$k(\boldsymbol{p},\boldsymbol{q})$が$\boldsymbol{p}$と$\boldsymbol{q}$の差の形（$k(\boldsymbol{p}-\boldsymbol{q})$）で表せるとき、このカーネル関数が、ある確率密度関数$p(\boldsymbol{\omega})$のフーリエ変換で表せることを利用する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
k(\boldsymbol{p},\boldsymbol{q}) &amp;amp;= k(\boldsymbol{p} - \boldsymbol{q})\\
&amp;amp;= \int_{\mathbb{R}^{D}} p(\boldsymbol{\omega}) \exp(i \boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))d\boldsymbol{\omega} \\
&amp;amp;= \mathbb{E}_{\boldsymbol{\omega}}[\exp(i \boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))] \\
&amp;amp;= \mathbb{E}_{\boldsymbol{\omega}}[\cos(\boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))] \\
&amp;amp;= \mathbb{E}_{\boldsymbol{\omega},b}[\sqrt{2}\cos(\boldsymbol{\omega}^{\top}\boldsymbol{p} + b) \cdot \sqrt{2}\cos(\boldsymbol{\omega}^{\top}\boldsymbol{q} + b)] \\
&amp;amp;\approx \frac{1}{R} \sum_{r=1}^{R} \sqrt{2}\cos(\boldsymbol{\omega}_r^{\top}\boldsymbol{p} + b_r) \cdot \sqrt{2}\cos(\boldsymbol{\omega}_r^{\top}\boldsymbol{q} + b_r).
\end{split}
\end{align}&lt;/p>
&lt;p>ここで、$\boldsymbol{\omega} \sim p(\boldsymbol{\omega}), b \sim \text{Uniform}(0, 2\pi)$である。
なお、$p(\boldsymbol{\omega})$は利用するカーネル関数によって異なるが、ガウスカーネルの場合、$\boldsymbol{w} = (w_d)^{1 \leq d \leq D}, w_d \sim \mathcal{N}(0, \sigma^2)$となる。&lt;/p>
&lt;p>最後の行は、この確率分布の期待値（$=$カーネル関数の結果）を$R$個のサンプリング結果の平均で近似することを示している。&lt;/p>
&lt;p>すなわち、各サンプルから求めた結果を、$z_r(\boldsymbol{x}) = \cos(\boldsymbol{\omega}_{r}^{\top}\boldsymbol{x} + b_r)$、$R$個の$z_r$を$\boldsymbol{z}(\boldsymbol{x}) = \sqrt{\frac{2}{R}}(z_1(\boldsymbol{x}),\ldots,z_R(\boldsymbol{x}))^{\top}$とおくと、カーネル関数$k$の近似$\hat{k}$が$\hat{k}(\boldsymbol{p},\boldsymbol{q}) = \boldsymbol{z}(\boldsymbol{p})^{\top}\boldsymbol{z}(\boldsymbol{q})$のように得られる。
また、学習データ$X$に対する$\boldsymbol{z}$の集合を$Z = (\boldsymbol{z}(\boldsymbol{x}_1)^{\top}, \ldots, \boldsymbol{z}(\boldsymbol{x}_N)^{\top})^{\top} \in \mathbb{R}^{N \times R}$とすると、$\hat{K} = ZZ^{\top}$の操作によって$N \times N$行列の各要素がカーネル関数$k$の近似$\hat{k}(\boldsymbol{x}_i, \boldsymbol{x}_j) = \boldsymbol{z}(\boldsymbol{x}_i)^{\top}\boldsymbol{z}(\boldsymbol{x}_j)$となるグラム行列$K$の近似$\hat{K}$を得られる。&lt;/p>
&lt;p>よって、これらの近似を用いたカーネルリッジ回帰のパラメータ$\boldsymbol{\alpha}$の近似$\hat{\boldsymbol{\alpha}}$は、$\hat{\boldsymbol{\alpha}} = (\hat{K} + \lambda I_{N})^{-1}\boldsymbol{y}$となる。
ただし、この手法では、$\hat{K} = ZZ^{\top}$であることを利用して、計算量を学習データ数$N$ではなくサンプリング数$R$のオーダーに変えることができる。
そのため、$R \ll N$であるならば、非常に効率よく予測が可能となる。&lt;/p>
&lt;p>以下に、$\hat{K}$や$\hat{\boldsymbol{\alpha}}$を消去していく経過と合わせて、この手法における予測式を示す。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\hat{y} &amp;amp;= \sum_{n=1}^{N} \hat{\alpha}_n \hat{k}(\boldsymbol{x}_n, \boldsymbol{x}) \\
&amp;amp;= \sum_{n=1}^{N} \hat{\alpha}_n \hat{k}(\boldsymbol{x}, \boldsymbol{x}_n) \\
&amp;amp;= \sum_{n=1}^{N} \hat{\alpha}_n \boldsymbol{z}(\boldsymbol{x})^{\top}\boldsymbol{z}(\boldsymbol{x}_n) \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} \sum_{n=1}^{N} \hat{\alpha}_n \boldsymbol{z}(\boldsymbol{x}_n) \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} \hat{\boldsymbol{\alpha}} \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} (\hat{K} + \lambda I_{N})^{-1}\boldsymbol{y} \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} (ZZ^{\top} + \lambda I_{N})^{-1}\boldsymbol{y} \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} (Z^{\top}Z + \lambda I_{R})^{-1}Z^{\top} \boldsymbol{y}.
\end{split}
\end{align}&lt;/p>
&lt;p>よって、$A=(Z^{\top}Z + \lambda I_{R}) \in \mathbb{R}^{R \times R}$、$\boldsymbol{b} = (Z^{\top} \boldsymbol{y}) \in \mathbb{R}^{R}$、$\boldsymbol{\beta} = A^{-1}\boldsymbol{b}$として、$\hat{y} = \boldsymbol{z}(\boldsymbol{x})^{\top} \boldsymbol{\beta}$と予測できる。
$Z$は$N \times R$であるものの、逆行列のサイズは$R \times R$となること、$\hat{y}$の計算も、新しい入力$\boldsymbol{x}$に対して$R$回の計算で済む$\boldsymbol{z}(\boldsymbol{x})$のみで良いことから、計算量が抑えられることが分かる。&lt;/p>
&lt;p>なお、最後の行では逆行列の補題（$P(I_N + QP)^{-1} = (I_R +PQ)^{-1}P, P \in \mathbb{R}^{R \times N}, Q \in \mathbb{R}^{N \times R}$）を用いた。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;h3 id="線形回帰モデル">線形回帰モデル&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://manabitimes.jp/math/1128">正規方程式の導出と計算例&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kspub.co.jp/book/detail/5161968.html">スタンフォード　ベクトル・行列からはじめる最適化数学&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kspub.co.jp/book/detail/1529267.html">ガウス過程と機械学習&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="カーネル法による線形回帰モデル">カーネル法による線形回帰モデル&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/wsuzume/items/09a59036c8944fd563ff">線形な手法とカーネル法（回帰分析）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://qiita.com/kilometer/items/66e6116cc661019ead59">カーネルトリック&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.slideshare.net/KeisukeSugawara/slide0629">PRML第６章「カーネル法」&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.slideshare.net/hagino_3000/prml-61-17081123">PRML 6.1章 カーネル法と双対表現&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iwanami.co.jp/book/b257891.html">カーネル多変量解析 非線形データ解析の新しい展開&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://towardsdatascience.com/truly-understanding-the-kernel-trick-1aeb11560769">Understanding the Kernel Trick with fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Radial_basis_function_kernel">Radial basis function kernel&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="random-fourier-features">Random Fourier Features&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/githug0906/items/448daec79fac2ffd82a0">乱択化フーリエ特徴を用いたリッジ回帰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kyoritsu-pub.co.jp/book/b10003381.html">機械学習のためのカーネル100問 with Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gregorygundersen.com/blog/2019/12/23/random-fourier-features/">Random Fourier Features&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://proceedings.neurips.cc/paper/2007/hash/013a006f03dbc5392effeb8f18fda755-Abstract.html">Rahimi, Ali, and Benjamin Recht. &amp;ldquo;Random features for large-scale kernel machines.&amp;rdquo; Advances in neural information processing systems 20 (2007).&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>gonum/matパッケージを直感的に操作するMatrix Adapterをつくった</title><link>https://blog.monochromegane.com/blog/2022/07/02/matrix-adapter/</link><pubDate>Sat, 02 Jul 2022 11:59:22 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2022/07/02/matrix-adapter/</guid><description>&lt;p>gonum/matによる行列計算を幾分か直感的に扱える薄いラッパーを作りました。
具体的には、計算結果用に空の行列を予め用意するのではなく、計算結果を戻り値で受け取れるように統一します。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/monochromegane/mat">Matrix Adapter&lt;/a>: Small adapter which provides method signatures that allow intuitive operation with fewer lines of code for gonum/mat.&lt;/li>
&lt;/ul>
&lt;h1 id="背景と課題感">背景と課題感&lt;/h1>
&lt;p>&lt;a href="https://github.com/gonum/gonum/tree/master/mat">Gonumプロジェクトのmatパッケージ&lt;/a>はGo言語での行列計算ライブラリを提供してくれています。
こういった正確さと速度の求められる数値計算の処理には、（趣味は別として）自作ではなく、多くの人に使われ実績のあるライブラリを採用したいことから、このパッケージを利用しています。&lt;/p>
&lt;p>非常に便利に使わせていただいている一方で、自分の場合、スムーズに書けないことがありました。
理由としては、計算結果の受け取り方法に対する一貫性の崩れがあるだろうと考えています。&lt;/p>
&lt;p>matパッケージでは、予め空の行列を用意し、これをレシーバーとして計算対象となる行列を引数で渡します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">Dense&lt;/span>
&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>元の行列が維持されるこの設計は非常にありがたいです。
しかしながら、一部の関数（例えば &lt;code>Dense.T&lt;/code>）は結果が戻り値として得られます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">ct&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>この一貫性の崩れは不変と可変の混在にあるのではないかと考えています。
gonum/matパッケージでは、&lt;a href="https://pkg.go.dev/gonum.org/v1/gonum/mat#hdr-Invariants">引数で渡す行列は計算操作に対して不変&lt;/a>とされています。
これは、関数のパラメータの方が、&lt;code>mat.Matrix&lt;/code>インターフェースであることからも読み取れます。
実際、このインターフェースには、&lt;code>Dims()&lt;/code>, &lt;code>At()&lt;/code>といった参照系かレシーバーを壊さない&lt;code>T()&lt;/code>のみが用意されています。&lt;/p>
&lt;p>一方で、このインターフェースを実装した&lt;code>mat.Dense&lt;/code>などは自身をレシーバーとして内容を変更する操作を認めています。
この差異により、mat.Matrixインターフェースのシグネチャの一つである&lt;code>T()&lt;/code>は戻り値を返すが、Denseの関数ではレシーバーを変更するという振る舞いの違いがあるのではないかと思われました。&lt;/p>
&lt;p>gonum/matパッケージではほとんどの関数が空の行列を予め用意する方式に従っているため、慣れれば問題ない程度ではありますが、久しぶりに使う場合など、多少まごつくことが何度かありました。
個人的に、Go言語で何か書くときは迷わず書きたいという欲求があり、迷わないため一貫性のあるラッパーを作ることとしました。&lt;/p>
&lt;h1 id="matrix-adapter">Matrix Adapter&lt;/h1>
&lt;p>今回は、計算結果を戻り値で受け取れるように統一します。
これにより、利用側からはDenseらも不変であるかのように扱え、一貫性という側面から認知負荷が減ると考えるためです。&lt;/p>
&lt;p>Matrix Adapterを適用した場合、先ほどの例は以下のようになります。
&lt;code>c&lt;/code>がレシーバーではなく、先ほどは引数となっていた&lt;code>a&lt;/code>がレシーバーとなっていることに注意してください。
&lt;code>c&lt;/code>は戻り値として受け取ることになりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="実装と使い方">実装と使い方&lt;/h2>
&lt;p>Adapterの実装は単純明快で、元の構造体を埋め込み（embedding）し、結果を戻り値で返すように関数のシグネチャを変更しました。
変更が不要なものは移譲されます。
いわゆるGoFのデザインパターンにおけるAdapterパターンというやつです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Dense&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">Dense&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Dense&lt;/span>) &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">Matrix&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Dense&lt;/span> {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">dense&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">Dense&lt;/span>
&lt;span style="color:#a6e22e">dense&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">Dense&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Dense&lt;/span>{&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">dense&lt;/span>}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>現状、DenseとVecDenseに対するAdapterを提供しています。
既存と同名の&lt;code>NewDense()&lt;/code>と&lt;code>NewVecDense()&lt;/code>を使って、ラップされたDenseやVecDenseを作成できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;github.com/monochromegane/mat/adapter&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">adapter&lt;/span>.&lt;span style="color:#a6e22e">NewDense&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, []&lt;span style="color:#66d9ef">float64&lt;/span>{&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">3.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>})
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">m&lt;/span>)
&lt;span style="color:#75715e">// ⎡1 2⎤
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ⎣3 4⎦
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、提供されるDenseとVecDenseは&lt;code>fmt.Stringer&lt;/code>インターフェースを実装し、行列の内容を整形して出力するようにしています。&lt;/p>
&lt;p>ここで、少し実践的な例として、リッジ回帰によるパラメータ推定（$\hat{\theta} = (X^{\top}X + \lambda I)^{-1} X^{\top}Y$）を実装し、比較してみます。&lt;/p>
&lt;h3 id="matrix-adapterでの実装">Matrix Adapterでの実装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go"> &lt;span style="color:#a6e22e">X&lt;/span>, &lt;span style="color:#a6e22e">Y&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">syntheticData&lt;/span>(&lt;span style="color:#a6e22e">N&lt;/span>, &lt;span style="color:#a6e22e">theta&lt;/span>) &lt;span style="color:#75715e">// Return adapter.Dense
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#a6e22e">I&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDiagDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, []&lt;span style="color:#66d9ef">float64&lt;/span>{&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>})
&lt;span style="color:#a6e22e">reg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">DenseCopyOf&lt;/span>(&lt;span style="color:#a6e22e">I&lt;/span>).&lt;span style="color:#a6e22e">Scale&lt;/span>(&lt;span style="color:#a6e22e">lambda&lt;/span>)
&lt;span style="color:#a6e22e">XTXinv&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">Transpose&lt;/span>().&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">X&lt;/span>).&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">reg&lt;/span>).&lt;span style="color:#a6e22e">Inverse&lt;/span>()
&lt;span style="color:#a6e22e">XTY&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">Transpose&lt;/span>().&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">Y&lt;/span>)
&lt;span style="color:#a6e22e">estimated&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">XTXinv&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">XTY&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="gonummatでの実装">gonum/matでの実装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go"> &lt;span style="color:#a6e22e">X&lt;/span>, &lt;span style="color:#a6e22e">Y&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">syntheticData&lt;/span>(&lt;span style="color:#a6e22e">N&lt;/span>, &lt;span style="color:#a6e22e">theta&lt;/span>) &lt;span style="color:#75715e">// Return adapter.Dense
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#a6e22e">XTXinv&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">XTXinv&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>(), &lt;span style="color:#a6e22e">X&lt;/span>)
&lt;span style="color:#a6e22e">I&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDiagDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, []&lt;span style="color:#66d9ef">float64&lt;/span>{&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>})
&lt;span style="color:#a6e22e">reg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">DenseCopyOf&lt;/span>(&lt;span style="color:#a6e22e">I&lt;/span>)
&lt;span style="color:#a6e22e">reg&lt;/span>.&lt;span style="color:#a6e22e">Scale&lt;/span>(&lt;span style="color:#a6e22e">lambda&lt;/span>, &lt;span style="color:#a6e22e">reg&lt;/span>)
&lt;span style="color:#a6e22e">XTXinv&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">XTXinv&lt;/span>, &lt;span style="color:#a6e22e">reg&lt;/span>)
&lt;span style="color:#a6e22e">XTXinv&lt;/span>.&lt;span style="color:#a6e22e">Inverse&lt;/span>(&lt;span style="color:#a6e22e">XTXinv&lt;/span>)
&lt;span style="color:#a6e22e">XTY&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">XTY&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>(), &lt;span style="color:#a6e22e">Y&lt;/span>)
&lt;span style="color:#a6e22e">estimated&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">estimated&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">XTXinv&lt;/span>, &lt;span style="color:#a6e22e">XTY&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>この例では、gonum/matでの実装に比べてMatrix Adapterでの実装が、結果用の&lt;code>Dense&lt;/code>の準備が省略できたこと、各関数で受け取る引数が減ったことなどから、幾分か簡潔に記述できているかと思います。&lt;/p>
&lt;p>なお、Adapterでの実装では、Method Chainによる行数の短縮も見てとれます。
これについては、戻り値を返す実装としたことで副次的に得られた、本Adapterの特徴です。
Go言語におけるMethod Chainは、errorを含む多値の戻り値との相性から、積極的に採用されていないと認識しています。
ただ、今回は元のパッケージが各計算においてerrorを返さないものが多く、多値にならない関数が多くできたため、結果としてMethod Chainがつながる場合ができています（&lt;code>Inverse()&lt;/code>などerrorを返すものもあるため全部は繋げません）。
この辺りのエラー処理については、一考の価値があると思いますが、現時点で本Adapterの対象外（従来パッケージを踏襲）としています。&lt;/p>
&lt;h2 id="相互運用性">相互運用性&lt;/h2>
&lt;p>Adapterの提供する関数でも、引数は&lt;code>mat.Matrix&lt;/code>（や&lt;code>mat.Vector&lt;/code>）を使うため、既存のラップしていないものを入力として受け取れます。
また、これらのAdapterは、&lt;code>mat.Dense&lt;/code>（や&lt;code>mat.VecDense&lt;/code>）構造体を埋め込んでいるため、&lt;code>mat.Matrix&lt;/code>（や&lt;code>mat.Vector&lt;/code>）の実装を満たします。
よって、ラップされた&lt;code>adapter.Dense&lt;/code>（や&lt;code>adapter.VecDense&lt;/code>）を既存の関数の入力として渡すことができます。&lt;/p>
&lt;p>また、&lt;code>T()&lt;/code>は&lt;code>mat.Matrix&lt;/code>として維持しなければならない関数であることから、同等の&lt;code>Transpose()&lt;/code>を提供しています。
これにより、転置行列がレシーバーとなるような呼び出しであっても、&lt;code>adapter.Dense&lt;/code>として振る舞うことができるようになり、Matrix Adapterとの親和性が向上します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// X.T().Product(Y) is invalid due to mat.Matrix has no method Product.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">XTY&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">Transpose&lt;/span>().&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">Y&lt;/span>) &lt;span style="color:#75715e">// Valid
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>本エントリでは、gonum/matパッケージを直感的に操作するための&lt;a href="https://github.com/monochromegane/mat">Matrix Adapter&lt;/a>を紹介しました。
本Adapterの作成とエントリ執筆において、「直感的でない」と主観的に感じる理由について、不変と可変の混在に起因するものではないかなと言語化できたのがよかったかなあと思います。&lt;/p>
&lt;p>自分の利用範囲だと、DenseとVecDenseで事足りる場合が多いのですが、必要に応じて対象を増やしていこうかと思います。&lt;/p>
&lt;h1 id="参考">参考&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://po3rin.com/blog/gonum">Go + Gonum を使った行列計算まとめ&lt;/a>
&lt;ul>
&lt;li>関数の直感性を上げるための独自関数や、行列のフォーマットなどを参考にさせていただきました。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/gorgonia/tensor">gorgonia/tensor&lt;/a>
&lt;ul>
&lt;li>gonum/matではないGo言語の行列計算パッケージ。戻り値で結果を受け取れたりerrorも返すので本Adapterの目指すところに近いとは思います。速度含めて検証が必要なのもあり、今回は慣れて使っている方が多いであろうgonum/matをラップする方式を採用しました。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>2022年2月のアイオー</title><link>https://blog.monochromegane.com/diary/20220226-io/</link><pubDate>Sat, 26 Feb 2022 11:53:35 +0900</pubDate><guid>https://blog.monochromegane.com/diary/20220226-io/</guid><description>&lt;p>月ごとのインプットとアウトプットの記録。&lt;/p>
&lt;h2 id="インプット">インプット&lt;/h2>
&lt;h3 id="書籍">書籍&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3sok7MY">未踏の蒼穹&lt;/a>』&lt;/p>
&lt;p>趣味のSFとして。ジェイムズ・Ｐ・ホーガンの長編作品。作者の『星を継ぐもの』ほど惹かれなかったが、十分面白く読むことができた。作者の科学者に対する理想像の実現が『星を継ぐもの』から今作の間にこのように変わったのだなあという観点で裏読みできたのでもう少し間の作品を埋めてみようかな。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3LZAxTL">情報検索と言語処理 (言語と計算)&lt;/a>』&lt;/p>
&lt;p>今月は情報検索関連でまとまったインプットが必要になったので。初版1999年と古いが（今から見ると）技術的な打ち手がまだ少ない時代は、定量的な評価が難しい人の認知モデルも含めた幅広い議論が交わされており、個人的には立ち返る意味があると思っている。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3M11yGd">情報検索アルゴリズム&lt;/a>』&lt;/p>
&lt;p>同じく情報検索関連のインプットとして。初版2002年。ベクトル空間からの近傍探索、アドホックな文字列照会による検索、索引構築を備えた検索などの基本が広く紹介されている。現在では前半の、これらを一貫して評価するための検索モデルや基準などの整理が参考になると思われた。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3BUPj9v">情報検索のためのユーザインタフェース&lt;/a>』&lt;/p>
&lt;p>同上。初版2011年。以前読んだものだが検索の個人化について章が割り当てられていたので目を通した。フィードバックをどう負担なく獲得しかつ有用に活かすかについて各研究が苦労している様が見てとれる。全体的な傾向を活かすところから順次粒度を細かくしていくのが王道だろうか。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/33W6I5e">AIアルゴリズムマーケティング 自動化のための機械学習/経済モデル、ベストプラクティス、アーキテクチャ&lt;/a>』&lt;/p>
&lt;p>同上。初版2018年。主に検索部分に目を通した。各施策に対してビジネス的な目標をおいた上でモデルやアーキテクチャを検討している。検索においては、その目標に沿って主観的にコントロール可能な部分が例示されており参考になった。上述の評価指標と組み合わせることで検索機構に対して求める性能の解像度を上げることができたと思う。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/33RIPLZ">Elasticsearch実践ガイド&lt;/a>』&lt;/p>
&lt;p>同上。初版2018年。施策を具体的な実装に落とし込む際の用語の紐付けのために読んだ。アーキテクチャの全体と基本的な使い方がわかりやすく図解で紹介されており素早く目的を達成できた。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3hgxvMA">Pythonではじめる 情報検索プログラミング&lt;/a>』&lt;/p>
&lt;p>同上。初版2020年。情報検索に関する基本的なアルゴリズムを実際に手を動かしながら体験できる。具体的にどういう結果がえられるのか、アルゴリズムごとの特性の違いは何かなど勘所をつかむ上で良さそう。特にうまく検索できないパターンなどを具体的なイメージを得られるのではないだろうか。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3Ho8OIw">情報検索 :検索エンジンの実装と評価&lt;/a>』&lt;/p>
&lt;p>同上。初版2020年。タイトルの通り検索エンジンを実装し評価するために必要な技術が詳細に解説されている。今回は検索サーバを使う上での観点が必要だったのでパート3の検索とランキング部分を読んだ。検索サーバで提供されていない基準でどういう手法をとれるかという知識のインデックスを増やせたと思う。必要に応じて読み直すつもり。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/35bOoFF">A/Bテスト実践ガイド　真のデータドリブンへ至る信用できる実験とは&lt;/a>』&lt;/p>
&lt;p>同上。初版2021年。情報検索の施策の有用性の評価の参考のため読んだ。A/Bテストの重要性や手法に加え、それを文化として根付かせるためのノウハウが紹介されている。個人的には多腕バンディットで解決できる部分も多いと思っていたが、その背景にある対照実験のための知識は重要だと改めて認識できたという面で参考になった。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3BThXI8">入門 機械学習による異常検知―Rによる実践ガイド&lt;/a>』&lt;/p>
&lt;p>時系列データの変化点検出をやりたくなり、以前も参考にしていた『&lt;a href="https://amzn.to/3BQL132">異常検知と変化検知&lt;/a>』とあわせて読んだ。非常に参考になるが、分布の仮定が今回解きたいものと合わないかもしれないなあというところで引き続き調べている。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3hieMQH">Machine Learning for Data Streams: with Practical Examples in MOA (Adaptive Computation and Machine Learning series) (English Edition)&lt;/a>』&lt;/p>
&lt;p>同じく変化点検出の方式調査で読んでいる。多腕バンディットやフィードバック制御など逐次的に適応していくような仕組みが好きなのだが、そのような仕組みのひとつで一時期調べていたADWINの提案者が執筆に参加しているもの。各方式については簡単な紹介だけなので英語であっても読みやすいが、アルゴリズム等の詳細は論文を読む必要があると思う。自分の興味範囲を整理整頓するのに良いと思い少しづつ読むことにした。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="論文">論文&lt;/h3>
&lt;p>読めていなかった〜。&lt;/p>
&lt;h2 id="アウトプット">アウトプット&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/monochromegane/banditalgorithms">Bandit algorithms&lt;/a>&lt;/p>
&lt;p>研究のシミュレーションで使う比較用の多腕バンディットのアルゴリズムをテスト込みできちんと整備することにした。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>2022年1月のアイオー</title><link>https://blog.monochromegane.com/diary/20220130-io/</link><pubDate>Sun, 30 Jan 2022 19:04:47 +0900</pubDate><guid>https://blog.monochromegane.com/diary/20220130-io/</guid><description>&lt;p>月ごとのインプットとアウトプットの記録。&lt;/p>
&lt;h2 id="インプット">インプット&lt;/h2>
&lt;h3 id="書籍">書籍&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3rerg1O">未来は予測するものではなく創造するものである　――考える自由を取り戻すための〈ＳＦ思考〉&lt;/a>』&lt;/p>
&lt;p>2022年の目標である100倍研究のため、入出力の幅を広げられたらと思い読んだもの。SFプロトタイピング、実例などが紹介されている。自分や研究所として、実際にSFとして仕立てる必要はないと思うが、研究テーマやストーリーの生成に、バックキャスティング、フォアキャスティングの反復を意識的に取り入れることは重要だなと思えた。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3oakVlW">WEB+DB PRESS Vol.126&lt;/a>』&lt;/p>
&lt;p>特集の「Goで作って学ぶ検索エンジン」が気になって読んだ。この特集自体は『&lt;a href="https://amzn.to/3rerRk4">情報検索の基礎&lt;/a>』を思い出しながらふむふむとさっくり読めた。実装もついている点も良かった。せっかくなので他の記事も読んだが、コンテナやプライバシー関連の動向など界隈の新しめの情報が端的にまとまっており継続して読んでおこうと思えた。自身の研究がアルゴリズム寄りになりつつあるが、システムとして導入、評価できるという強みは保っておきたいことだし。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3Ght26m">データサイエンスの無駄遣い 日常の些細な出来事を真面目に分析する&lt;/a>』&lt;/p>
&lt;p>もっと機械学習等をどんどん使っていって普段の選択肢を広げたいなあとは思っているので、アイディアのヒントがないかなと読んだもの。なるほどこういう動機や解決策もあるんだなあと思いつつ、現時点ではあまりヒントにはならなかったかな。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3reDk33">完全独習 ベイズ統計学入門&lt;/a>』&lt;/p>
&lt;p>以前読んだはずだけど、所長が読んだという情報から内容が全然思い出せなかったので再読。今よりベイズ統計がさらにわかってなかった時に読んだのだが、今ならすんなり理解ができるので少しは成長した様子。離散から連続確率になるときに条件付き確率と記述されているのが尤度関数になる部分に納得がいかなかったのだが、研究所で教えてもらって理解がより深まった感じ。ありがたい。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3oa1d9I">ガイダンス 確率統計: 基礎から学び本質の理解へ&lt;/a>』&lt;/p>
&lt;p>確率統計はずっと苦手意識があるので何度目かの再入門として読んだ。証明や練習問題もありしっかりサポートしてくれているので、もう一周すればだいぶ理解が深まりそうだが、目を通したところまで。確率と集合の記号がもっと動いて見えるまで慣れないとダメだなあ。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3gaCz4I">円　劉慈欣短篇集&lt;/a>』&lt;/p>
&lt;p>趣味のSFとして。『三体』の作者の短編集。単純にどの作品も面白かったが、SF思考の後に読んだので、短編ごとになるほどそういう世界観で、その技術体系を導くのか等、いつもより多角的な視点で読めて良かった。個人的には「詩雲」「二〇一八年四月一日」「人生」が印象に残ったのだが共通点を振り返って自分でも意外だった。多様で飽きのこない短編集だった。おすすめ。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3ISWykL">実践 時系列解析 ―統計と機械学習による予測&lt;/a>』&lt;/p>
&lt;p>研究で時系列を扱う機会はとても多いので新しい観点が得られればと思い読んだもの。解析手法だけでなく、前処理や探索的な解析、データ保存手段、時系列データの探し方、解析の実例等幅広く扱っている。個人的には解析手法における分類自体がそもそもありがたいと感じた。ただし個別の説明はあまりわかりやすいものではないと感じたので、知識のインデックスの増強として割り切って読んだ。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="論文">論文&lt;/h3>
&lt;p>バンディット系を2本。ちょっと少ないので来月はこの辺を改善しようと思う。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://arxiv.org/abs/2010.00827">Neural Thompson Sampling&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arxiv.org/abs/1909.09146">Weighted Linear Bandits for Non-Stationary Environments&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="アウトプット">アウトプット&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/monochromegane/banditsflow">BanditsFlow&lt;/a>&lt;/p>
&lt;p>100倍研究の出力側の施策として。研究で扱うシミュレーションに纏わる、開発効率の改善や再現性の確保といったいくつかの課題を解決する。シミュレーションにおける定型化可能なワークフロー、ならびにこれらのパラメータや結果の管理を一元に行えるフレームワークである。Gitとあわせて実験内容とその結果を時系列的にコード管理する予定。来月から玄人実行していく。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="100倍アイオーのために">100倍アイオーのために&lt;/h2>
&lt;p>今月はTwitterを制限して読書量が増えたので良かった。
全然見ないというのも情報収集に支障が出るので、以下のような雑スクリプトを一日一回だけ実行している。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
argv&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">`&lt;/span>seq &lt;span style="color:#ae81ff">1&lt;/span> $#&lt;span style="color:#e6db74">`&lt;/span>
&lt;span style="color:#66d9ef">do&lt;/span>
yesterday&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>date -v-1d &lt;span style="color:#e6db74">&amp;#39;+%Y-%m-%d&amp;#39;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
encoded&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>echo &lt;span style="color:#e6db74">&amp;#34;https://twitter.com/search?q=from:&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>argv[$i-1]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> since:&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>yesterday&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">_00:00:00_JST until:&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>yesterday&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">_23:59:59_JST&amp;amp;src=typed_query&amp;amp;f=live&amp;#34;&lt;/span> | ruby -r uri -ne &lt;span style="color:#e6db74">&amp;#39;print URI.encode $_.chomp&amp;#39;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
open $encoded
&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下のように実行すると、@hogeさんと@fugaさんと@piyoさんの昨日のTweetだけがそれぞれ検索結果のページとして開く。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ ./tw.sh hoge fuga piyo
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Twitterの中毒性は、未読を消化するべく無限に見てしまうことだと思う。
この検索結果のページでは過去にスクロールできないため、やめ時が明確になる点が良い。
今のところはうまくいっていると思う。&lt;/p>
&lt;p>検索クエリは&lt;a href="https://scrapbox.io/june29/">29box&lt;/a>を参考にしました。ありがとうございます。&lt;/p></description></item><item><title>2021</title><link>https://blog.monochromegane.com/blog/2021/12/29/2021/</link><pubDate>Wed, 29 Dec 2021 16:03:57 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2021/12/29/2021/</guid><description>&lt;p>2021年は、自分の研究テーマとひたすら向き合った年となった。
昨年10月より博士後期課程に在学していることもあり、まずは1本国際会議に通すべく、自身の提案手法の改善、評価と従来手法との比較分析を、1年間ひたすら続けていた。
研究の進捗の節目ごとに投稿していた国際会議は、残念ながら3回投稿して全てリジェクトとなってしまったが、これらのフィードバックや方式の改善の結果、論文の質や提案手法の性能はこの1年間で随分上がったのではないかと思う。&lt;/p>
&lt;p>実際に、これらの進捗を議論すべく報告した、国内の2回の研究会では3つの賞を受賞することができ、客観的にも、自分の研究テーマとの向き合ってきた結果が出てきていると思える。
昨年度の受賞は、優秀プレゼンテーション賞という発表の分かりやすさの側面が強かったが、今年は、それに加え、座長や運営委員による選定という、より内容に踏み込んだ評価の上での受賞であり、非常に嬉しかったし、国際会議挑戦を継続するにあたって励みになった。&lt;/p>
&lt;p>来年は引き続き国際会議への挑戦と研究の発展を進めたい。
そのために、結果に一喜一憂せずに淡々と継続することを心がけていく。
また、手法改善の基盤となる数学的な能力向上や先行研究のサーベイは一過性ではなく計画的に長期的に取り組めるような枠組みを作り上げたい。
加えて、来年度は、個人のみの研究の位置付けからもう少し視座を高め、例えば研究所の取り組みと各研究員の研究、会社のサービスやビジョンとの関係性などから、方針や行動を見定め、それらに向かって導いたり知ってもらえるような振る舞いなど、今よりも先を見通し、今よりも大きく影響を与えることも意識していきたい。&lt;/p>
&lt;p>2022年からは、支えてくれる周りの人にも、恩返しだったり良い影響を与えることをできるようになりたいと思う。
来年もよろしくお願いします。&lt;/p>
&lt;h1 id="実績">実績&lt;/h1>
&lt;p>以下、実績を列挙する。&lt;/p>
&lt;h2 id="表彰">表彰&lt;/h2>
&lt;p>2021年は2つの研究会で3つの賞を受賞できた。
聴講者だけでなく運営委員や座長による評価をいただけるような研究を継続的に出せるようになっていることは素直に嬉しい。
また、研究所の共著論文でも2つの賞を受賞しており、研究所全体の盛り上げにも貢献できてよかったと思う。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.sigwi2.org/prev-awardlist">ARG 第17回Webインテリジェンスとインタラクション研究会 優秀研究賞&lt;/a>, 三宅 悠介, 峯 恒憲, 仮想的な探索を用いて文脈や時間の経過による番狂わせにも迅速に追従する多腕バンディット手法, 2021年12月.&lt;/li>
&lt;li>&lt;a href="https://sites.google.com/view/sig-macc/smash/smash21-summer-symposium">SMASH21 Summer Symposium 優秀賞&lt;/a>, 三宅 悠介, 峯 恒憲, Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム, 2021年9月.&lt;/li>
&lt;li>&lt;a href="https://sites.google.com/view/sig-macc/smash/smash21-summer-symposium">SMASH21 Summer Symposium 奨励賞&lt;/a>, 三宅 悠介, 峯 恒憲, Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム, 2021年9月.&lt;/li>
&lt;/ul>
&lt;h2 id="論文">論文&lt;/h2>
&lt;p>招待講演1本、研究報告2本。
実際には国際会議3回投稿、投稿中の国内ジャーナル1本があり、体感的な執筆量は例年と変わらない程度であったと思う。
また、研究報告のラストオーサーを2本、国内査読付き論文と国際会議（ワークショップ）論文でそれぞれ1本づつ共著を務めた。&lt;/p>
&lt;ol>
&lt;li>三宅 悠介, 峯 恒憲, &lt;a href="https://www.sigwi2.org/d_library">仮想的な探索を用いて文脈や時間の経過による番狂わせにも迅速に追従する多腕バンディット手法&lt;/a>, ARG Webインテリジェンスとインタラクション研究会 第17回研究会予稿集, No.17, pp.19-24, Dec 2021. &lt;a href="https://rand.pepabo.com/papers/wi2-17-miyakey.pdf">[論文]&lt;/a> &lt;a href="https://speakerdeck.com/monochromegane/wi2-lkf-bandits">[発表資料]&lt;/a>&lt;/li>
&lt;li>三宅 悠介, 峯 恒憲, &lt;a href="http://id.nii.ac.jp/1001/00212709/">Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム&lt;/a>, 研究報告知能システム（ICS）, Vol.2021-ICS-204, No.9, pp.1-8, Sep 2021. &lt;a href="https://rand.pepabo.com/papers/smash21-miyakey.pdf">[論文]&lt;/a> &lt;a href="https://speakerdeck.com/monochromegane/smash21-synapse">[発表資料]&lt;/a>&lt;/li>
&lt;li>三宅 悠介, 栗林 健太郎, &lt;a href="https://tsys.jp/dicomo/2021/program/program_abst.html#8A-1">(招待講演) なめらかなシステムと運用維持の未来&lt;/a>, マルチメディア，分散，協調とモバイル（DICOMO2021）シンポジウム論文集, 2021, p.1509, Jun-Jul 2021.&lt;a href="https://rand.pepabo.com/papers/dicomo2021-miyakey.pdf">[論文]&lt;/a> &lt;a href="https://speakerdeck.com/monochromegane/dicomo2021-coherently-fittable-system">[発表資料]&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="国内発表">国内発表&lt;/h2>
&lt;p>技術イベント、研究会での発表をそれぞれ1回（学会の研究会、シンポジウムを除く）。
今年はFukuoka.goもWSAも開催が少なかったこともあり、随分控えめになってしまった。
来年はもう少し機会を見つけて登壇していきたい。&lt;/p>
&lt;ol>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/fukoukago17-go-code-embedding">go:embedでExplainable Binaryを作る&lt;/a>, &lt;a href="https://fukuokago.connpass.com/event/202570/">Fukuoka.go#17(オンライン開催)&lt;/a>, 2021年6月.&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/">非定常な多腕バンディット問題において効率的に変化を察知する方式の検討&lt;/a>, &lt;a href="https://wsa.connpass.com/event/207143/">Web System Architecture 研究会 (WSA研) #8&lt;/a>, 2021年6月.&lt;/li>
&lt;/ol>
&lt;h2 id="oss">OSS&lt;/h2>
&lt;p>Fukuoka.go用に書いたツールが1本。
先行研究の実装など随分とコードは書いている気がするので研究とOSSもうまくつないでいきたいところ。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/monochromegane/go-code-embedding">go-code-embedding&lt;/a> A tool to embed Go source code into binary using go:embed.&lt;/li>
&lt;/ul>
&lt;h2 id="コミュニティ活動">コミュニティ活動&lt;/h2>
&lt;p>今年よりこれまでのFukuoka.goに加え、学会系の活動も手伝うようになった。
具体的には研究会の運営委員への就任に伴う運営従事の他、査読、座長、シンポジウムのプログラム委員などを務めた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://fukuokago.connpass.com/event/202570/">Fukuoka.go#17 (オンライン開催)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iot.ipsj.or.jp/">情報処理学会 インターネットと運用技術研究会 運営委員 就任&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iot.ipsj.or.jp/symposium/iots2021/">第14回 インターネットと運用技術シンポジウム（IOTS 2021）プログラム委員&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ブログ">ブログ&lt;/h2>
&lt;p>2本。昨年までに比べるとかなり少なめだが、研究の進め方シリーズとして集中的サーベイは研究所のみんなに紹介するなど役立ったと思う。
このような手探りからやり方に昇華できたものは今後もブログにまとめていきたい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/">非定常な多腕バンディット問題において効率的に変化を察知する方式の検討&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2021/05/15/survey-method/">研究の位置づけを明確にする集中型の論文サーベイ方法&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>非定常な多腕バンディット問題において効率的に変化を察知する方式の検討</title><link>https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/</link><pubDate>Tue, 08 Jun 2021 10:52:04 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/</guid><description>&lt;p>このエントリは、&lt;a href="https://wsa.connpass.com/event/207143/">第8回 Web System Architecture 研究会 (WSA研)&lt;/a>の予稿です。&lt;/p>
&lt;h1 id="非定常な多腕バンディット問題において効率的に変化を察知する方式の検討">非定常な多腕バンディット問題において効率的に変化を察知する方式の検討&lt;/h1>
&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>適応的なシステムの実現には、利用者と情報システムが互いの状態をよく理解するためのコミュニケーションと、それに応じた振る舞いの変更が必要となる。
一方で、そのコミュニケーションから得られる情報や利益の価値を考慮しなければならない環境では、確実な情報に基づく振る舞いを選択しつつ、まだ得られていない情報を引き出すために、価値の低いコミュニケーションを敢行しなければならない。&lt;/p>
&lt;p>これは、多腕バンディット問題として定式化できる。
多腕バンディット問題では、振る舞いの選択肢のことを腕と呼び、ある時点までの情報をもとに有効な腕を選択することを「活用」、腕の可能性を探るために有効ではない腕を選択することを「探索」と呼ぶ。
それぞれの腕はある確率分布に従い報酬を生成する。
中でも、選択肢の相対的な有効性が時間経過とともに変化する問題設定は非定常な多腕バンディット問題と呼ばれ、いくつかの解法が提案されている。&lt;/p>
&lt;p>非定常な多腕バンディット問題に対する解法には、腕の有効性の変化に応じた評価の更新が重要とされてきた。
しかしながら、選択による機会損失の低減を目的とした多腕バンディット問題の設定では、ある時点で有効性の低い選択肢が利用される機会は少なく、腕の有効性の変化を察知する、それ自体がまず難しい。&lt;/p>
&lt;p>本研究では、このような非定常な多腕バンディット問題における変化を素早く察知するにあたり、探索による機会損失を抑制した、効率的な方式を検討する。
なお、多腕バンディット問題の設定は、同時に文脈付きの問題設定に拡張することができるが、課題の本質は同じであること、方式検討の容易性から、本方向では文脈の考慮は行わない。&lt;/p>
&lt;h2 id="非定常な多腕バンディット問題の解法における変化察知の課題">非定常な多腕バンディット問題の解法における、変化察知の課題&lt;/h2>
&lt;p>非定常な多腕バンディット問題への解法では、腕の報酬分布が変化した際に、過去に観測した報酬に捉われずに腕の評価を迅速に更新しなくてはならない。
この問題の解法には大きく4つのアプローチがある。
一つ目は、腕の報酬分布が変化することを前提にして、観測時点からの経過に応じて腕の評価に重み付けをするアプローチである（減衰型）。
二つ目も、同様の前提において、新しく観測した報酬から一定の期間のみの情報で報酬分布を評価する（ウィンドウ型）。
三つ目は、腕の報酬分布の変化を契機として、腕を再評価するものである（変化検出型）。
このアプローチでは、変化検出の手法を用いて腕の報酬の変化を検出し、変化前の観測を取り除くことで、新しく観測された報酬を重視する。
これは変化検出による可変のウィンドウ型とみなすこともできる。
四つ目は、現時点の腕の評価を継続的に推定するものである。
このアプローチでは、腕の状態として状態空間モデルを仮定し、カルマンフィルタや粒子フィルタを推定に用いる。&lt;/p>
&lt;p>これらの全てのアプローチは、変化後の報酬分布から得られる報酬のサンプルを一定数必要とする。
選択による機会損失の低減を目的とした多腕バンディット問題の設定では、ある時点で評価の高い腕を最も多く活用する。
そのため、評価の高い腕が、ある時点で有効性が低くなるようなケースでは、十分な報酬のサンプルを観測することができ、各アプローチは有効に働く。
反対に、評価の低かった腕が、ある時点で有効性が高くなるケースでは、その腕に対する報酬のサンプルを得るまでに時間が掛かり、機会損失の発生に繋がると考えられる。
例えば、ECサイトの推薦アルゴリズムのコールドスタートのような、一定の嗜好情報が蓄積されることでその有効性を増すような選択肢がある場合に、この問題が発生する。&lt;/p>
&lt;p>この問題に直接挑んだ先行研究[1][2]では、いずれもなんらかの非定常な多腕バンディットの解法に従い腕の選択を行うが、一定の割合で、ランダムに腕を選択することで、腕の選択の偏りの解消を試みている。
また、上述のアプローチのうち、報酬の観測数の上限を変化させるような、減衰型、ウィンドウ型、変化検出型でも、間接的に腕の選択の偏りが緩和される。
なぜなら、多くの多腕バンディットの解法では、観測数の少なさを評価の不確かさと捉え、探索を促すからである。&lt;/p>
&lt;p>これらの探索を増やすアプローチは、トレードオフが発生する。
すなわち、相対的な腕の評価が逆転しない期間では、その期間中の探索が機会損失につながってしまう。
そのため、評価の低い腕の有効性の変化を素早く察知できるよう探索を行いつつ、その探索に伴う機会損失を減らすことが求められる。&lt;/p>
&lt;h2 id="非定常な多腕バンディット問題の解法における効率的な変化察知の方式の検討">非定常な多腕バンディット問題の解法における、効率的な変化察知の方式の検討&lt;/h2>
&lt;p>本研究では、評価の低い腕に対する変化の察知について、素早さと機会損失低減の観点を両立させるため、この探索行為を多腕バンディット内の多腕バンディットとみなす。
そして、この多腕バンディット内の多腕バンディットの評価基準に、腕の不安定性と、将来性を採用することで、探索時の機会損失低減を目指す。&lt;/p>
&lt;p>本報告では、先行研究の一定の割合で実施される探索行為を対象として機会損失の改善を目指す。
すなわち、腕の選定の比率が同一となるようなランダム選定ではなく、腕の不安定性と将来性を基準に、腕の選定の比率を変化させる。
提案手法では、腕の不安定性と将来性を扱うために、獲得報酬の時系列予測を行う。
時系列予測には、将来性の変化を扱えるよう少なくともトレンド成分を扱うことができ、不安定性を扱えるよう予測の幅も扱えるようなモデルが望ましい。
そこで、これらを満たすベイズ型統計モデルを採用する。
扱う報酬の形式により、カルマンフィルタや粒子フィルタを選択可能である。
探索には、各腕でn時点先の評価を予測値と信用区間に基づき腕の不安定性と将来性が高い腕を選定する。
予測値が将来性、信用区間の広さが不安定性に該当する。
なお、これらのモデルでは時系列予測の時点が進むにつれ、その信用区間が広がっていくことから、無限の将来を想定した腕の選定では、先行研究と同じ振る舞いになると考えられる。&lt;/p>
&lt;h2 id="評価">評価&lt;/h2>
&lt;p>カルマンフィルタベースの提案方式のコンセプト実装し、トイ・シミュレーションで機会損失を抑えられることを評価した。&lt;/p>
&lt;h3 id="シミュレーション設定">シミュレーション設定&lt;/h3>
&lt;p>評価環境として、腕の数が3、1000回の試行において、期間中に有効性の最も低かった腕が最も高くなるよう設定した。
なお、このシミュレーションでは、先行研究における一定数の割合の探索の試行のみを取り出したことを想定している。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/1845486/120578001-10a3b200-c460-11eb-83f6-d9b4d703125b.png" alt="plot_true_reward">&lt;/p>
&lt;h3 id="評価方法">評価方法&lt;/h3>
&lt;p>そして、以下のそれぞれの方式に対して、機会損失を抑える性能と変化を素早く察知する性能を評価した。&lt;/p>
&lt;ul>
&lt;li>random: ランダムな探索（予測できない未来を想定）ε-Greedy(ε=1.0)&lt;/li>
&lt;li>epsilon: 現在の情報に基づく探索（予測できない未来を想定）ε-Greedy(ε=0.1)&lt;/li>
&lt;li>state model: 予測に基づく探索（予測できる未来を想定）ε-Greedy(ε=0.1)だが活用時はカルマンフィルタによる100期先予測の値で選定する&lt;/li>
&lt;/ul>
&lt;p>なお、本報告の提案手法のコンセプト実装では、将来性のみを扱い、不安定性の考慮はできていない。&lt;/p>
&lt;p>本評価では、機会損失を抑える性能を、累積リグレットの低さによって評価する。
本報告で、累積リグレットとは、各時点での最適な腕から得られる期待報酬額と方策が選定した腕から得られた報酬額の差の合計のことを指す。
また、変化を素早く察知する性能を、腕の真の有効性が切り替わった時点以降で新しい最適な腕を選択した回数が一定数を超えるまでの期間の短さによって評価する。&lt;/p>
&lt;p>なお、準備期間の関係上、シミュレーションは複数回行っていないため、変動する可能性がある。&lt;/p>
&lt;h3 id="機会損失を抑える性能の評価">機会損失を抑える性能の評価&lt;/h3>
&lt;p>各方式の累積リグレットの推移を下図に示す。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/1845486/120577990-0e415800-c460-11eb-9521-bc81e83b2f38.png" alt="plot_cum_regret">&lt;/p>
&lt;p>均等に腕を選択するrandomではおおよそ線形にリグレットが増加する。
epsilonでは、変化前のリグレットの増加は抑えられるが、変化後には追従が遅れ、リグレットが大きく増加した。
これは、腕の選定の偏りによって探索が十分に行えないことと、過去データにひきづられて腕の評価の更新が遅れていることから発生していると考えられる。&lt;/p>
&lt;p>提案のstate modelでは、シミュレーション初期にrandomと同じ程度のリグレットの増加が確認された。
これは、予測に基づく活用が精度が低かったことに起因する。
50時点以降は予測が安定することで、リグレットの増加がepsilonと同等になった。
そして、変化後であっても、リグレットの増加が抑えられていることが確認できる。
これは、予測によって、将来性がある探索すべき腕を決定し、評価の更新をいち早く行えたためである。&lt;/p>
&lt;h3 id="変化を素早く察知する性能の評価">変化を素早く察知する性能の評価&lt;/h3>
&lt;p>切り替わり後の最適な腕を選択した累積回数の推移を下図に示す。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/1845486/120577999-10a3b200-c460-11eb-8798-e56325190308.png" alt="plot_sampled_new_arm">&lt;/p>
&lt;p>均等に腕を選定するrandomではおおよそ線形に腕が選定される。
本研究の課題設定では、この増加より大きいことが望まれる。
epsilonでは、腕の有効性の変化に追従できず、ε-Greedyの探索割合に応じた増加にとどまった。
これは、腕の選択肢が増加するほど、探索が行われない可能性が増すことも示している。
提案のstate modelでは、予測によって、将来性がある探索すべき腕を決定し、該当の腕に対する探索がrandomと比べて多く行われた。
これにより、変化の察知が素早く進むことが期待できる。&lt;/p>
&lt;p>腕の有効性の変更に対する、提案方式の100時点先の予測を下図に示す。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/1845486/120577996-0f728500-c460-11eb-963f-63cf25f17038.png" alt="plot_predicted_reward">&lt;/p>
&lt;p>本評価のシミュレーション設定は非常に単純なものであったため、予測がおおよそ正しかったことがわかる。&lt;/p>
&lt;h2 id="まとめ">まとめ&lt;/h2>
&lt;p>本報告では、非定常な多腕バンディットにおける変化の察知の課題を整理し、腕の不安定性と将来性に着目した予測型の多腕バンディット方策を提案した。
将来性を考慮可能なコンセプト実装では、シミュレーションにおいて、累積リグレットを抑えた素早い変化察知の可能性が示唆された。
今後はコンセプト実装に、不安定性の考慮を組み込むこと、そのためにε-Greedyではなくトンプソンサンプリングをベースにした手法との統合を進めたい。
また、文脈を考慮した場合での実装とシミュレーションの拡張を行う。
加えて、探索割合自体を環境の変化の度合いに応じて変動させる方式も検討する。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ul>
&lt;li>[1] Fang Liu, Joohyun Lee, and Ness Shroff. 2018. A change-detection based framework for piecewise-stationary multi-armed bandit problem. In Proceedings of the AAAI Conference on Artificial Intelligence, Vol. 32.&lt;/li>
&lt;li>[2] Yang Cao, Zheng Wen, Branislav Kveton, and Yao Xie. 2019. Nearly optimal adaptive procedure with change detection for piecewise-stationary bandit. In The 22nd International Conference on Artificial Intelligence and Statistics. PMLR, 418–427.&lt;/li>
&lt;/ul>
&lt;h1 id="発表スライド">発表スライド&lt;/h1>
&lt;!-- raw HTML omitted -->
&lt;h1 id="発表を終えて">発表を終えて&lt;/h1>
&lt;!-- raw HTML omitted --></description></item><item><title>研究の位置づけを明確にする集中型の論文サーベイ方法</title><link>https://blog.monochromegane.com/blog/2021/05/15/survey-method/</link><pubDate>Sat, 15 May 2021 15:35:14 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2021/05/15/survey-method/</guid><description>&lt;p>博士課程に進学し、国際会議に論文を投稿した際に行った論文サーベイの流れやツールについてまとめておく。
今回のサーベイを行うにあたり、既存研究に対する自身の研究の位置づけを明らかにすることを目標とした。
すなわち、自身の提案がある程度カタチになっていることを前提とした集中的サーベイ方法である。&lt;/p>
&lt;h1 id="論文サーベイの流れ">論文サーベイの流れ&lt;/h1>
&lt;p>以下に行った工程を示す。&lt;/p>
&lt;ol>
&lt;li>会議名とキーワード検索による候補のリストアップ&lt;/li>
&lt;li>各候補のアブストラクトによる選定&lt;/li>
&lt;li>各候補の精読&lt;/li>
&lt;li>必要に応じて参考になる会議名、キーワード、参照論文を候補に追加&lt;/li>
&lt;li>候補がなくなるまで繰り返す&lt;/li>
&lt;/ol>
&lt;p>以降、各工程について利用したツールや工夫などを述べる。&lt;/p>
&lt;h1 id="1-会議名とキーワード検索による候補のリストアップ">1. 会議名とキーワード検索による候補のリストアップ&lt;/h1>
&lt;p>サーベイは十分な量の候補を必要とする。
自身の研究分野や貢献と完全に一致する論文は多くはないが、全くゼロではない。
もし多すぎるのであれば、自身の研究の貢献や目的が十分に掘り下げられていない可能性がある。
もしゼロであれば、自身の研究に有用性がないか、十分な調査ができていないかもしれない。
自身の研究を信じる我々は、いずれにせよ十分に候補を見つける必要がある。&lt;/p>
&lt;p>候補の選定には、&lt;a href="https://scholar.google.com/">Google Scholar&lt;/a>によるキーワード検索を用いる。
なるべく多くの論文を候補とするため、キーワードは関連しそうなキーワードを複数挙げて、ORで繋ぐと良い。
この時、指導教官からのアドバイスで会議名を絞って検索するようにした。
これは、検索クエリに &lt;code>source:SIGKDD&lt;/code> などと指定することで実現できる。&lt;/p>
&lt;p>そして、検索結果から以下の情報をリスト化する。&lt;/p>
&lt;ul>
&lt;li>Title&lt;/li>
&lt;li>Citiations&lt;/li>
&lt;li>URL&lt;/li>
&lt;li>Authors&lt;/li>
&lt;/ul>
&lt;p>おおよそ、Google Scholarではキーワードへの関連性が高いものから並べてくれているため、会議ごとに上位20-50本程度を候補とすれば十分であったように思える。&lt;/p>
&lt;p>リスト化にはGoogleスプレッドシートを利用した。後の工程のため、関連有無フラグとメモ欄をカラムとして追加する。&lt;/p>
&lt;p>なお、検索〜リスト作成は手動では面倒なので、スクリプトを用意した。&lt;/p>
&lt;h1 id="2-各候補のアブストラクトによる選定">2. 各候補のアブストラクトによる選定&lt;/h1>
&lt;p>1.でリストアップした候補について、精読すべきかの選定を行う。
なお、選定はアブストラクトのみで行うこと。
ここで、個別に精読を始めると時間がいくらあっても足りないからである（逆に言えば自身の研究もやはりアブストラクトに提案と貢献をしっかり記述する必要がある）。&lt;/p>
&lt;p>選定基準は自身の研究や提案、貢献に関連がありそうかとする。
また、いくつか読んでいく中で判断基準が徐々に形成されていくので、効率よく見直せるよう、メモを書いておく。
メモには、どういう提案や手法かを一行程度書けば良い。
精読すべきと判断したものには、リストに丸をつけ、フィルタなり色付けして候補を見つけやすくしておく。&lt;/p>
&lt;h1 id="3-各候補の精読">3. 各候補の精読&lt;/h1>
&lt;p>2.で選定した精読候補を読み、まとめる。
多くの論文を読まなければならないこと、最終的に自分の研究との相対的な位置づけを整理する必要があるため、効率よく見直せるようまとめを残す必要がある。
まとめがないと何度も同じ論文をイチから読み直す必要があるので絶対にまとめること。
以下にまとめの観点とこれを実現するツールについて示す。&lt;/p>
&lt;h2 id="まとめの観点">まとめの観点&lt;/h2>
&lt;p>まとめの粒度や項目が統一されていることが望ましい。
自分は、&lt;a href="https://www.slideshare.net/Ochyai/1-ftma15/">落合メソッド&lt;/a>をアレンジして使っている。
つまり、自分の研究の位置づけを整理するのに適した問いかけにしている。&lt;/p>
&lt;ul>
&lt;li>どんなもの？&lt;/li>
&lt;li>先行研究と比べてどこがすごい？（どんな課題を解決する？）&lt;/li>
&lt;li>技術や手法のキモはどこ？（どうやって解決した？）&lt;/li>
&lt;li>どうやって有効だと検証した？&lt;/li>
&lt;li>議論はある？（自分の研究との差異は？）&lt;/li>
&lt;li>次に読むべき論文は？（他に知らなかった技術や概念は？）&lt;/li>
&lt;/ul>
&lt;p>括弧内が自分用の問いかけである。
特に、「議論はある？」を「自分の研究との差異は？」に置き換えることで位置付けの整理を強く意識したまとめができるようになった点が気に入っている。&lt;/p>
&lt;h2 id="まとめのためのツール">まとめのためのツール&lt;/h2>
&lt;p>これまで論文管理には、&lt;a href="https://www.mendeley.com/">Mendeley&lt;/a>を利用し、&lt;a href="https://www.papershipapp.com/">PaperShip&lt;/a>と同期、必要に応じてiPadで書き込みを行っていた。&lt;/p>
&lt;p>しかしながら、今回まとめには&lt;a href="https://www.notion.so/">Notion&lt;/a>を別途利用した。
Notionは、論文への直接書き込みの場合の、十分な余白がない点や論文同士の関係性を横串で把握しにくかった点を解消してくれる。
Notionで、上述のアレンジ版落合メソッドを含んだテンプレートを用意し、サーベイDATABASEに論文ごとに1ページ作り、読みながらまとめを作っていく。&lt;/p>
&lt;p>この時、最初からまとめようとすると論文全体を覚えておかなくてはならないので、自由に記入可能なメモ欄を用意して、読みながら、そちらにわかったこと疑問に思ったことなどを気楽に書いて、最後にまとめる方法をとっている。
メモ欄も残したままにしておくと後から読み直した時に記憶が蘇りやすいのでそのまま残している。&lt;/p>
&lt;p>また、Notionでは各ページに対してPropertyを付与することで絞り込みができるため、会議名タグ、論文の発行年度、論文のURL、その論文を読んだ日付、キーワードのタグをPropertyとして設定している。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2021/05/notion_survey_template.png" alt="notion-survey-template">&lt;/p>
&lt;h1 id="4-必要に応じて参考になる会議名キーワード参照論文を候補に追加">4. 必要に応じて参考になる会議名、キーワード、参照論文を候補に追加&lt;/h1>
&lt;p>精読の中で、気になる会議名、キーワードが追加された場合、もう一度、1.の検索に戻り候補を追加する。
また、参照されている論文も候補に追加する。&lt;/p>
&lt;p>コツとしては、追加された候補に対してすぐにアブストや精読を始めずに、候補として追加に止める事。
この追加した候補はまた新しい候補を増やすので、ゴールが見えなくなってしまうからである。
なので、最初に決めた候補まで読み切ってから、新しい候補の処理に着手すると気分的に進捗感が出て楽であった（これはまあ人による）。&lt;/p>
&lt;h1 id="5-候補がなくなるまで繰り返す">5. 候補がなくなるまで繰り返す&lt;/h1>
&lt;p>以上を候補がなくなるまで繰り返す。
参考文献が参考文献を呼んで終わらないのではないかと思われたが、2-3周もすれば新しい文献も出てこなくなってくる。
まとめの中で自身の研究が位置付けられてくるので、そこを一旦の止め時とした。&lt;/p>
&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>国際会議への投稿にあたって、自身の研究の位置づけを明確にするための論文サーベイの方法をまとめた。
今回は、最初のリストが243本、精読が47本であった。
会議を分けてサーベイすることで会議ごとに同じキーワードでも論文に特色があることなどが分かり興味深かった。
また、トップカンファレンスに限ることで、サーベイ効率も高まったと思う。
指導教官に感謝である。&lt;/p>
&lt;p>Notion上の47ページの論文まとめは執筆中、何度も読み直したが自分なりのまとめメモが入っていること、自分の研究との位置づけが一言でまとめられていることから、効率よく記憶が蘇らせることができた。
結果として、複数の論文同士の関係性を整理するという目標に自身のリソースを采配することができたと思う。&lt;/p>
&lt;p>一方で、キーワード検索では、既読管理と相性が悪いため、普段のインプットとしての継続的なサーベイには向かない。
RSSフィード的なインプットの方法を探したい。&lt;/p></description></item><item><title>2020</title><link>https://blog.monochromegane.com/blog/2020/12/31/2020/</link><pubDate>Thu, 31 Dec 2020 11:47:04 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/12/31/2020/</guid><description>&lt;p>今年は、なんと言っても、6月の初めてのジャーナル論文採録が文句なしに一番嬉しかった出来事だった。
ペパボ研究所に入って3年半。
本当に長かったし苦しかった。
それでもこの期間にたくさん自分自身や研究と向き合うことで、多くのものを得ることができたと思う。
今は、ただただ「巨人の肩に乗ることから逃げずに真摯に向き合い一歩づつ精進して」いる。&lt;/p>
&lt;p>10月には、博士後期課程に挑戦し、無事に入学することができた。
12月のインターネットと運用技術シンポジウムではジャーナル論文の研究を発展させる手法が採録され、優秀プレゼンテーション賞も受賞することができた。
来年は国際会議に挑戦する。&lt;/p>
&lt;p>長い暗中模索を抜けたが、スタートラインにやっと立てたとも言える。
遅れを取り戻すことを動機とはしないが、2021年は、可能な限り、適切な粒度で継続的に分野への貢献を出していきたい。
また、その貢献を通して周りの人へ直接的間接的に良い影響を与えたいと思う。&lt;/p>
&lt;p>そのためにも、習慣と計画をうまく使い、仕組みによって淡々と自分を駆動していきたい。
2020年は1月末からリモートワークに完全移行したが、毎朝の論文読み会によって生活リズムが崩れることはなく研究に取り組めた。
毎日の業務後に進めるよう計画していた、大学基礎数学の参考書は、微分積分、線形代数、確率統計を一通りこなすことができた。
一方で、研究開発において、習慣と計画は適用が難しいと感じている。
研究には終わりがないため、どこまでの試行錯誤を区切りとするのか判断がつきにくい。
また、アイディアは無限にあるため、いろいろなことをやりたくなり、優先順位の判断がつきにくい。
つまり、全体をブレイクダウンしてルーティーンに落とし込むところに苦労している。
ここに関しては、研究日誌のような短期のアウトプットに加えて、もう少しだけ長い視点での判断をする機会を計画や習慣として組み込んでいきたい。
まずは、その観点でも指導教官や研究所のみんなにも相手になってもらおう。&lt;/p>
&lt;p>2020年は光が見えた年だった。
2021年からは、この成果を普段から出せるよう、そして一つ上を目指せるようにしていこうと思う。
そして、その成果から行動の意義が伝わるような良い影響を与えられるようになりたいと思う。
来年もよろしくお願いします。&lt;/p>
&lt;h1 id="実績">実績&lt;/h1>
&lt;p>以下、実績を列挙する。&lt;/p>
&lt;h2 id="表彰">表彰&lt;/h2>
&lt;p>2020年は2回の表彰があった。
コミュニティ活動と研究活動の両面で表彰をいただくことができて、非常に嬉しい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.iot.ipsj.or.jp/awards/symposium/">IOTS2020 優秀プレゼンテーション賞&lt;/a>, 三宅 悠介, 栗林 健太郎, 変化検出と要約データ構造を用いた利用者の嗜好の変化に迅速に追従する多腕バンディット手法, 2020年12月.&lt;/li>
&lt;li>&lt;a href="https://efc.fukuoka.jp/information/3116">エンジニアフレンドリーシティ福岡アワード コミュニティ部門&lt;/a>, 三宅 悠介,小田 知央, Fukuoka.go, 2020年1月.&lt;/li>
&lt;/ul>
&lt;h2 id="論文">論文&lt;/h2>
&lt;p>国内ジャーナル論文1本、査読付き論文1本。研究報告については第一著者のものが1本。
また、今年は研究報告のラストオーサーを2本務めた。&lt;/p>
&lt;ol>
&lt;li>三宅 悠介, 峯 恒憲, &lt;a href="https://search.ieice.org/bin/summary.php?id=j103-d_11_764">Synapse: 文脈に応じて継続的に推薦手法の選択を最適化する推薦システム&lt;/a>, 電子情報通信学会論文誌D, Vol.J103-D, No.11, pp.764-775, Nov 2020.&lt;/li>
&lt;li>三宅 悠介, 栗林 健太郎, &lt;a href="http://id.nii.ac.jp/1001/00208105/">変化検出と要約データ構造を用いた利用者の嗜好の変化に迅速に追従する多腕バンディット手法&lt;/a>, インターネットと運用技術シンポジウム論文集, 2020, pp.1-8, Nov 2020. &lt;a href="https://speakerdeck.com/monochromegane/iots2020-adaptive-linear-mab">[発表資料]&lt;/a>&lt;/li>
&lt;li>三宅 悠介, 栗林 健太郎, &lt;a href="http://id.nii.ac.jp/1001/00206029/">非定常な多腕バンディット問題における変化検出アプローチの線形モデルへの拡張&lt;/a>, 研究報告インターネットと運用技術（IOT）, Vol.2020-IOT-50, pp.1-8, July 2020.&lt;a href="http://localhost:4567/papers/iot50-miyakey.pdf">[論文]&lt;/a> &lt;a href="https://speakerdeck.com/monochromegane/extension-of-change-detection-method-for-non-stationary-linear-multi-armed-bandit">[発表資料]&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="国内発表">国内発表&lt;/h2>
&lt;p>技術イベント、研究会での発表で計６回（学会の研究会、シンポジウムを除く）。
Fukuoka.go、WSA研究会といったお馴染みのところに加え、GMOのテックカンファレンス、エンジニアフレンドリーシティ福岡のような声をかけていただいた登壇もあり、バランスは良かったと思う。
来年は、国際カンファレンス登壇が最初の目標だが、国内でも参加したことがない技術カンファレンスや勉強会なども挑戦してみたい。&lt;/p>
&lt;ol>
&lt;li>三宅 悠介 &lt;a href="https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/">嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討&lt;/a>, &lt;a href="https://wsa.connpass.com/event/187128/">Web System Architecture 研究会 (WSA研) #7&lt;/a>, 2020年11月.&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/coherently-fittable-system">なめらかなシステムの実現に向けて&lt;/a>, &lt;a href="https://www.gmo.jp/developersday/">GMO Developers Day 2020&lt;/a>, 2020年7月. [&lt;a href="https://youtu.be/KW-YKuM1ndI">動画&lt;/a>]&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/fukuokago-stage">Go言語でシミュレーション用のシンプルなフレームワークStageをつくった&lt;/a>, &lt;a href="https://fukuokago.connpass.com/event/180414/">Fukuoka.go#16(オンライン開催)&lt;/a>, 2020年7月.&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/wsa6-sifter">軽量なインデックス機構を用いた全文検索ツールの高速化の検討&lt;/a>, &lt;a href="https://websystemarchitecture.hatenablog.jp/entry/2019/12/11/165624">Web System Architecture 研究会 (WSA研) #6&lt;/a>, 2020年4月.&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/fukuokago15-adwin-exphist">Adaptiveなウィンドウを求めて 〜サーベイと実装 Go言語編〜&lt;/a>, &lt;a href="https://fukuokago.connpass.com/event/164350/">Fukuoka.go#15 + 鹿児島Gophers(オンライン開催)&lt;/a>, 2020年3月.&lt;/li>
&lt;li>三宅 悠介, 田中 孝明, 白石 憲正, 浜崎 陽一郎, 松口 健司 &lt;a href="https://efc.fukuoka.jp/information/2562#day2_7">トークセッション / エンジニアと企業が描く未来のかたち&lt;/a>, &lt;a href="https://efc.fukuoka.jp/information/2562">エンジニアフレンドリーシティ福岡フェスティバル&lt;/a>, 2020年2月.&lt;/li>
&lt;/ol>
&lt;h2 id="oss">OSS&lt;/h2>
&lt;p>変化検出の手法をはじめ、シミュレーションのフレームワークなど研究開発で取り組む分野の実装が増えてきた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/monochromegane/adwin-v">ADWIN-V&lt;/a>: ADWIN-V is an adaptive windowing algorithm for vector data.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/stage">stage&lt;/a>: Simple and flexible simulation framework for Go.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/sifter">sifter&lt;/a>: A lightweight index for full text search tools using bloom filter.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/adwin">adwin&lt;/a>: Adwin is an adaptive windowing algorithm.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/exponential-histograms">exponential-histograms&lt;/a>: Exponential histograms is a data structure for sliding windows.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/random_multivariate_normal">random_multivariate_normal&lt;/a>: Random number generator from a multivariate normal distribution.&lt;/li>
&lt;/ul>
&lt;h2 id="コミュニティ活動">コミュニティ活動&lt;/h2>
&lt;p>昨年度の活動や昨今の状況でのオンラインでの活動が評価され、表彰やインタビューを受ける機会をいただき非常にありがたいことであった。
一方で、Fukuoka.go自体の活動実績は2回と例年に比べかなり少なめであった。
オンライン開催での主催者側のモチベーションをどう維持するかも課題である。&lt;/p>
&lt;ul>
&lt;li>小田 知央,三宅 悠介,清家 史郎 &lt;a href="https://efc.fukuoka.jp/interview/3704">勉強会はパーティーだ! ビール片手に楽しくGo言語を学ぶコミュニティ「Fukuoka.go」&lt;/a>, &lt;a href="https://efc.fukuoka.jp/interview">ENGINEER INTERVIEW - Engineer Friendly City Fukuoka&lt;/a>, 2020年8月.&lt;/li>
&lt;li>&lt;a href="https://fukuokago.connpass.com/event/180414/">Fukuoka.go#16 (オンライン開催)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fukuokago.connpass.com/event/164350/">Fukuoka.go#15 + 鹿児島Gophers(オンライン開催)&lt;/a>&lt;/li>
&lt;li>三宅 悠介,小田 知央 &lt;a href="https://dayori.city.fukuoka.lg.jp/129892/">エンジニアの技術向上に取り組むコミュニティ･企業を表彰 エンジニアフレンドリーシティ福岡アワード&lt;/a>, &lt;a href="https://dayori.city.fukuoka.lg.jp/">福岡市政だより&lt;/a>, 2020年3月.&lt;/li>
&lt;/ul>
&lt;h2 id="ブログ">ブログ&lt;/h2>
&lt;p>13本。結果だけでなく、どうしてその考えに至ったかなど、その経緯、考えをまとめるカタチの文章をいくつか出すことができた。特に論文執筆のエントリのような自分なりのまとめは定期的に書いていきたいと思う。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/">嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/10/14/pen-tablet/">ペンタブレットでリモートワークのコミュニケーションを改善する&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/09/23/structure-of-research-paper/">構造を意識した抜け漏れがなく主張点が明確な論文執筆&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/09/21/isee-kyushu-u/">九州大学大学院システム情報科学府博士後期課程に入学します&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/">ペパ研から研究をはじめてジャーナルでのアクセプトまでいけた日&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/05/31/simulation-framework-stage/">Go言語でシミュレーション用のシンプルなフレームワークStageをつくった&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/05/16/bandit-algorithm-ucb1/">多腕バンディット問題におけるUCB方策を理解する&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/04/29/why-fukuokago/">なぜ勉強会「だった」のか&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/04/29/wsa6_sifter/">軽量なインデックス機構を用いた全文検索ツールの高速化の検討&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/03/11/dynamic-gamma-poisson/">Dynamic Gamma-Poisson modelを試す&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/03/03/minimum-start-for-online-event/">勉強会をオンライン配信するための必要最小限な環境構築&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/01/30/memo-getting-start-reinformation-learning-algorithm/">『強化学習アルゴリズム入門』第1章〜第2章の学習メモ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/01/26/exhalation-and-coherently-fittable-system/">テッド・チャン『息吹』と「なめらかなシステム」&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討</title><link>https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/</link><pubDate>Tue, 17 Nov 2020 10:46:53 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/</guid><description>&lt;p>このエントリは、&lt;a href="https://wsa.connpass.com/event/187128/">第7回 Web System Architecture 研究会 (WSA研)&lt;/a>の予稿です。&lt;/p>
&lt;h1 id="嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討">嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討&lt;/h1>
&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>適応的なシステムの実現には、システムが利用者の状況をよく知ることが重要になる。
ECサイトのシステムであれば、利用者の嗜好を把握することで、最適な商品を提案できると考えられる。&lt;/p>
&lt;p>ECサイトのシステムが利用者の嗜好を把握するためには、特に初期段階における利用者との一定量のコミュニケーションが必要となる。
明示的なコミュニケーションであれば、システムは利用者に、年齢や居住地、興味関心などのプロファイルの登録を依頼する。
暗黙的なコミュニケーションであれば、システムは利用者の、閲覧や購買、検索履歴を通して利用者の嗜好を把握する。
システムはこれらのプロファイルの登録や履歴の蓄積なくして、適応的に振舞うことが難しい。
一方で、これらのコミュニケーションは利用者に負担を強いる。
これには、システムごとに発生するプロファイルの登録や履歴蓄積のための労力的な負担の他、プライバシーを守りたいという意識的な負担も考えられる。&lt;/p>
&lt;p>本研究では、利用者の嗜好伝達に纏わるコミュニケーションの負担を低減しつつ、適応的なシステムによる利便性を常に享受できるインターネット世界に向けて、嗜好伝達コミュニケーションの効率化のための伝達方式の検討を行う。&lt;/p>
&lt;h2 id="嗜好伝達コミュニケーションの課題">嗜好伝達コミュニケーションの課題&lt;/h2>
&lt;p>嗜好伝達コミュニケーションの課題整理にあたり、本研究における「嗜好」を定義する。
まず、嗜好(preference)とは「利用者の素性(feature)」に基づく「対象(content)への反応(reaction)」と考える。&lt;/p>
&lt;pre tabindex="0">&lt;code>preference(feature,content) #=&amp;gt; reaction
&lt;/code>&lt;/pre>&lt;p>対象(content)はシステムごと（ECサイトごと）に異なるため、嗜好伝達にはシステムごとに個別のコミュニケーションが求められる。
利用者の素性(feature)を示すか、直接、対象(content)への反応(reaction)を示す行為がこれに該当する。
推薦システムでは、利用者の素性(feature)を示す場合、類似する素性の群の反応を用いて利用者の嗜好が推測される。
対象(content)への反応(reaction)を示す場合、この反応から、もしくは類似する群から利用者の嗜好が推測される。&lt;/p>
&lt;p>本研究では、この、利用者の素性(feature)の伝達か、対象(content)への反応(reaction)の伝達に纏わるコミュニケーションの効率化を検討する。&lt;/p>
&lt;h3 id="利用者の素性featureの伝達の課題">利用者の素性(feature)の伝達の課題&lt;/h3>
&lt;ol>
&lt;li>システム内に限定された利用者の素性&lt;/li>
&lt;li>適切なデータ構造が不明&lt;/li>
&lt;li>プライバシー保護が必要&lt;/li>
&lt;/ol>
&lt;p>「1. システム内に限定された利用者の素性」について、利用者の素性(feature)には人口統計的な情報だけでなく、行動データが考えられる。
利用者の素性をより知るためには、システムを横断して蓄積された行動データを得られることが望ましい。
しかしながら、通常、システムの把握可能な履歴はシステム内に限定される。
オンライン広告に見られるアドネットワークやオーディエンスデータの利用により、横断した行動を特定できる。
しかしながら、これらのcookieなどを用いた名寄せに関してはプライバシー保護意識の高まりもあり、代替手段を検討すべきである（要リファレンス）。&lt;/p>
&lt;p>「2. 適切なデータ構造が不明」について、利用者の素性(feature)となり得る要因は無限に検討可能なことから、これを全てのシステムで共通に管理することは困難である。
例えば、訪問したサイトを利用者の素性として扱うとして、多次元のベクトルデータで表現すると、各次元とサイトの紐付けやサイトの追加削除を管理しなければならない。&lt;/p>
&lt;p>「3. プライバシー保護が必要」について、人口統計的な情報だけでなく、行動データを含む利用者の素性は多くのセンシティブな情報を含むことから、利用者側が開示するにあたって内容の制限が求められるであろう。&lt;/p>
&lt;h3 id="対象contentへの反応reactionの伝達の課題">対象(content)への反応(reaction)の伝達の課題&lt;/h3>
&lt;ol>
&lt;li>システム内に限定された利用者の嗜好&lt;/li>
&lt;li>プライバシー保護が必要&lt;/li>
&lt;/ol>
&lt;p>「1. システム内に限定された利用者の嗜好」について、前述の通り、プロファイルの登録や履歴蓄積のための労力的な負担が発生する。
対象(content)はシステム内に限定されるため、システムごとにその反応を提示しなければならない。
この時、利用者の嗜好をより知るためには、できるだけ多くの対象(content)に対する反応(reaction)を示せることが望ましいが、労力的な負担は比例して増加する。&lt;/p>
&lt;p>「2. プライバシー保護が必要」について、利用者の嗜好傾向は（素性と比較して間接的ではあるものの）センシティブな情報を含むことから、利用者側が開示するにあたって内容の制限が求められるであろう。&lt;/p>
&lt;h2 id="嗜好伝達コミュニケーションの効率化の検討">嗜好伝達コミュニケーションの効率化の検討&lt;/h2>
&lt;h3 id="利用者の素性featureの伝達の効率化">利用者の素性(feature)の伝達の効率化&lt;/h3>
&lt;p>本研究では、利用者の素性(feature)の伝達の効率化のため、人口統計的な情報だけでなく、システムを横断した行動データを局所管理するアプローチを検討する。
無限に検討可能な要因を共通して扱うため、Key-Value形式のデータ構造を採用する。
また、システムへの提示時に、このKey-Value形式のデータをBloomFilterに変換することでプライバシー保護を試みる。
すなわち、BloomFilterの偽陽性に着目した素性であるKeyを断定することができない特性を利用する。
また、BloomFilterが保存する要素数に依存しない特性を利用して、無限に検討可能な利用者の素性の要因を固定次元で扱うことができる。&lt;/p>
&lt;p>なお、あるシステムに提示されるBloomFilterのパラメータは全ての利用者が同じものを用いる必要があるが、これらの共有方式についてはここでは検討しない。&lt;/p>
&lt;h3 id="対象contentへの反応reactionの伝達の効率化">対象(content)への反応(reaction)の伝達の効率化&lt;/h3>
&lt;p>本研究では、対象(content)への反応(reaction)の伝達の効率化のため、嗜好モデルを局所管理するアプローチを検討する。
提案手法では、システムを横断した行動データから、嗜好モデルを構築するローカルエージェントを設ける。
構築される嗜好モデルはこれまでの行動データから、未知の対象(content)への反応(reaction)を精度よく推測する。
ローカルエージェントは、このモデルを使い、システムに対する対象(content)への反応(reaction)の伝達を代理する。
具体的には、利用者が新しいシステムへのアクセスする際に、（システムが対応していれば）この嗜好モデルを使って、先方のシステムから示された大量の対象(content)への反応(reaction)を回答する。
先方のシステムは、十分な量のコミュニケーションを終え、利用者に利便性の高い状態から利用を開始してもらうことができる。
また、予めローカルエージェントの嗜好提示範囲に制限を持たせておくことで、プライバシー管理も行えると考える。&lt;/p>
&lt;p>なお、これらの方式は検討段階であり、ローカルエージェント、嗜好モデルの具体的な実装はこれから検討していく。&lt;/p>
&lt;h2 id="評価">評価&lt;/h2>
&lt;h3 id="利用者の素性featureの伝達の効率化の評価">利用者の素性(feature)の伝達の効率化の評価&lt;/h3>
&lt;p>提案手法の有効性を判断するため、BloomFilterに変換した素性によって嗜好情報の伝達能力を評価した。
評価として、素性を特徴量として用いた多腕バンディットのシミュレーションを行った。
元の素性と比較して提案手法の素性で、どの程度精度に変化があったかを確認した。&lt;/p>
&lt;p>以下は、腕の数が30、密度（＊後述）10倍の実験設定の時の、BloomFilterの次元数と精度の変化を表している。
ここで、精度の変化とは、元の素性を使ったシミュレーションで選定された腕と同じ腕を選定できた割合を言う。&lt;/p>
&lt;pre tabindex="0">&lt;code>1: 1.0
2: 0.60425
3: 0.424515
4: 0.38845
5: 0.35002
6: 0.32798
7: 0.335945
8: 0.307885
9: 0.31443
10: 0.317955
20: 0.311235
30: 0.3068
40: 0.320385
50: 0.30193
60: 0.31655
70: 0.33412
80: 0.319935
90: 0.309365
100: 0.33812
&lt;/code>&lt;/pre>&lt;p>BloomFilterで表現された素性をコンテキスト情報として用いた推定には誤差が生じる。
そして、この誤差の増加はBloomFilterの偽陽性率の増加に従う。
今回の問題設定では、例えば100次元のバイナリベクトルを50次元のBloomFilterで表現することである（このような状態を本研究では密度2倍と考える）。
また、多腕バンディットでは腕の本数の増加に従い、不確実な状況において偶然当たる確率が下がる。
これらを考慮して、100次元のコンテキスト情報を10次元へ圧縮、30本の腕という問題設定でベストな腕を選択できた割合をサンプリングによって求めた。
結果として正しい腕を選択できたのは33%程度であった。
現実の推薦システムにおいてあり得る程度のスケールでも精度に対して大きな影響が発生することがわかった。&lt;/p>
&lt;h3 id="対象contentへの反応reactionの伝達の効率化の評価">対象(content)への反応(reaction)の伝達の効率化の評価&lt;/h3>
&lt;p>今後、実装と評価を行っていく。&lt;/p>
&lt;h1 id="発表スライド">発表スライド&lt;/h1>
&lt;!-- raw HTML omitted -->
&lt;p>発表後の議論では、アプローチに対する新規性や有用性について、また、Webサービスへの適用のアイディアについても話すことができ、今後にとって非常に有意義なものとなった。&lt;/p>
&lt;h1 id="発表を終えて">発表を終えて&lt;/h1>
&lt;p>今回のWSA研では、最初のアプローチの失敗で終わらず、やりたいことに立ち返り、より良いと思われるアプローチも検討できた点が良かったと思う。
長期間続く研究であればこそ、個々の結果に一喜一憂ではなく全体として進んでいけるよう全てを糧にしていきたい。&lt;/p>
&lt;p>そして、このような研究のアイディア段階から前向きに意見を出し合うことができる機会を定期的に設けることができるWSA研はとても良いコンセプトの研究会だと思う。
何よりその時間はとても楽しい。&lt;/p>
&lt;p>Webシステムアーキテクチャに関する運用知見を研究的アプローチで前進させること興味がある方は次回開催の参加を検討してみてはいかがでしょうか。&lt;/p>
&lt;!-- raw HTML omitted --></description></item><item><title>ペンタブレットでリモートワークのコミュニケーションを改善する</title><link>https://blog.monochromegane.com/blog/2020/10/14/pen-tablet/</link><pubDate>Wed, 14 Oct 2020 20:47:32 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/10/14/pen-tablet/</guid><description>&lt;p>リモートワークが続く中、口頭での説明を補足するため電子ホワイトボードなどを使ったコミュニケーションの機会が増えています。
一方で、手書きの気軽さに追従できないマウスを使っていると、書くより口頭での説明の方が早いと電子ホワイトボードを使わずにすましてしまうこともありました。&lt;/p>
&lt;p>しかしながら手書きの表現力を生かしたコミュニケーションは捨て難く、ペン型の入力装置を探していました。
iPadは入力装置としても優れていますが、他にも活躍する場面が多いこと、連携時にも一手間かかることから、常時接続できる据置型のシンプルな入力装置としてペンタブレット（いわゆる板タブ）を導入しました。
今のところ、快適に利用できているので、簡単にご紹介します。&lt;/p>
&lt;h2 id="機材">機材&lt;/h2>
&lt;p>家にあった&lt;a href="https://www.amazon.co.jp/gp/product/B013SMIUDU/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=B013SMIUDU&amp;amp;linkCode=as2&amp;amp;tag=monochromeg03-22&amp;amp;linkId=fe1ce71c51452d4f2aeb9e54b37e1ed5">ワコム Intuos Comic&lt;/a>を使っています。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>僕の用途であればSサイズ（210x169mm。ただし入力領域はこのうち155x95mm程度）で十分でした。
こちらはUSB(Type-A)でPCと接続します。すでに旧モデルとのことで、これから購入するならBluetoothで接続できる新しいものが良さそうです。&lt;/p>
&lt;p>また、接続先のPCはMacBook Pro (15-inch, 2019) です。
macOS Catalinaですが、ワコムのサイトに公開されている最新のドライバをインストールした上で、「セキュリティとプライバシー」で必要なアプリケーションに許可を与えることで利用できるようになりました。&lt;/p>
&lt;h2 id="設定">設定&lt;/h2>
&lt;p>後述しますが、タブレットの座標検出は絶対位置の指定です。
小さいタブレットに大きな画面をマッピングして使うのは向いていないため、画面内の限られた範囲をマッピングして利用しています。&lt;/p>
&lt;p>僕の用途では電子ホワイトボードとしてJamboardを利用しており、画面内の決まった位置（左上）で扱うため、この範囲をタブレットの操作範囲としました。
これによってJamboardの表示範囲とタブレットの入力領域がある程度同じになり、違和感なく入力できるようになりました。&lt;/p>
&lt;p>ワコムのタブレットの場合、以下のように設定できます。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2020/10/wacom-config.png" alt="wacom">&lt;/p>
&lt;h2 id="タブレットの操作">タブレットの操作&lt;/h2>
&lt;p>普段の業務は、キーボードとマウスで済むため、タブレットは初めて利用でした。
そのため、操作に慣れるまで少しだけ戸惑いましたが、以下のサイトを見て、基本を理解しました。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tablet.wacom.co.jp/article/%E3%83%9A%E3%83%B3%E3%82%BF%E3%83%96%E3%83%AC%E3%83%83%E3%83%88-%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E4%BD%BF%E3%81%84%E6%96%B9">ペンタブレット 基本的な使い方&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>以下だけ理解すればすんなり使えると思います。&lt;/p>
&lt;ul>
&lt;li>ペンをタブレットから浮かした状態でポインタを移動&lt;/li>
&lt;li>ペンをタブレットにつけるとクリックしながらポインタを移動することに相当&lt;/li>
&lt;li>タブレットの操作領域が画面にマッピングされている&lt;/li>
&lt;/ul>
&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>Google MeetからJamboardを開いて参加者にリンクを共有できるようになり、便利になりました。
利用までの手間を小さくできるよう、常時接続型のシンプルなタブレットを導入することで、Jamboardを積極的に利用することができ、手書きの気軽さと表現力を活かしたコミュニケーションの改善につながっていると感じます。&lt;/p>
&lt;p>今後改善したいところとしては、ペンのボタンへのアクション割り当てなのですが、Jamboardの消しゴムやレーザーポインタ切り替えにショートカットがなく、まだ実現できていない状態です（フィードバック送ろう）。&lt;/p>
&lt;p>まだまだリモートワークも続くでしょうから、引き続き、入力機器の構成や工夫など進めていきたいと思います。&lt;/p></description></item><item><title>構造を意識した抜け漏れがなく主張点が明確な論文執筆</title><link>https://blog.monochromegane.com/blog/2020/09/23/structure-of-research-paper/</link><pubDate>Wed, 23 Sep 2020 13:36:25 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/09/23/structure-of-research-paper/</guid><description>&lt;h1 id="はじめに">はじめに&lt;/h1>
&lt;p>研究者は、自身の研究の有用性を主張するため論文を発表する。
しかしながら、研究の有用性を主張するために、抜け漏れがなく主張点が明確な文章を書くのは、慣れないうちは難しい（慣れても難しい）。
本エントリでは、論文の構造を見出だす工程とその構造を書き下す工程を明示的に分離することで、抜け漏れがなく主張点が明確な論文執筆を行う方法を検討する。&lt;/p>
&lt;h1 id="論文執筆の課題">論文執筆の課題&lt;/h1>
&lt;p>前述の通り、研究の有用性を主張するために、抜け漏れがなく主張点が明確な文章を書くのは、慣れないうちは難しい。
これは、主張の整理と文章の生成を頭の中で同時にやろうとしていることが原因であるように思う。&lt;/p>
&lt;p>第一に、主張の整理は複雑なタスクである。
研究の有用性の主張は、いくつかの課題や提案、評価といった複数の要素と、要素同士の関係性のあり方、すなわち「構造」を持つ。
要素やその関係性の増加に伴い、構造は複雑になるため、頭の中だけで網羅しつつ整合性を取り続けるのは困難である。&lt;/p>
&lt;p>第二に、主張の構造を文章に落とし込むのは複雑なタスクである。
文章は連続した文から構成され、逐次的に記述される。
そのため、要素同士の関係性を含む主張の構造を書き下すためには、文同士の局所的な繋がりに加え、段落や接続詞による大局的な繋がりを表現しなければならない。
頭の中の主張の構造を余さずに正確に文章へと変換するのは困難である。
主張の構造が明らかでない段階では尚更である。&lt;/p>
&lt;h1 id="抜け漏れがなく主張点が明確な論文を書く">抜け漏れがなく主張点が明確な論文を書く&lt;/h1>
&lt;p>論文執筆が難しい理由は、主張の構造を見出だすこと、この構造を文章に落とし込むことという複雑なタスクを同時に行うためだと解釈した。
そこで、これらのタスクを明示的に分離する方法を考える。
この時、主張の構造を見出だすタスクの成果物を文章としてしまっては、主張の構造を文章に落とし込むタスクを兼ねてしまう。
主張の構造を見出だすタスクには必要な要素を文単位で表し、これらの関係性を表現できる形式が望ましい。
本エントリでは、このタスクをつなぐ中間表現を論文ストラクチャーと名付ける。
提案する論文ストラクチャーを以下に示す。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2020/09/research_paper_structure.jpeg" alt="structure">&lt;/p>
&lt;p>提案する論文執筆では、この論文ストラクチャーを埋めていく工程と、論文ストラクチャーをもとに主張を文章に落とし込む工程を繰り返すことで執筆を行う。&lt;/p>
&lt;h2 id="主張の構造を見出だす論文ストラクチャーを埋める">主張の構造を見出だす（論文ストラクチャーを埋める）&lt;/h2>
&lt;p>以下、埋めるべき内容について簡単に説明する。
はじめに②と⑤から主張を明確にし、その主張をストーリー立てて仕上げるよう残りの項目を埋めていくと良い。
なお、③④⑥はリスト形式かつ対応づけを行えるため、ストーリー内の根拠の抜け漏れを防ぐことができる。&lt;/p>
&lt;h3 id="-やりたいこと">② やりたいこと&lt;/h3>
&lt;p>⑤と合わせて、&lt;strong>主張を明確にするために重要な要素&lt;/strong>。
リサーチクエスチョンとして、何を解決したいのか、達成したいのかを一文で述べる。&lt;/p>
&lt;p>システム・ソフトウェア開発の論文では、提案手法によって、どのような理想の世界に近づくのかを示す。&lt;/p>
&lt;ul>
&lt;li>例）実行環境の変化に素早く適応する &lt;!-- raw HTML omitted -->[*1]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>例）文脈に応じて継続的に推薦手法の選択を最適化する &lt;!-- raw HTML omitted -->[*2]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;/ul>
&lt;h3 id="-やったこと">⑤ やったこと&lt;/h3>
&lt;p>②と合わせて、&lt;strong>主張を明確にするために重要な要素&lt;/strong>。
リサーチクエスチョンをどのようなアプローチ、着眼点をもって解決、達成したかを一文で述べる。&lt;/p>
&lt;p>システム・ソフトウェア開発の論文では、開発したシステムやソフトウェア、アーキテクチャなどの特徴を示す。&lt;/p>
&lt;ul>
&lt;li>例）恒常性を持つシステムアーキテクチャ（を提案・開発）&lt;!-- raw HTML omitted -->[*1]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>例）多腕バンディットを用いたメタ推薦システム（を開発）&lt;!-- raw HTML omitted -->[*2]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;/ul>
&lt;h3 id="-なぜやりたいのか">① なぜ、やりたいのか&lt;/h3>
&lt;p>②への導入となる要素。
その研究の価値や意義を述べる。&lt;/p>
&lt;p>システム・ソフトウェア開発の論文では、提案手法によって、どうして、そのような理想の世界に近づけたいのかを示す。
世間一般的に解決すべき課題として位置付けるも良いし、これまで世間が気づけていなかったけれども見方を変えて課題として捉え直した、のようにしても良いと思う。&lt;/p>
&lt;h3 id="-なぜできないのか">③ なぜ、できないのか&lt;/h3>
&lt;p>②に対しての課題であり、⑤のアプローチへの導入となる要素。
理想となる世界に対しての（主に）技術的な課題を述べる。
多くの研究では、従来の研究成果で未解決、もしくは改善が必要とされる領域についてサーベイ結果が該当する。&lt;/p>
&lt;p>なお、ここは複数の要素が挙げられるため、論文ストラクチャー上は「A、B、C&amp;hellip;」とリスト形式で記述する。&lt;/p>
&lt;h3 id="-どうやって解決したのか">④ どうやって、解決したのか&lt;/h3>
&lt;p>③の複数の課題に対する個々の解決手段であり、⑤の詳細となる要素。
提案手法である⑤がどのような方法で課題を解決するのかを述べる。&lt;/p>
&lt;p>ここは対応づけを行うことでストーリー内での根拠の抜け漏れを防ぐことが目的であるため、③の個々の課題に対する解決手段を「A'、B'、C'&amp;hellip;」とリスト形式で記述する。&lt;/p>
&lt;h3 id="-本当にできたのか">⑥ 本当に、できたのか&lt;/h3>
&lt;p>③の課題を④の手法で解決できたことを示す要素。
評価とその結果を述べる。&lt;/p>
&lt;p>ここも対応づけによる抜け漏れを防ぐことが目的であるため、③④の個々の課題、手法に対する評価内容を「A''、B''、C''&amp;hellip;」とリスト形式で記述する。&lt;/p>
&lt;h2 id="構造を文章に落とし込む論文ストラクチャーから文章を作る">構造を文章に落とし込む（論文ストラクチャーから文章を作る）&lt;/h2>
&lt;p>論文ストラクチャーを埋めたら、各項目を使って論文の文章の雛形を作っていく。&lt;/p>
&lt;h3 id="タイトル">タイトル&lt;/h3>
&lt;p>②と⑤を組み合わせることは主張を端的に表現したタイトル案を作ることができる。
よく使われるパターンは「⑤を用いた②」「②が可能な⑤」などであろう。&lt;/p>
&lt;h3 id="概要">概要&lt;/h3>
&lt;p>①から⑥を順番に並べることで抜け漏れのない概要案を作ることができる。
典型的な例では以下のようにつながれる。&lt;/p>
&lt;ul>
&lt;li>①の状況になっている&lt;/li>
&lt;li>そのため②が求められている、必要となる&lt;/li>
&lt;li>一方で③A&amp;hellip;の課題がある&lt;/li>
&lt;li>本研究では⑤を提案する&lt;/li>
&lt;li>提案手法では④A'&amp;hellip;を用いて課題を解決した&lt;/li>
&lt;li>評価では⑤A''&amp;hellip;によって有効性を確認した&lt;/li>
&lt;/ul>
&lt;h3 id="1-はじめに">1. はじめに&lt;/h3>
&lt;p>概要と同じく①から⑥を順番に並べることで案を作ることができる。
ここでは、パラグラフのトピックセンテンスが論文ストラクチャーの各項目になるように配置し、各パラグラフに説明とリファレンスを追加していくと良い。&lt;/p>
&lt;h3 id="2-関連研究">2. 関連研究&lt;/h3>
&lt;p>③の各課題を単位とする節やパラグラフを並べることで案を作ることができる。
ここでは、各課題がなぜ発生するのか、解決できていないのかを説明するために、従来手法の説明を加えるのが一般的である。&lt;/p>
&lt;h3 id="3-提案手法">3. 提案手法&lt;/h3>
&lt;p>④の各手法を単位とする節やパラグラフを並べることで案を作ることができる。
ここでは、③との対応づけが明らかになるようにできるだけ順序を維持し、また対応する課題について明記すべきである。
また、⑤を用いて提案手法全体の概要と達成できる事柄について導入部分で触れておくと良い。&lt;/p>
&lt;h3 id="4-評価">4. 評価&lt;/h3>
&lt;p>⑥の各評価を単位とする節やパラグラフを並べることで案を作ることができる。
ここでも、③や④との対応づけが明らかになるようにできるだけ順序を維持し、また対応する課題、手法について明記すべきである。&lt;/p>
&lt;h3 id="5-まとめ">5. まとめ&lt;/h3>
&lt;p>②と⑤からリサーチクエスチョンとこれに対する提案をまとめる。
また、⑥の結果を踏まえ解決した③を明記する。
最後に研究を発展させるための今後の予定を述べる。&lt;/p>
&lt;h1 id="おわりに">おわりに&lt;/h1>
&lt;p>本エントリでは、抜け漏れがなく主張点が明確な論文執筆のために、論文執筆の複雑なタスクを分離し、主張の構造を見出だすタスクと、この構造を文章に落とし込むタスクという二つのタスクを交互に行う方式を提案した。
また、このために論文ストラクチャーと名付けた主張の構造の整理に適した表現形式を提案した。&lt;/p>
&lt;p>提案手法によって、論文の品質を一定に保ちつつ初稿までの執筆時間を短縮する。
加えて、論文ストラクチャーを通した研究成果共有によって共著者との早期の意思疎通が容易になり、手戻りを防ぐ効果が期待できる。&lt;/p>
&lt;p>あとは良い研究をするだけである（それもまた難しいのであった）。&lt;/p>
&lt;hr>
&lt;h3 id="参照">参照&lt;/h3>
&lt;ul>
&lt;li>*1: 松本 亮介, 近藤 宇智朗, 三宅 悠介, 力武 健次, 栗林 健太郎, FastContainer: 実行環境の変化に素早く適応できる恒常性を持つシステムアーキテクチャ, インターネットと運用技術シンポジウム2017論文集，2017，89-97（2017-11-30）, Nov 2017&lt;/li>
&lt;li>*2: 三宅 悠介, 峯 恒憲, Synapse: 文脈に応じて継続的に推薦手法の選択を最適化する推薦システム, 電子情報通信学会論文誌D, Vol.J103-D,No.11,pp.-,Nov. 2020. (to appear)&lt;/li>
&lt;/ul></description></item><item><title>九州大学大学院システム情報科学府博士後期課程に入学します</title><link>https://blog.monochromegane.com/blog/2020/09/21/isee-kyushu-u/</link><pubDate>Mon, 21 Sep 2020 12:38:52 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/09/21/isee-kyushu-u/</guid><description>&lt;p>先日8/7、九州大学大学院システム情報科学府博士後期課程に無事合格しました。
10/1より入学します。
専攻は情報知能工学[*1]です。&lt;/p>
&lt;p>39歳、文系学士から修士を飛ばして理系の博士課程への挑戦となった経緯や入試に向けた準備などまとめます。&lt;/p>
&lt;h2 id="略歴">略歴&lt;/h2>
&lt;p>大学では環境政策を学びましたが、工学的なアプローチの解決手法の方に興味を持ち、いろいろあってソフトウェアを扱える仕事につきました。
2012年に転職し、現職のGMOペパボでインターネットサービスのWebアプリケーションの開発・運用維持業務に携わってきました。
2017年より同社の研究職として情報システムの自律適応等の研究に従事しています。&lt;/p>
&lt;h2 id="研究員になった理由">研究員になった理由&lt;/h2>
&lt;p>サービスの運用開発の傍ら、&lt;a href="https://speakerdeck.com/monochromegane/pepabo-log-infrastructure-bigfoot">ログ活用基盤の構築&lt;/a>に取り組み、サービスを動的に改善していくための仕組みづくりと機械学習に興味を持ち始めたところ、その前年に設立した&lt;a href="https://rand.pepabo.com/">ペパボ研究所&lt;/a>でやってみませんかと&lt;a href="https://kentarokuribayashi.com/">@antipop所長&lt;/a>に誘われました。&lt;/p>
&lt;p>当時、ソフトウェア開発という非常に強力で柔軟な相棒を得て、OSSを楽しく量産する一方で、独学でやってきたこともあり、解決できる課題規模やアルゴリズムなど実装力に関する頭打ちを感じていました。
そんな折、コンピュータサイエンスや研究的なアプローチを学ぶことでここを突破できるのはないかと思えるこの誘いは非常に魅力的でした。&lt;/p>
&lt;p>完全に未知の職種であること、天職だと思っていたエンジニアからの職種転換ということなど、悩む部分は正直多かったですが、所長との面談の中で「今までやっていることに論文書くのが加わるだけです」と後押しされ、その日のうちに決めました。（今思えば論文として研究をまとめるそれが一番難しいじゃ〜〜という気持ちでいっぱいですが興味があればやってみましょうと後押ししてくれたんだと思ってます）&lt;/p>
&lt;p>実際に、今進めている研究も、インターネットサービスの運用維持の中で発生する課題を、研究というアプローチを用いて解決、サービスへ還元するという、エンジニアリングに研究が加わった方式で進めており、これまでのスキルも十分に活かしながら、研究観点での新規性・有効性・信頼性を追求することができています。&lt;/p>
&lt;h2 id="博士後期課程に入学した理由大学の選定理由">博士後期課程に入学した理由（大学の選定理由）&lt;/h2>
&lt;p>自身の研究の発展はもちろんのこと、研究を推し進めていく力を高めたいと考え、博士後期課程へ挑戦しました。&lt;/p>
&lt;p>僕の3年間の研究への取り組みは全く順調ではなく、研究活動もテーマも解決手段も評価も論文執筆も暗中模索で、そのくせいつの間にか年齢と共に大きくなっていた自意識が、光となるはずの先達からのアドバイスも歪めてしまっていました。
結果として、&lt;a href="https://blog.monochromegane.com/blog/2017/12/31/2017/">最初の2年ほどは迷走&lt;/a>しており、研究所の皆さんには迷惑をかけてしまいました。&lt;/p>
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/">今年の6月に初めてジャーナルの採録通知をもらい&lt;/a>、研究者としての一歩を踏み出したものの、研究への取り組み方はまだまだ下手くそだなあと自分自身考えています。
具体的には、課題解決だけでなく、問題自体への向き合う時間を見直していく必要がありそうです。
過去の迷走の中で、かろうじて掴んだことは、「研究とは、ある問題設定に対する解釈を深めることであり、その問題設定に対して向き合った量が結果につながる（のではないか）」というものでした。
何が課題なのか、どういう世界があるべきなのか、これらは瞬時に明確になるものではなく、試行錯誤やアウトプットとフィードバックによって徐々に練られていく問いですが、この工程を避けてしまうと小手先や思いつきの対策に留まる、もしくは不要に複雑なだけの解法の適用に陥ってしまいます。
周りを見ても、良い研究だなあと思うものは、課題そのものを高度に解決するのはもちろんのこと、問題設定自体にきちんと向き合うことで、研究の位置付けを明確にし、提案手法の汎用性を高めているものがたくさんあります。
特に、モノの見方自体を少しでも変えるような問題設定に昇華した研究には尊敬すら覚えます。
博士後期課程では、自分の研究というものを確立する過程を通して、世界をよくするような研究を推し進める力を高められたらと考えています。&lt;/p>
&lt;p>10月より指導いただく峯先生とは、幸い、既に共著で論文執筆する機会があり、専門性の観点だけでなく、研究の課題や貢献に対する気づきを多数アドバイスいただき、この面でも学ぶことができると考えています。
また、通学が可能な範囲、学費の面での国公立の大学という諸条件も九州大学は満たしており、受験を決めました。&lt;/p>
&lt;h2 id="博士後期課程に向けての準備など">博士後期課程に向けての準備など&lt;/h2>
&lt;p>九州大学大学院システム情報科学府では、社会人特別選抜試験が用意されており、こちらを受験することとなりました。
前提として指導教官との受け入れに関する合意が必要ですが、僕の場合、幸い、既に先生と共著で論文執筆する機会があり、その繋がりで指導についてお願いすることができました。&lt;/p>
&lt;p>出願について、学士である僕は、修士相当の学力を持つという出願資格を認めてもらうため、事前審査が必要でした。
そのため、以下の出願資格を満たすことを証明する内容と研究実績を事前に提出しています。&lt;/p>
&lt;blockquote>
&lt;p>(7) 文部科学大臣の指定した者
A) 大学を卒業し，大学，研究所等において，２年以上研究に従事した者で，本学府において，当
該研究の成果等により，修士の学位を有する者と同等以上の学力があると認めた者&lt;/p>
&lt;/blockquote>
&lt;p>事前審査のため、通常の出願スケジュールより前倒しで各種書類なども合わせて準備する必要があります。
僕の場合、2020年10月入学の入試に向けて、5月下旬が事前審査の書類提出でしたので4月下旬ごろから関係書類を集めていたようです。
ここで落ちるようなら、修士から臨もうと考えていましたが、幸いにも出願資格を認めてもらうことができました。
もしかしたらここが一番緊張したかもしれません。&lt;/p>
&lt;p>2020年10月入学の入学試験は、口頭試問でした。
これまでの研究実績と博士課程での研究計画に関して発表し、質疑応答という形式です。
限られた時間で3年間の研究実績と研究計画に触れなければならず、羅列ではなくストーリーの中での位置付けと重要な部分の抜粋が必要となり、資料の作成には苦労しました。
それでも、資料作成を通して研究テーマや位置付けの整理が一段階進み、結果として自分の研究とこれからを見直す良い機会になったなあと思います。
せっかくなので公開可能な範囲で資料を公開しておきます。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>試験を終えた感想としては、事前審査にしろ口頭試問にしろ、そのために慌てて頑張って準備が間に合うようなものではなく、きちんとこれまで積み重ねてきた実績やその課題設定に向き合ってきた量というのが試されたんだろうなあと思います。
なお、完全に余談ですが、マスクをつけて30分程度の発表と質疑応答は酸欠で倒れそうになったので、今後もこのような状況が続くようであればフェイスマスクのような呼吸が楽な装備をお勧めします。&lt;/p>
&lt;h2 id="会社の支援">会社の支援&lt;/h2>
&lt;p>10月より社会人博士課程に挑むことになりますが、所属する研究所において、業務との両立について理解をいただけています。
特に、博士課程の研究テーマにサービスの改善に適用可能なものを選択したことが理解を得やすかった点だと思います。&lt;/p>
&lt;h2 id="これから">これから&lt;/h2>
&lt;p>研究としては、今取り組んでいる推薦システムの自律適応について発展させていきたいと考えています。
&lt;a href="https://www.isee.kyushu-u.ac.jp/internal/isee_tebiki.html">シラバス&lt;/a>を見る限り、博士論文に向けて色々指導の時間（指導教官以外の取り組む研究テーマの分野ごとの研究指導や関連研究調査など）があるようで、研究そのものの発展はもちろんのこと目的としている研究力の向上も図れるのではないかなと、今から楽しみです。&lt;/p>
&lt;hr>
&lt;ul>
&lt;li>[*1] 2021年度より「情報知能工学専攻」は「情報理工学専攻」に&lt;a href="http://www.isee.kyushu-u.ac.jp/reorganization.html">改組されるとのこと&lt;/a>です。&lt;/li>
&lt;/ul></description></item><item><title>ペパ研から研究をはじめてジャーナルでのアクセプトまでいけた日</title><link>https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/</link><pubDate>Sun, 28 Jun 2020 13:00:48 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/</guid><description>&lt;p>先週の6/22、初めてジャーナルの採録通知をいただいた。&lt;/p>
&lt;p>大学は情報系ではなく、大学院にも行っていないので、研究なるものを始めたのが、&lt;a href="https://rand.pepabo.com/">ペパボ研究所&lt;/a>に入った2017年1月から。3年半もかかってしまった。&lt;/p>
&lt;p>元々、サービスの運用開発をしていた経緯もあり、2017年の前半はその延長で研究報告を2本書き切った。
初めての研究報告は、論文の型みたいなのを徹底的に教えてもらえた。
今も執筆時に気をつけるところのほとんどはここで教えてもらったことが根底にあると思う。
2017年の後半から、研究の内容自体も「すごいもの」にしようとした結果、迷走が始まる。
自分のやってきたことを深堀するわけでもなく、先達の研究を調べるわけでもなく、自分の能力を高めるわけでもなく、ただ、目新しいことに挑んでは当然のように跳ね返され、焦りから近道を探し、悪循環に陥る。
研究所内で、（今にして思えばほぼ八つ当たりな）相談したり、WSA研でいろいろな人の研究に対する考え方を聞きながら、自分の中の蓄積や道標をきちんと整備していかなければと考えるようになった。&lt;/p>
&lt;p>2018年は、アドバイス制度を利用して初めてジャーナル投稿に挑戦した。
当時としては全力で取り組んだ論文はあらゆる直接的間接的な表現で「よくわからないです」とアドバイスをいただき、心砕け撃沈した。
まだまだ付け焼き刃な研究は、専門性に対する脆い知識や理論構成であり、指摘に対して一気に瓦解する。
やれることは、専門性を高めることだけなのだが、分野のあまりの広さ・難しさに途方に暮れていた。
この時期は、指摘をまだアドバイスと見なすことができず辛い時期であった。&lt;/p>
&lt;p>2019年の前半は、転換の兆しが見えたが苦しい時期でもあった。
わからないなりに勉強を続け、サーベイを進めた。
自分なりの方向性を見つけ、評価し、効果がある研究ができた。
それでも相変わらず研究報告を上手く書けない。
文章として形が見えていく中で、新しい前提や課題が明らかになり、議論は活発になる。
当たり前のことであり、むしろ喜ばしいことであるのだが、どこかで形を決めなければならない。
この時期は、これは、もっといけるはずだという期待に応えたい気持ちとそれを時間内に解決できない自分の無力感で悪循環に陥ることが多かったのではないかと思う。
そして、この時期の振り返りで、自分と向き合った結果、「結局は、無能だと判断されたくないだとか、集中することができれば大きな成果を出せるはずだとか、心の奥底に対外的な評価が中心に据えられて、自己評価とのギャップと相まって動けなくなっていたことが原因だと思い至」った。&lt;/p>
&lt;p>2019年の後半、これを踏まえ冷静になりつつ、いろいろな人に助力をいただきながら、前に進んだ。
学術系ではないがGo言語の国際カンファレンスのトークセッションに採択された。
ポスターセッションではあるものの学術系では初めて査読ありセッションで採択された。
ジャーナルへももう一度挑戦した。結果はリジェクトであったが、査読者の判定は、条件付き採録と不採録で別れ、メタ査読者からは前半（研究の前提や既存研究に対する位置づけ）は非常に読みやすいとのコメントをいただけた。
後半の提案手法やその評価について、アーキテクチャ含め更新、年内にまた別のジャーナルに提出へこぎつけた。&lt;/p>
&lt;p>2020年、3月にその論文が条件付き採録となり、これに応えて晴れて採録通知を受けたのが先週。
「ペパ研から研究をはじめてジャーナルでのアクセプトまでいけた日」は研究所の所長が言ってくれた。
本当にそうだなあとこれまでのことを思い返して、泣けた。
今にして思えば遠回りばかりして、勝手に袋小路に迷い込んで非効率極まりない反面教師の塊だと思うけれどもこの過程と振り返りがなければ、今の研究もできていないだろうし小さな人間のままだったかもしれない。
これからまた難航することがあるかもしれないが、今はこの経験が今度は乗り切れるのではないかと思わせてくれる。
なんにせよ、自分のような人間が、ジャーナルを通せるところまでたどり着くことができたのは、ひとえに見捨てずに見守りアドバイスをくれ、相談に乗ってくれる周りの方々のおかげです。
遠回りばかりしていますが、これから、改めて巨人の肩に乗ることから逃げずに真摯に向き合い一歩づつ精進していこうと思います。&lt;/p>
&lt;hr>
&lt;p>今年は他にも、研究チームとしての側面も取り組んで、研究報告ではあるが、はじめて2本ラストオーサーを務めた。
研究所での論文読みや勉強会などの新しい習慣も定着し、今後が楽しみ。
また、自身の研究も前進させ、ジャーナルのアドバイスもうまく取り込めていると思う。
国際会議なども狙っていきたい。
そして、博士課程に挑戦することにした。
まだ結果はわからないが、これまで模索してきた取り組みを加速できると良いなと思う。&lt;/p>
&lt;h1 id="過去の振り返り">過去の振り返り&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2017/12/31/2017/">2017年, 12月のライオン&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2018/06/30/first-half-2018/">First Half of 2018&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2018/08/16/reason/">理性の人&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2019/12/31/2019/">2019&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Go言語でシミュレーション用のシンプルなフレームワークStageをつくった</title><link>https://blog.monochromegane.com/blog/2020/05/31/simulation-framework-stage/</link><pubDate>Sun, 31 May 2020 12:16:27 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/05/31/simulation-framework-stage/</guid><description>&lt;p>時系列に対するコンピュータシミュレーションを開発する機会が増えてきたので、共通する処理の流れをフレームワーク化した。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;h2 id="コンピュータシミュレーション">コンピュータシミュレーション&lt;/h2>
&lt;p>状況に応じたクリック数の最大化や変化点検出のような、システムの適応的な振る舞いを検証するために、時系列に対するコンピュータシミュレーションを行うことがある。
また、実環境で発生するランダムな誤差を表現する場合、乱数を用いたシミュレーション技法であるモンテカルロ法も利用することになる。&lt;/p>
&lt;p>このようなシミュレーションのプログラムでは、変化する時系列を入力に、振る舞いのシミュレーション結果を出力するだけではなく、乱数によって発生する誤差を均すためにシミュレーションを数百〜数千回繰り返す必要がある。&lt;/p>
&lt;h2 id="stage">Stage&lt;/h2>
&lt;p>Stageは、これらの一連の流れの実行とこれに伴う煩雑な処理（シミュレーションの並列化、乱数の管理、進捗の監視、ログ出力）を開発者から隠蔽する。
開発者は、時系列や振る舞い、ログフォーマットをGo言語で記述するだけで良い。&lt;/p>
&lt;p>Stageで行っているメイン処理の「疑似コード」は以下の通りシンプルである。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">i&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span> &amp;lt; &lt;span style="color:#a6e22e">iter&lt;/span>; &lt;span style="color:#a6e22e">i&lt;/span>&lt;span style="color:#f92672">++&lt;/span> {
&lt;span style="color:#a6e22e">sem&lt;/span> &lt;span style="color:#f92672">&amp;lt;-&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span>{}{}
&lt;span style="color:#66d9ef">go&lt;/span> &lt;span style="color:#66d9ef">func&lt;/span>() {
&lt;span style="color:#a6e22e">scenario&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewScenarioFn&lt;/span>(&lt;span style="color:#a6e22e">rnd&lt;/span>.&lt;span style="color:#a6e22e">Int63&lt;/span>())
&lt;span style="color:#a6e22e">actor&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">NewActorFn&lt;/span>(&lt;span style="color:#a6e22e">rnd&lt;/span>.&lt;span style="color:#a6e22e">Int63&lt;/span>())
&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">scenario&lt;/span>.&lt;span style="color:#a6e22e">Scan&lt;/span>() {
&lt;span style="color:#a6e22e">action&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">actor&lt;/span>.&lt;span style="color:#a6e22e">Act&lt;/span>(&lt;span style="color:#a6e22e">scenario&lt;/span>.&lt;span style="color:#a6e22e">Line&lt;/span>())
&lt;span style="color:#a6e22e">w&lt;/span>.&lt;span style="color:#a6e22e">Write&lt;/span>(&lt;span style="color:#a6e22e">action&lt;/span>.&lt;span style="color:#a6e22e">String&lt;/span>())
}
&lt;span style="color:#f92672">&amp;lt;-&lt;/span>&lt;span style="color:#a6e22e">sem&lt;/span>
}()
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>このフレームワークでは、メタファーとして劇場(Stage)を採用した。
劇場は、劇を開催する。
その劇は台本(Scenario)があり、演者(Actor)は台本の1行づつのセリフ(Line)に沿って演技を行い、結果(Action)を出力する、といった形だ。
そして劇は何度も繰り返される。&lt;/p>
&lt;p>開発者は、時系列や振る舞いをそれぞれ、ScenarioとActorのinterfaceを実装によって記述する。
また、ログフォーマットもAction interfaceで指定するだけで良い。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Scenario&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Scan&lt;/span>() &lt;span style="color:#66d9ef">bool&lt;/span>
&lt;span style="color:#a6e22e">Line&lt;/span>() &lt;span style="color:#a6e22e">Line&lt;/span>
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Actor&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">Act&lt;/span>(&lt;span style="color:#a6e22e">Line&lt;/span>) (&lt;span style="color:#a6e22e">Action&lt;/span>, &lt;span style="color:#66d9ef">error&lt;/span>)
}
&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Action&lt;/span> &lt;span style="color:#66d9ef">interface&lt;/span> {
&lt;span style="color:#a6e22e">String&lt;/span>() &lt;span style="color:#66d9ef">string&lt;/span>
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとは実装したScenarioとActorを生成する関数を指定して必要な回数実行。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">dir&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;log&amp;#34;&lt;/span> &lt;span style="color:#75715e">// Directory for output
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">concurrency&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">runtime&lt;/span>.&lt;span style="color:#a6e22e">NumCPU&lt;/span>() &lt;span style="color:#75715e">// Number of concurrency for scenario
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">seed&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#75715e">// Seed for random
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">iter&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">3&lt;/span> &lt;span style="color:#75715e">// Number of iteration
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#a6e22e">s&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">stage&lt;/span>.&lt;span style="color:#a6e22e">New&lt;/span>(&lt;span style="color:#a6e22e">dir&lt;/span>, &lt;span style="color:#a6e22e">concurrency&lt;/span>, &lt;span style="color:#a6e22e">seed&lt;/span>)
&lt;span style="color:#a6e22e">s&lt;/span>.&lt;span style="color:#a6e22e">Run&lt;/span>(&lt;span style="color:#a6e22e">iter&lt;/span>, &lt;span style="color:#a6e22e">NewActorFn&lt;/span>, &lt;span style="color:#a6e22e">NewScenarioFn&lt;/span>, &lt;span style="color:#a6e22e">stage&lt;/span>.&lt;span style="color:#a6e22e">NoOpeCallbackFn&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>結果は、指定したログディレクトに出力され、実行日時や利用した乱数シードも確認することができる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">log
└── 20200530184234-1 &lt;span style="color:#75715e"># Timestamp-Seed&lt;/span>
├── iter_00-a_7947919477105006377-s_5355116748216652230.log &lt;span style="color:#75715e"># Iteration log files&lt;/span>
├── iter_01-a_4846631296614585111-s_2007235010091403794.log &lt;span style="color:#75715e"># with seed for actor(a)&lt;/span>
└── iter_02-a_0610076349056253918-s_3540139325796113853.log &lt;span style="color:#75715e"># and seed for scenario(s)&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>なお、出力後の解析、グラフ出力については、Stageでは取り扱わない。
任意のフォーマットで出力できるのでお好みの言語やツールで操作して欲しい。&lt;/p>
&lt;p>各インターフェースの具体的な実装方法については&lt;a href="https://github.com/monochromegane/stage/blob/master/README.md">README&lt;/a>を参照のこと。&lt;/p>
&lt;h2 id="複数のシナリオを持つシミュレーション例">複数のシナリオを持つシミュレーション例&lt;/h2>
&lt;p>例えば、以下の青線のような変化の仕方が異なるシナリオを切り替えて、橙の線のような振る舞いの違いをシミュレーションすることができる。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Abrupt changes&lt;/th>
&lt;th>Gradual changes&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;img src="https://user-images.githubusercontent.com/1845486/83343338-f8bcbe00-a333-11ea-983b-81ba9a6f8b08.png" alt="example_adwin_abrupt">&lt;/td>
&lt;td>&lt;img src="https://user-images.githubusercontent.com/1845486/83343344-10944200-a334-11ea-9364-b4d4cedcdff6.png" alt="example_adwin_gradual">&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;a href="https://github.com/monochromegane/stage/tree/master/_examples/adwin">複数シナリオの実装例&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="長時間かかるシミュレーション例">長時間かかるシミュレーション例&lt;/h2>
&lt;p>また、シミュレーションに時間がかかる場合は、各シナリオの完了時に呼ばれるCallback関数を指定することで、進捗の監視もできる。
お好みのProgress barライブラリを使えば進捗バーも表示できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ go run _examples/progress/main.go
&lt;span style="color:#ae81ff">180&lt;/span> / &lt;span style="color:#ae81ff">200&lt;/span> &lt;span style="color:#f92672">[&lt;/span>----------------------------&amp;gt;___&lt;span style="color:#f92672">]&lt;/span> 90.00% &lt;span style="color:#ae81ff">40&lt;/span> p/s
&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;a href="https://github.com/monochromegane/stage/tree/master/_examples/progress">プログレスバーの実装例&lt;/a>&lt;/li>
&lt;/ul>
&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>普段よりアルゴリズムの理解を深めるため手に馴染んだGo言語で実装を試みるので、必然的にシミュレーションもGoで書くことが多くなったことからGo言語での実装となった。
完全に自分用途でつくったフレームワークではあるが、各シミュレーションにおいてシナリオとアクターという要素のみを意識すればよくなり実装の効率が格段に上がりコードの見通しもよくなった。
また、Go言語を使うことで並列化が容易に実装できシンプルなフレームワークでありながら十分に安定して高速化を達成できていると思う。
付加的な利点として、ログ構成などが統一されたことで後段の解析やグラフ化のスクリプトも共通化が進んでおり、個人的に満足度が高いものができたと思う。&lt;/p></description></item></channel></rss>