<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>hugo on THINKING MEGANE</title><link>https://blog.monochromegane.com/tags/hugo/</link><description>Recent content in hugo on THINKING MEGANE</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><lastBuildDate>Sat, 18 Jul 2015 11:07:01 +0900</lastBuildDate><atom:link href="/tags/hugo/" rel="self" type="application/rss+xml"/><item><title>みんなと仲良くすること</title><link>https://blog.monochromegane.com/blog/2024/12/23/nakayoku/</link><pubDate>Mon, 23 Dec 2024 10:36:20 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2024/12/23/nakayoku/</guid><description>&lt;p>ここ数ヶ月、思うように成果が出なかったことに対するボスからのフィードバックを中心に自分なりに来年の仕事の指針としてまとめておく。&lt;/p>
&lt;p>多くの事業では、環境の変化へ追従するためにプロジェクトの優先順位は目まぐるしく整理・最適化されていく。
また、近年では、データ駆動な意思決定、機械学習やAIのような新しい自動化の導入によって、事業に求められる水準も高度化している。
このような質・量ともに認知負荷の高い状況に対処するため、専門性を高めた分業やチーム体制が出来上がるのは必然である。
しかしながら、例え、各々が目的やビジョンを揃えていたとしても、皆が足並みを揃えて進むことは存外に難しい。
この要因として、分業した専門の観点ごとにゴールまでの過程における課題の内容や具体度が異なることが考えられる。
描く経路が異なれば、当然、足並みが揃うことはない。&lt;/p>
&lt;p>よって、ある程度以上の規模や難易度の仕事を成功させるなら、関わる人々の間での関心度を高めないといけない。
しかし、分業による過程のカプセル化と無関心は紙一重である。
せっかく認知負荷を下げることができたのだから、わざわざ相手の事情を汲むような工程を挟まずに、阿吽の呼吸で足並みを揃えて進んでほしいと思いたくもなる。
それでもやはり、関わる範囲が広範囲だったり内容が高度になるに伴い、表面上の理解や想像による補完では立ち行かなくなってしまう。
だからこそ、互いの専門領域の広さと難しさを前提とし、労力を払って関心を維持することが仕事を成功させるために必要になってくる。&lt;/p>
&lt;p>もちろん、全体としてのコミュニケーションコストを低減させるため、各々の専門領域に照らした道程について、聞き手に応じた表現で過不足なく効率的に伝えることが求められる。
そのために、伝えたいことを抽象的な概念上の枠組みに変換し、効率的に伝えるために図解をはじめとした表現方法を駆使するスキルが求められる。
発信側の労力も抑えるため、この実現にはAIも積極的に活用し、聞き手に応じたバリエーション生成まで即時に行える仕組みも構築したい。
また、関心は関係する人々がそれぞれ双方向に接続されている状態が望ましいが、返報性の原理を期待して、まずは制御可能な自身から関心を維持することを始めるのが良いだろう。&lt;/p>
&lt;p>ペパボで大切にしている三つのことのうち一つに「みんなと仲良くすること」というものがある。
これを表面上の摩擦がない状態と捉えてしまうと無関心に通じてしまうので、仕事の達成を念頭において、伝えるべきことをしっかり伝えるというのが、自身のこれまでの理解であった。
ただ、これも一方向のコミュニケーションに過ぎず、ある種の無関心とも言えるのではないかと考え直したのが今回である。
今後は、仕事を達成するため、もう一段階踏み込んだ「みんなと仲良くすること」を常に意識的に実施していきたい。
そうすることで、無関心による安易な想像に起因する問題を回避したり、問題が生じたとしても、なぜ齟齬が発生しているのかを構造ベースで捉えて建設的に解決に進めることができると思う。&lt;/p>
&lt;hr>
&lt;p>実際はフィードバックは以下のように端的にまとめてくれていたのだが、自分なりの解釈に落とし込むために書いてみました。これぐらいズバッとまとめられるようになりたい。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2024/12/boss.png" alt="feedback">&lt;/p></description></item><item><title>ペパボに入って12年が経った。気付けば博士になっていた</title><link>https://blog.monochromegane.com/blog/2024/10/05/doctor-information-science/</link><pubDate>Sat, 05 Oct 2024 09:58:42 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2024/10/05/doctor-information-science/</guid><description>&lt;p>先月、博士（情報科学）の学位を取得した。&lt;/p>
&lt;p>12年前、&lt;code>福岡 おもしろい it 会社&lt;/code>と検索をして、株式会社paperboy&amp;amp;co.（現GMOペパボ株式会社）に運用開発エンジニアとして転職した時&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>からすると、予想だにしなかった状態である。
転機は2017年1月だった。
ペパボで切磋琢磨できる仲間に恵まれ、OSS活動や登壇を通したアウトプット、社内での成果を自負する一方で、社内でもレベルの高いエンジニアとの仕事の機会を通して、自分の限界も感じ始めていた。
そんな折、研究所の所長から研究職への打診があった。
確か、当時進めていたログ活用基盤の構築とその内容の研究所のコンセプトへの親和性からだったように記憶している。
感じていた限界を「コンピュータサイエンス」ってやつや「研究的アプローチ」ってやつで突破できるかもしれない、研究って何もわからないけれども何とかなるだろう、渡りに船だとばかりにこの誘いに乗ることにした。&lt;/p>
&lt;p>結果、丸々二年間、滑稽なぐらい迷走した&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。
「研究」をするぞと意気込みは空回りし、研究所の同僚からのアドバイスも虚しく、納得する成果を出せずに時間だけが過ぎ、短時間で効果が出るものを求め悪循環が始まった。
元来の己の精神的な弱さ、四十歳前後という年齢特有の焦り、人生最高潮に達したあらゆるものに対する固執が目を曇らせ、足を引っ張った。
長く暗い時期だったが、ほんとうにほんとうにありがたいことに、さまざまな人に支えられ、何度も内省を進めることでかろうじて持ち直していった。
研究所の同僚、エンジニアと研究者が集うWSA研&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>、研究者の先輩方、そして家族には感謝の念が尽きることはない。
それでも距離をおくことを選択した縁もあり、たくさん迷惑をかけてしまった。&lt;/p>
&lt;p>「研究」は難しい。
これは高度という意味での難しさではなく、ソフトウェアによる課題解決とは目的が違うことに起因する難しさについてである。
博士課程を終えて、研究とは「人類が新たに学べる領域を作り出すこと」であると考えるようになった。
すなわち、ソフトウェアによる課題解決は、目的に連なる目標のうちの一つであり、その解決も含めて、新たに学べる状態に仕上げねばならない。
そして、後進が学べる状態であるには、どこがこれまでの方法と異なるのか、どれぐらいの効果があるのか、それらが主張とその裏付けという形で明確に述べられたかといった要件に落とし込まれる。
これは、論文における「新規性」「有用性」「了解性」の観点に対応し、論文を記述する際には、これらの観点を満たすための様々なサーベイやライティング手法を駆使して臨むことになる。
そのような過程を経ることで初めてそのアウトプットは、未来の誰かの手による学べる領域の更なる拡大を支えていくことができる。
落とし穴は、ソフトウェアによる課題解決を目標ではなく目的に据えてしまうことである。
ここに陥ると、課題の解決こそが研究であり、課題解決のみで研究であるためには、大層な水準の課題を解決せねばならないとなりかねない。
自分が最初に躓いたのはここではないかと思う。&lt;/p>
&lt;p>この頃の自身の振り返りを読むと、感情との付き合い方&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>の他に、研究とは何かを手探りで模索している様子が見て取れる&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup> &lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup> &lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>。
解決したことを伝えていかないといけないのだな、そのためにはたくさんの根拠を示さないといけないのだな、だから一朝一夕じゃ無理で時間をかけて向き合うことが必要なんだな、程度の理解度ではあるものの、この辺りから前に進み出したのだろうと思う。
2020年6月に初めてジャーナルの採録通知を受け取り&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>、10月には社会人学生として九州大学大学院システム情報科学府博士後期課程へ社会人学生として進学した&lt;sup id="fnref:9">&lt;a href="#fn:9" class="footnote-ref" role="doc-noteref">9&lt;/a>&lt;/sup>。
進学の後押しも研究所の所長だったと思う。
これまでの経緯もあり、及び腰だった自分に「研究職続けるなら博士号はあった方がいいし、いずれは取るのだから最短で効果が出せることをやったらいいんじゃないですか」と言われ、それもそうだなと挑戦を決めた。
暗中模索の中でも進めていた十本弱の研究報告やジャーナルの実績をもって修士を飛ばしての出願と入学が認められたこともあり、積み重ねは無駄じゃなかったなあ、ようしやるぞとここからは順風満帆。
といかないのがいかにも自分らしくて思い出しても苦笑してしまうのだが。&lt;/p>
&lt;p>博士課程の修了には一定数の実績が必要となる。
自分の場合は、在学中に国内ジャーナル論文をもう一本、一定水準以上の国際会議での採択が一回が最低基準であった。
国内ジャーナルこそなんとか通せたものの、国際会議については、2021年5月の初投稿から丸二年、七回目の挑戦にしてようやくの採択となり長い我慢の時期を過ごした&lt;sup id="fnref:10">&lt;a href="#fn:10" class="footnote-ref" role="doc-noteref">10&lt;/a>&lt;/sup>。
そんな中、指導教官は一貫して、研究という最短ルートはない道程において、同じ道を回ることなく、常に何かしらの前進という成果を得るためのアドバイスを与えてくれたと思う。
それは例えば「難しいものと認識した上でそれに挑戦する喜び」であったり「ダメだった場合は改善してただ次に行くだけ」であったり、「自分で決めて悔いのないように進む」こと、そして「結果に対して本質的な面白さを見出して言語化し、これまでの取り組みと有機的に関連づけていくこと」などである。
博士課程という自分の研究の型を体得していく中で、指導教官の存在は本当にありがたいものであった。
指導教官は、分野の専門性が重なっていることが望ましいが、それ以上に相性があると思うので、できれば共著を先に一度執筆するなどコミュニケーションを取れると良いと思う。
幸い、自分の場合は、進学前の共同研究の際に知り合うことができたのでこの点でも恵まれていたと思う。&lt;/p>
&lt;p>とはいえ、博士課程は、自身で主体的に研究を推進しなければならない。
これは、博士課程が「人類が新たに学べる領域を作り出すこと」という研究を達成する、「その方法論を、特定の研究テーマに基づく実践を通して身につける課程」だからだと思われる。
新たに学べる領域を作り上げているのであるから、指導教官にとってもわからない部分を切り開いていくのであり、そしてその開拓の方法は、自身でやり方を模索していかなければならない。
主体性については、能動的に動くことが前提の社会人であれば特段問題にならないかと思う。
博士課程での大変さは、この研究を推し進めるやり方の模索に対するフィードバックが、アウトプットに対してのみ得られるという点だったと思う。
それは主に査読結果や、国際会議での発表に対する議論の形を取るが、いずれにせよ論文の形にまとめる必要がある。
これは研究を学ぶには研究をしなければならないという構造であり、研究テーマ自体も発展させなければならないことも相まって、随分鍛えられたと感じている。
幸い、指導教官のアドバイスはこれに即したものであり、博士論文に着手する前の三年間で研究報告や不採択のものも含めると十六本、おおよそ二、三ヶ月に一本は何かしら研究成果を出して論文執筆していたことになる。
成長が遅いのは仕方ないとはいえ、研究開発員として、事業への貢献も求められる中でも諦めずに課程を継続したことは自分を褒めてあげたい。&lt;/p>
&lt;p>2024年4月には、追加でもう一つ国際会議に採択され、最終的に、入学前のジャーナル論文と合わせて計四本の実績をもとに、学位申請のための博士論文を執筆した&lt;sup id="fnref:11">&lt;a href="#fn:11" class="footnote-ref" role="doc-noteref">11&lt;/a>&lt;/sup>。
博論の執筆では、これまでの実績を「人類が新たに学べる領域」として再構成する。
四本の論文の整合性を取りながら、領域の世界観の確立も必要で、非常に難易度の高い執筆であり、実績達成以上にまだ大変な工程が残っているのかと驚いた。
しかしながら、この工程を通して初めて、ボトムアップな進め方であった自身の研究テーマに対し、トップダウンからの位置付けを与えることができたように思える。
実際に、自身の研究観である「人類が新たに学べる領域を作り出すこと」というのもこの段階を経て感じるようになった。
これまで各論文においても「新規性」「有用性」「了解性」の観点を満たせるよう突き詰めてきたが、複数論文をまとめる中で、それぞれの点が関連し、補い合う形で（まだ非常に狭いながら）初めて領域として形をなしていったように思う。
なお、世界観の確立については、ペパボ研究所のコンセプトである「なめらかなシステム」についての、所長との数年間に渡るディスカッションが非常に役立った。
このようなハイコンセプトな思考だけでなく実践的にも抽象的にも自在に観点を行き来しながら多面的に研究を見直す機会があるのがペパボ研究所の長所だと思う。
博士課程を考えている方はぜひ検討してほしい。
その後、公聴会を経て、2024年9月25日付けで博士（情報科学）の学位を授与された。
在学は四年間。
標準年度の三年には間に合わなかったが、なんとか修了に漕ぎ着けることができて安堵している。&lt;/p>
&lt;p>さて、ここまでして博士課程を終了する必要はあったのか。そしてこれからも研究をする必要はあるのか。
サンクコストを差し引いたとしても、自分自身としては「はい」と答えたい。
「課題解決」と「研究（新たに学べる領域を作り出すこと）」は相補的な関係であり、それぞれの存在がお互いを必要としていると思う。
また、特にソフトウェアやエンジニアリングの分野においては、それぞれは明確に分離している訳でもないと思う。
研究的なアプローチによって、同じ課題に対しても体系化・一般化・言語化・比較整理などを通して、多面的に捉え直し、新しい観点からちょっと面白い発想が出るかもしれない。
研究による成果物によって、ある課題に対してある状況において有用な方式を広く適用できるかもしれない。
その方式がうまくいかない場合も、理論的な裏付けもしくは再現可能な部分評価を元に、そこから学んで最短で適用できる改善を思いつけるかもしれない。
学べる状態にするのは手間がかかる。
それでもどこかの誰かの巨人の肩になるのだと信じて、研究というのを仕事にする人がいても良いのではないかと思う。&lt;/p>
&lt;p>もちろん、企業研究所に所属する研究員としては、より実践的に、博士課程で得たスキルを早速活用していきたい。
改めて、博士号を取得したということは、不確実で混沌とした課題領域においても、比較・体系化・言語化を通して、誰もがその課題を共有し、時間をかけることなく効果のある対策を講じられる基盤を整えられるスキルを持つ、すなわち、学べる領域を作り出せる人材であることが期待されるようになったのだと思う。
今後は、自身の研究テーマの推進はもちろんのこと、さまざまな施策において、所属する研究所のミッションである「研究開発により『事業を差別化できる技術』を生み出す」ことができるよう、さらに精進していきたい。
そして、これまで辛抱強く支えてくれたペパボに恩返ししていきたい。&lt;/p>
&lt;p>ペパボに入社して十二年。
タイトルの「気付けば」も大袈裟ではなくて、特に研究職になってからは時間が飛ぶようにすぎていった。
それでも、いろんなことがあったけれども、誰かと比較してではなく、過去最高の自分に仕上がっているというのは四十三歳にしては悪くないのではないか。
これからも「虚仮の一念、岩をも通す」の精神で頑張っていきたい。&lt;/p>
&lt;h3 id="お知らせ">お知らせ&lt;/h3>
&lt;p>僕のキャリアを支援してくれたことからも分かるように、GMOペパボ株式会社はどうすればインターネットを面白くできるのか、これを真面目に考えてさまざまななやり方で取り組んでいます。
研究開発的なアプローチに対してでも良いですし、事業に対してでも大丈夫です。
こんなペパボに興味持たれた方、もっと雰囲気知りたい方、お気軽にお声がけください。&lt;/p>
&lt;p>&lt;a href="https://rand.pepabo.com/">ペパボ研究所&lt;/a>&lt;/p>
&lt;h3 id="参考">参考&lt;/h3>
&lt;section class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2016/10/30/5th-year-at-pepabo/">ペパボに入って4年が経った&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2017/12/31/2017/">2017年, 12月のライオン&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3" role="doc-endnote">
&lt;p>&lt;a href="https://websystemarchitecture.hatenablog.jp/">WSA研&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2018/08/16/reason/">理性の人&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2019/02/25/entrance-of-research/">わかるとわからないの間&lt;/a>&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2019/11/27/guidepost_for_writing_paper/">論文執筆の道しるべ&lt;/a>&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2019/12/31/2019/">2019&lt;/a>&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/">ペパ研から研究をはじめてジャーナルでのアクセプトまでいけた日&lt;/a>&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:9" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2020/09/21/isee-kyushu-u/">九州大学大学院システム情報科学府博士後期課程に入学します&lt;/a>&amp;#160;&lt;a href="#fnref:9" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:10" role="doc-endnote">
&lt;p>&lt;a href="https://blog.monochromegane.com/blog/2023/12/30/international-conference-struggles/">社会人大学院生の七転び八起き国際会議奮闘記&lt;/a>&amp;#160;&lt;a href="#fnref:10" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:11" role="doc-endnote">
&lt;p>&lt;a href="https://rand.pepabo.com/article/2024/09/25/miyakey-doctor/">博士後期課程を修了し、博士（情報科学）の学位を授与されました&lt;/a>&amp;#160;&lt;a href="#fnref:11" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/section></description></item><item><title>ターミナルフレンドリーなAIコマンド、afaを作った</title><link>https://blog.monochromegane.com/blog/2024/09/16/afa/</link><pubDate>Mon, 16 Sep 2024 10:48:05 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2024/09/16/afa/</guid><description>&lt;p>Go言語で、AIモデルに対する推論をコマンドラインで実行する&lt;a href="https://github.com/monochromegane/afa">afa&lt;/a>というツールを作りました。入出力としてテキストストリームを前提としており、パイプやリダイレクトを用いて他のコマンドと連携しやすいのが特徴です。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ echo $ERROR_MESSAGE | afa new -p &lt;span style="color:#e6db74">&amp;#34;What is happening?&amp;#34;&lt;/span> /path/to/file1 /path/to/file2
&lt;/code>&lt;/pre>&lt;/div>&lt;p>与えるプロンプトやコンテキスト情報によってAIモデルが柔軟に振る舞いを変えてくれるので、これまでの個別ツールでは対応が難しかった用途における自動化にも有用でしょう。
また、テキストストリームを扱えるリッチなTUIのコマンド&lt;a href="https://github.com/monochromegane/afa-tui">afa-tui&lt;/a>も別途提供しているので、ターミナル上でのチャットも快適です。&lt;/p>
&lt;h2 id="デモ">デモ&lt;/h2>
&lt;h3 id="リッチtuiによるチャット">リッチTUIによるチャット&lt;/h3>
&lt;p>快適なインタラクティブチャットのため、Markdownを装飾して描画しつつ、&lt;code>less&lt;/code>コマンド相当の操作感のページャーと、プロンプトの入力欄を持つViewerと連携できます。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2024/09/chat.gif" alt="Chat">&lt;/p>
&lt;h3 id="zsh-line-editorzleを用いたターミナル上でのコマンド提案">Zsh Line Editor(ZLE)を用いたターミナル上でのコマンド提案&lt;/h3>
&lt;p>ZLEと連携すれば、コマンドライン上でのプロンプトをそのまま提案されたコマンドに置き換えて実行できます。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2024/09/command_suggestion.gif" alt="Command Suggestions">&lt;/p>
&lt;h3 id="vim上でのコード提案">Vim上でのコード提案&lt;/h3>
&lt;p>Vimと連携すれば、選択範囲のコードを提案されたものに置換できます。使い慣れたエディタであればdiff表示や差分の部分反映もお手のものですね。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2024/09/code_suggestion.gif" alt="Code Suggestions">&lt;/p>
&lt;h2 id="機能一覧">機能一覧&lt;/h2>
&lt;ul>
&lt;li>ターミナルフレンドリーなAIコマンドとして機能します。&lt;/li>
&lt;li>リッチなターミナルユーザーインターフェース（TUI）を持つチャットクライアントとして機能します。&lt;/li>
&lt;li>システムとユーザーのための文脈に応じたプロンプトをテンプレートを使用してサポートします。&lt;/li>
&lt;li>プロンプト、標準入力、およびファイルパスを文脈として受け付けます。&lt;/li>
&lt;li>セッションを管理し、&lt;code>resume&lt;/code> サブコマンドを介して迅速に再開できるようにします。&lt;/li>
&lt;li>安全にエスケープされたJSONオプションで構造化された出力をサポートし、他のコマンドとの統合を容易にします。&lt;/li>
&lt;li>コアアプリケーションはサードパーティライブラリに依存せずに独立して動作します。&lt;/li>
&lt;li>AIモデルとして&lt;code>OpenAI&lt;/code>をサポートします（他のAIモデルのサポートは将来計画されています）。&lt;/li>
&lt;/ul>
&lt;p>なお、この文章は、英語で書かれたafaのREADMEのFeatures項目をコピーして、&lt;code>pbpaste | afa new -script -p &amp;quot;翻訳して&amp;quot; | pbcopy&lt;/code>で貼り付けました。便利ですね。&lt;/p>
&lt;h2 id="基本的な使い方">基本的な使い方&lt;/h2>
&lt;p>Viewerを使用しないシンプルなチャットを起動する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ afa new
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Viewerを使用してチャットを起動する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ afa new -V
&lt;/code>&lt;/pre>&lt;/div>&lt;p>コンテキスト情報を加えてチャットを起動する。コンテキスト情報には「標準入力」「プロンプトメッセージ(-pオプションによるもの)」、そして「ファイルパス」を与えることができる。
ただし、仕様上、標準入力を与えるとキーボードからの入力を継続できないため、インタラクティブなチャットはできない。この場合は、プロセス置換（&lt;code>&amp;lt;()&lt;/code>）をファイルパスとして与えることを検討されたい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ echo $ERROR_MESSAGE | afa new -p &lt;span style="color:#e6db74">&amp;#34;What is happening?&amp;#34;&lt;/span> /path/to/file1 /path/to/file2
&lt;span style="color:#75715e"># Please be cautious; when standard input is provided, interactive mode is disabled.&lt;/span>
&lt;span style="color:#75715e"># Consider using process substitution.&lt;/span>
&lt;span style="color:#75715e">#=&amp;gt; afa new -p &amp;#34;What is happening?&amp;#34; /path/to/file1 /path/to/file2 &amp;lt;( echo $ERROR_MESSAGE )&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>直近のセッションを再開する。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ afa resume
&lt;/code>&lt;/pre>&lt;/div>&lt;p>指定したセッションを再開する。なお、&lt;code>afa list&lt;/code>コマンドでセッション一覧を表示できる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#75715e"># The command `afa list` displays past sessions.&lt;/span>
$ afa source -l SESSION_NAME
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ユーザープロンプトを指定する。ユーザープロンプトは、Go言語のテンプレート形式であり、テンプレート内ではプリセットの値としてコンテキスト情報に対応する、&lt;code>Message&lt;/code>、&lt;code>MessageStdin&lt;/code>、そして &lt;code>Name&lt;/code>と&lt;code>Content&lt;/code>をメンバとする&lt;code>File&lt;/code>構造体のリストである&lt;code>Files&lt;/code>を以下のように呼べる。これにより動的なプロンプトの生成が可能となる。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#75715e"># `Message`, `MessageStdin`, and `Files` that include `File` with `Name` and `Content` members can be used in the template file.&lt;/span>
$ echo &lt;span style="color:#e6db74">&amp;#34;Please explain the following.\n{{ (index .Files 0).Content }}&amp;#34;&lt;/span> &amp;gt; CONFIG_PATH/templates/user/explain.tmpl
afa -u explain /path/to/file
&lt;/code>&lt;/pre>&lt;/div>&lt;p>スクリプトモードを指定して起動する。コマンドライン実行に適したモードのオプション設定を一括で行う&lt;code>-script&lt;/code>オプションを指定することで、他のコマンドとの連携が容易になる。具体的には&lt;code>-I=false -H=false -S=false -V=false -L=false&lt;/code>が設定される。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">pbpaste | afa new -script -p &lt;span style="color:#e6db74">&amp;#34;Transrate this&amp;#34;&lt;/span> | pbcopy
&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>OpenAI&lt;/code>の独自機能として提供される&lt;code>Structured Output&lt;/code>用のスキーマを指定できる。これは指定したJSON構造体に沿うような出力を強制する機能である。例えば、余分な説明が不要なコマンド提案などに適している。
クオート文字のエスケープを担う&lt;code>-Q&lt;/code>オプションと合わせて使うことで&lt;code>jq&lt;/code>による整形が容易になるので活用されたい。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ cat &lt;span style="color:#f92672">&amp;lt;&amp;lt;&amp;lt;&lt;/span> EOS &amp;gt; CONFIG_PATH/schemas/command_suggestion.json
&lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;object&amp;#34;&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;properties&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;suggested_command&amp;#34;&lt;/span>: &lt;span style="color:#f92672">{&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;type&amp;#34;&lt;/span>: &lt;span style="color:#e6db74">&amp;#34;string&amp;#34;&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>,
&lt;span style="color:#e6db74">&amp;#34;additionalProperties&amp;#34;&lt;/span>: false,
&lt;span style="color:#e6db74">&amp;#34;required&amp;#34;&lt;/span>: &lt;span style="color:#f92672">[&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;suggested_command&amp;#34;&lt;/span>
&lt;span style="color:#f92672">]&lt;/span>
&lt;span style="color:#f92672">}&lt;/span>
EOS
$ P&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;List Go files from the directory named &amp;#39;internal&amp;#39; and print the first line of each file.&amp;#34;&lt;/span>
$ afa new -script -Q -j command_suggestion -p $P | jq &lt;span style="color:#e6db74">&amp;#39;. | fromjson&amp;#39;&lt;/span> | jq -r &lt;span style="color:#e6db74">&amp;#39;.suggested_command&amp;#39;&lt;/span>
&lt;span style="color:#75715e">#=&amp;gt; find internal -name &amp;#39;*.go&amp;#39; -exec head -n 1 {} \;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="実践例">実践例&lt;/h2>
&lt;p>実践例を列挙します。
もし使いたい例があれば、GitHubのリポジトリの&lt;a href="https://github.com/monochromegane/afa?tab=readme-ov-file#practical-examples">README&lt;/a>にプロンプトや設定例と共に載せているので参考にしてみてください。&lt;/p>
&lt;ul>
&lt;li>Zsh Line Editor(ZLE)を用いたターミナル上でのコマンド提案
&lt;ul>
&lt;li>デモで紹介したものです&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Vim上でのコード提案
&lt;ul>
&lt;li>これもデモで紹介したものです&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ターミナルに表示されたエラーメッセージの分析
&lt;ul>
&lt;li>&lt;code>tmux&lt;/code>の&lt;code>capture-pane&lt;/code>を使って直近の実行結果を分析できます。複数行にわたるエラーメッセージのコピペの手間が省けて便利ですね&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>GitHubのプルリクエストの自動生成
&lt;ul>
&lt;li>&lt;code>git diff&lt;/code>と&lt;code>git log&lt;/code>の情報を元にタイトルと要約を生成してプルリクエストを開きます。ZLEを想定しているので背景情報も踏まえて考えてもらえるようになっています。また、既存のテンプレートの上に要約を差し込む形にしているので、どのリポジトリでも使いやすいかなと思います。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>pecoを用いたセッションの絞り込みと読み込み
&lt;ul>
&lt;li>インタラクティブな絞り込みで素早く過去のセッションにアクセスできます。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="afa">AFA&lt;/h2>
&lt;p>AFAは&lt;code>AI for All&lt;/code>の略で、あらゆるコマンドラインツールに対して連携可能（$\forall x \in X , \exists \mathrm{AI}(x)$、つまりコマンドラインツールの集合&lt;code>X&lt;/code>の全ての要素&lt;code>x&lt;/code>に対し、その結果を入力とする&lt;code>AI(x)&lt;/code>な組み合わせが存在する）なAIコマンドになるといいなと思って付けた名前です。&lt;/p>
&lt;p>現時点でもまだViewerの入力欄が不調になることがあったりWindowsでの動作確認ができていないなど課題はありますが、通常使う分には十分な品質になったと思うので公開しました。よく使うオプションセットをconfigに設定し、いくつかのユーザープロンプトを登録しておいて&lt;code>alias af='afa new'&lt;/code>とするだけで、個人的には、調べ物やチャットを含め、ブラウザの利用頻度がかなり減ったことを実感しています。&lt;/p>
&lt;p>Homebrewによるインストール&lt;code>brew install monochromegane/tap/afa monochromegane/tap/afa-tui&lt;/code>も提供していますので、よければ使ってみてください。&lt;/p>
&lt;p>将来的には、サーバー上での異常検知のような定式化の難易度が高いタスクでの適用も検討しています（サードパーティー製ライブラリへの非依存とViewerツールとの分離は、そのためでもあります）。AFAであれば、他のコマンドラインツールとの親和性を活かして、通知やロギングは従来の仕組みも活用できると考えています。適用例など共有してもらえたら嬉しいです。&lt;/p></description></item><item><title>社会人大学院生の七転び八起き国際会議奮闘記</title><link>https://blog.monochromegane.com/blog/2023/12/30/international-conference-struggles/</link><pubDate>Sat, 30 Dec 2023 10:23:08 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2023/12/30/international-conference-struggles/</guid><description>&lt;p>2023年10月に初めてのアカデミックな国際会議での発表を終えました。
社会人博士課程に進学後、2021年5月の初投稿から丸2年、7回目の挑戦にしてようやくの採択ということで、自慢できるものではないのですが、同様に博士課程において日々挑戦している方々に何かの参考になればと思い、まとめておきます。&lt;/p>
&lt;h1 id="略歴と背景">略歴と背景&lt;/h1>
&lt;p>2017年から&lt;a href="https://rand.pepabo.com/">ペパボ研究所&lt;/a>で研究開発職に従事しています。
情報システムの自律適応等の研究に取り組み、&lt;a href="https://blog.monochromegane.com/blog/2020/09/21/isee-kyushu-u/">2020年10月に社会人博士課程に進学&lt;/a>しました。
博士課程では、多様かつ継続的に変化する環境に適応する実用的な情報システムの実現に向けて、多腕バンディット方策を用いる機構の研究を進めています。&lt;/p>
&lt;p>修士を飛ばした進学であったこともあり、進学時の実績としては&lt;a href="https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/">国内ジャーナル論文1本&lt;/a>のみでしたので、博士号取得に向けてはジャーナル論文をもう1本と、水準を満たす国際会議での採択1本を目指しての挑戦となりました。&lt;/p>
&lt;h1 id="年表">年表&lt;/h1>
&lt;p>以下に挑戦した国際会議とその結果について時系列にまとめました。&lt;/p>
&lt;h2 id="recsys2021-reject">RecSys2021 (Reject)&lt;/h2>
&lt;p>2021/05投稿。
提案手法において変化する環境への適応能力を向上させるべく進学後に試行錯誤した結果をまとめたものを投稿。&lt;/p>
&lt;p>2021/07不採択通知。
Review結果は5点中、1点4点2点2点2点と散々でした。
総評としてはアイディアやアプローチの萌芽は理解できるが、それらを納得させるような位置付けや妥当性の説明が不十分であるというもの。
この時点では、国際会議に向けての&lt;a href="https://blog.monochromegane.com/blog/2021/05/15/survey-method/">集中的サーベイ&lt;/a>や、初めての英語論文を書き上げるのに精一杯で、論文としてまだ議論の土台に立てていなかったと思います。&lt;/p>
&lt;h2 id="wsdm2022-reject">WSDM2022 (Reject)&lt;/h2>
&lt;p>2021/08投稿。
前回のRecSys2021の指摘事項を踏まえ、記述を見直して投稿。
当初は前回投稿に対するレビュアーからの指摘事項を個別に反映しただけでしたが、指導教官より、研究の位置付けが明確になるよう全体を通した見直しはどうですかとアドバイスをいただき、導入や関連研究を中心に大幅にリライトして投稿。&lt;/p>
&lt;p>2021/10不採択通知。
Review結果は、Weak rejectが3名、Rejectが1名でまだまだ採択には遠かったです。
それでも、総評には、サーベイの充実度や記述の了解性に対する前向きなコメントが多く、前進が感じられました。
なお、分野のexpertからは、提案の新規性や理論的な裏付け、もう一歩踏み込んだ評価の必要性などが指摘されています。&lt;/p>
&lt;h2 id="sac2022-rs-track-reject">SAC2022 RS Track (Reject)&lt;/h2>
&lt;p>2021/10投稿。
前回のWSDM2022の指摘のうち、提案手法を維持したまま対応できる部分を記述面で更新して投稿。&lt;/p>
&lt;p>2021/12不採択通知。
Review結果は、スコアが明記されていないもののReject寄りのコメントが2名、Accept寄りのコメントが1名でした。
採択に多少は近づいたように感じられるものの、総評としては前回とほぼ同様であり、次の提案方式の検討も進んでいたことから、この方式での国際会議への挑戦はここで一旦終えています。&lt;/p>
&lt;p>なお、この方式については、国内の論文誌に投稿し、無事採択されました（2本目の国内ジャーナル論文の実績）。
その査読においても新規性・有用性に関しての議論は行われ、採録条件に応える中で、これらを向上させることができたと思います。&lt;/p>
&lt;h2 id="cikm2022-reject">CIKM2022 (Reject)&lt;/h2>
&lt;p>2022/05投稿。
提案手法において変化する環境への適応能力とオンライン性能を両立させるための方式を検討したものを投稿。
先んじて国内研究会で途中経過をまとめる機会があったこと、前年の執筆経験が蓄積されていることもあり、同様に新規書き下ろしであったRecSys2021の時よりも短い期間で投稿できました。&lt;/p>
&lt;p>2022/08不採択通知。
Review結果は、Weak rejectが1名、Weak acceptが2名で、メタの判断によっては採択されていたかもしれず、惜しいと感じました。
総評は、研究の位置付けやアプローチの妥当性、記述の了解性に対しては一定の水準を満たすものの、手法の有効性を示すための評価方法の改善を求める指摘が多くありました。
前年と比べて手法自体の新規性の観点では認められつつあるなと感じるものの、その有用性を示すための工夫をどうするべきか考えあぐねていた時期だったと思います。&lt;/p>
&lt;h2 id="aamas2023-reject">AAMAS2023 (Reject)&lt;/h2>
&lt;p>2022/10投稿。
前回のCIKM2022の通知を待つ間に、提案手法に関連するサーベイが進んだこともあり、位置付けの補強を兼ねて、それらを盛り込み、イントロダクションと関連研究を中心にリライトして投稿。&lt;/p>
&lt;p>2023/01不採択通知。
Review結果は、Weak paperが1名、Decent paperが2名。
総評としては、やや厳し目で、了解性や位置付けに関する指摘が再発してしまいました。
おそらく追加的なサーベイを自身で消化しきれておらず、結果的に解決したい課題に対して不要に広い議論となってしまったのではないかと考えています。
また、前回の有用性をどう示すかという指摘についても、具体的な解決策を検討できないまま、記述で頑張ろうとしてしまったのも不明瞭になった遠因かもしれません。&lt;/p>
&lt;p>この時期は、なかなか国際会議に採択されないため、博論執筆に向けた実績を満たせないことに対する焦りが募っていきました。&lt;/p>
&lt;h2 id="pakdd2023-reject">PAKDD2023 (Reject)&lt;/h2>
&lt;p>2022/12投稿。
AAMAS2023への投稿と並行して、提案手法のもう一つの要素技術についてコンセプト的な実装と評価を進めていたものを投稿。&lt;/p>
&lt;p>2023/02不採択通知。
Review結果は、Weak rejectが2名、Weak acceptが2名でした。
総評は、課題と提案の位置付けや妥当性は納得できるものの、提案の新規性に関する疑問があるとのことで、課題に対する提案手法の検討の甘さが見透かされたように思えます。&lt;/p>
&lt;h2 id="smc2023-accept">SMC2023 (Accept!)&lt;/h2>
&lt;p>2023/04投稿。
研究としてはAAMAS2023の手法とPAKDD2023の手法が二つ並行している状態でしたが、まずは提案として完成しているAAMAS2023の手法を着地させるべく投稿。
一度、PAKDD2023の研究で離れたことが功を奏したのか、改めて関連文献を読み込む機会を通して知識の再整理が進み、提案手法の課題設定と採用するアプローチにおいて無理なく接続できるような定式化と説明ができたと喜んだ記憶があります。
また、執筆中に最新のサーベイで類似手法が見つかって焦る場面もありましたが、提案手法との差異を検討する中で結果的に提案の新規性の主張が明確にできたのでよかったです。&lt;/p>
&lt;p>2023/06採択通知。
Review結果は、スコアが明記されていないもののAccept寄りのコメントが3名、Reject寄りのコメントが1名でした。
総評では、研究や提案の位置付け、記述の明快さなどについて前向きなコメントがあり、新規性の多寡についての議論も若干ありました。
一方で、有用性や評価に関する不足のコメントがほぼ見られなかったのは興味深かったです。
これは定式化を進め、課題設定や解決する部分についての曖昧性が減少したことで、最小限の記述で過不足ない評価内容について、査読者と認識を揃えることができたためではないかと考えています。
この論文の執筆を通して、改めて、査読者のコメントを局所的に解釈するのではなく、その疑問が発生する根本について対局的にみて解決していくことの重要性を感じました。
これは2度目のWSDM2022への投稿時に指導教官からのアドバイスそのものであり、ようやく自分のものとすることができた時だったのかなと思えます。&lt;/p>
&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>国際会議への長い挑戦を通して、研究を世界的な基準で議論できる水準まで押し上げていくのは一朝一夕にできるものではないのだなあと感じました。
自分の場合は、自身の研究の発展はもちろんのこと、研究を推し進めていく力を高めたいと考え、博士後期課程へ挑戦したこともあり、研究自体と研究力を同時に前進させる必要があり、特に時間がかかってしまっているのだろうと思います。
すぐ成果が出るものではないと頭では分かっているつもりでしたが、やはり2年間全く結果が出なかったというのは心理的な負担が大きかったです。
特に、研究開発員として、事業への貢献も求められる中、不採択による論文執筆期間の延長は、各種施策のスケジュールにも影響するため、とても心苦しい思いをしました。&lt;/p>
&lt;p>そのような中でも、最初の国際会議の採択に漕ぎ着けることができたのは、ひとえに指導教官、研究所の仲間、そして会社の皆様の支援のおかげだと考えています。
本当にありがとうございます。&lt;/p>
&lt;p>最後に、自分にとって研究は「&lt;a href="https://blog.monochromegane.com/blog/2017/12/31/2017/">自分の思い描く世界に至るための過程&lt;/a>」であり、そのためには問題に向き合い続けることが大切だと考えています。
問題に向き合い続けるには、行き詰まらないよう多面的に見ることが重要です。
とは言え、博士課程の進学前は、多面的にあれこれ手を出すことはできていたものの、どこかでやりきれなかったり発散してしまっていたように思えます。
しかし、博士課程の進学後は、指導教官からの指導の中で、絶対に止まらない方法、収束させる方法というのを体得できているように感じます。
それは例えば、「難しいものと認識した上でそれに挑戦する喜び」であったり「ダメだった場合は改善してただ次に行くだけ」であったり、「自分で決めて悔いのないように進む」こと、そして「結果に対して本質的な面白さを見出して言語化し、これまでの取り組みと有機的に関連づけていくこと」などです。
これらはつまり、研究という最短ルートはない道程において、同じ道を回ることなく、常に何かしらの前進という成果を得るための能力です。
現在は、2回目の国際会議に向けてPAKDD2023に挑戦した時の手法を一層発展させたものを投稿中です。
この論文の取り組みは、国際会議の実績を得た後に更に取り組んだもので、継続的な研究が常態となったことを示すものなのかなと思っています。&lt;/p>
&lt;p>来年はおそらく博論に着手できる状態ですので、4年目に突入してしまいましたが博士号を確実に取得できるよう精一杯頑張ります。
そして、このように時間をかけて体得してきた研究と研究力の、支えてくれた皆様への還元を始めていきたいです。&lt;/p></description></item><item><title>カーネルリッジ回帰 入門</title><link>https://blog.monochromegane.com/blog/2022/09/11/kernel-ridge-regression/</link><pubDate>Sun, 11 Sep 2022 12:00:00 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2022/09/11/kernel-ridge-regression/</guid><description>&lt;p>基底関数を用いた線形回帰モデルのように入力に非線形な変換を施してモデルの表現力の向上を図る手法では、以下の2つの問題が発生する。&lt;/p>
&lt;ol>
&lt;li>特徴ベクトルの次元数の増加に伴う計算量の増加&lt;/li>
&lt;li>予測に有用な基底関数の選定&lt;/li>
&lt;/ol>
&lt;p>カーネルリッジ回帰は、カーネル関数を用いて上記の課題を解決する。
このエントリは、このカーネルリッジ回帰を最初に学んだ際の内容を自分なりにまとめたものである。&lt;/p>
&lt;p>以下では、はじめに、記法の整理を兼ねて基本的な線形回帰モデルを説明する。
次に、カーネル法を用いた線形回帰であるカーネルリッジ回帰の説明を通して上記の課題の解決アプローチを学ぶ。
最後に、カーネル法における計算量の課題を解決するためのアプローチである、Random Fourier Featuresも紹介する。&lt;/p>
&lt;h2 id="1-線形回帰モデル">1. 線形回帰モデル&lt;/h2>
&lt;p>線形回帰モデルの問題設定と解法について述べる。
いま、$N$個の入力$X=(\boldsymbol{x}_1,\ldots,\boldsymbol{x}_N)^{\top} \in \mathbb{R}^{N \times D}$と出力$\boldsymbol{y}=(y_1,\ldots,y_N)^{\top} \in \mathbb{R}^{N}$が与えられている。
このとき、$y$は$\boldsymbol{x}$を入力とした線形回帰モデル$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$の出力として得られると仮定する。
ここで、$\boldsymbol{\phi}(\boldsymbol{x}) = (\phi_1(\boldsymbol{x}),\ldots,\phi_F(\boldsymbol{x}))^{\top} \in \mathbb{R}^{F}$は$F$個の基底関数$\phi: \mathbb{R}^{D} \rightarrow \mathbb{R}$からなる特徴ベクトル、$\boldsymbol{w} \in \mathbb{R}^{F}$はこれに対応する係数ベクトルである。
このとき、この係数ベクトル$\boldsymbol{w}$を推定することが本問題の目標である。&lt;/p>
&lt;p>推定には最小二乗法を用いる。
なお、実用上は汎化性能の考慮から正則化を施すことが多いと思われるので、これを適用した&lt;strong>リッジ回帰&lt;/strong>を行う。
すなわち、$\Phi = (\boldsymbol{\phi}(\boldsymbol{x}_1),\ldots,\boldsymbol{\phi}(\boldsymbol{x}_N))^{\top} \in \mathbb{R}^{N \times F}$としたとき、学習データに対する誤差の二乗和（に正則化項を加えたもの）$E(\boldsymbol{w}) = \| \Phi \boldsymbol{w} - \boldsymbol{y} \|^2 + \lambda \| \boldsymbol{w} \|^2$を最小化する$\boldsymbol{w}$を求める。&lt;/p>
&lt;p>このために、まず$E(\boldsymbol{w})$を次のように整理する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
E(\boldsymbol{w}) &amp;amp;= (\Phi \boldsymbol{w} - \boldsymbol{y})^{\top}(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w} \\
&amp;amp;= ((\Phi \boldsymbol{w})^{\top} - \boldsymbol{y}^{\top})(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&amp;amp;= ( \boldsymbol{w}^{\top}\Phi^{\top} - \boldsymbol{y}^{\top})(\Phi \boldsymbol{w} - \boldsymbol{y}) + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&amp;amp;= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} - \boldsymbol{y}^{\top}\Phi\boldsymbol{w} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&amp;amp;= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} - \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}\\
&amp;amp;= \boldsymbol{w}^{\top}\Phi^{\top}\Phi\boldsymbol{w} - 2\boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{w}^{\top}\boldsymbol{w}.
\label{eq:ew}
\end{split}
\end{align}&lt;/p>
&lt;p>整理には、行列の定理$(AB)^{\top}=B^{\top}A^{\top}$と、スカラーは転置しても値が同じであることを利用した（$\boldsymbol{y}^{\top}\Phi\boldsymbol{w} = (\boldsymbol{y}^{\top}\Phi\boldsymbol{w})^{\top} = \boldsymbol{w}^{\top}\Phi^{\top}\boldsymbol{y}$）。&lt;/p>
&lt;p>次に、$E(\boldsymbol{w})$を最小化する$\boldsymbol{w}$を求めるために$\boldsymbol{w}$について偏微分して0とおく。&lt;/p>
&lt;p>\begin{align}
\frac{\partial E(\boldsymbol{w})}{\partial \boldsymbol{w}} &amp;amp;= 2\Phi^{\top}\Phi\boldsymbol{w} -2\Phi^{\top}\boldsymbol{y} + 0 + 2\lambda\boldsymbol{w} = 0.
\end{align}&lt;/p>
&lt;p>偏微分には、対称行列（$A=\Phi^{\top}\Phi=A^{\top}$）に対する二次形式（$\boldsymbol{w}^{\top}A\boldsymbol{w}$）の$\boldsymbol{w}$の偏微分が$(A + A^{\top})\boldsymbol{w} = 2A\boldsymbol{w}$であること、$\boldsymbol{w}^{\top}\boldsymbol{a}, \boldsymbol{a}=\Phi^{\top}\boldsymbol{y}$としたときの$\boldsymbol{w}$の偏微分が$\boldsymbol{a}$であることを利用した。&lt;/p>
&lt;p>最後に、$\boldsymbol{w}$について整理する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
2\Phi^{\top}\Phi\boldsymbol{w} -2\Phi^{\top}\boldsymbol{y} + 2\lambda\boldsymbol{w} &amp;amp;= 0\\
2\Phi^{\top}\Phi\boldsymbol{w} + 2\lambda\boldsymbol{w} &amp;amp;= 2\Phi^{\top}\boldsymbol{y}\\
\Phi^{\top}\Phi\boldsymbol{w} + \lambda\boldsymbol{w} &amp;amp;= \Phi^{\top}\boldsymbol{y}\\
(\Phi^{\top}\Phi + \lambda I_F)\boldsymbol{w} &amp;amp;= \Phi^{\top}\boldsymbol{y}\\
\boldsymbol{w} &amp;amp;= (\Phi^{\top}\Phi + \lambda I_F)^{-1}\Phi^{\top}\boldsymbol{y}.
\label{eq:w}
\end{split}
\end{align}&lt;/p>
&lt;p>ここでは、行列のサイズが$F \times F$の単位行列を$I_{F}$と表記した。&lt;/p>
&lt;p>新しい入力$\boldsymbol{x}$に対する出力は推定した$\boldsymbol{w}$を用いて、$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$と予測できる。&lt;/p>
&lt;h2 id="2-カーネル法による線形回帰モデル">2. カーネル法による線形回帰モデル&lt;/h2>
&lt;p>上述の線形回帰モデルを利用する際には、基底関数を増やし多くの特徴量の候補から予測に有用なものに重み付けできれば良いと考えられることから、特徴ベクトルの次元数$F$を増やすアプローチが検討される。
しかしながら、この場合、パラメータ$\boldsymbol{w}$の推定や出力$\hat{y}$の予測に必要な計算量も同時に増加してしまう。
そこで、カーネル法による線形回帰モデルでは、パラメータの次元数を$N$に抑えるようなアプローチをとる。
これは、学習データ数$N$が特徴ベクトルの次元数$F$よりも少ない場合に有効である。
また、線形回帰モデルにはもう一つ、予測に対して有用な基底関数の種類や数が明らかではないという課題がある。
これに対しカーネル法による線形回帰モデルは、カーネル関数を導入することで、基底関数の選定を省略することができる。&lt;/p>
&lt;p>以下、上述のリッジ回帰にカーネル法を適用した&lt;strong>カーネルリッジ回帰&lt;/strong>を説明する。&lt;/p>
&lt;h3 id="21-線形回帰モデルの双対表現">2.1. 線形回帰モデルの双対表現&lt;/h3>
&lt;p>パラメータの次元数を$N$に抑えるため、$F$次元の$\boldsymbol{w}$についての線形モデル$\hat{y} = \boldsymbol{w}^{\top}\boldsymbol{\phi}(\boldsymbol{x})$を、$N$個の学習データ$\Phi$に対応するパラメータ$\boldsymbol{\alpha} \in \mathbb{R}^{N}$で表現することを考える。&lt;/p>
&lt;p>そのために、式\eqref{eq:w}の3行目以降の変形を以下のように進める。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\Phi^{\top}\Phi\boldsymbol{w} + \lambda\boldsymbol{w} &amp;amp;= \Phi^{\top}\boldsymbol{y}\\
\lambda\boldsymbol{w} &amp;amp;= - \Phi^{\top}\Phi\boldsymbol{w} + \Phi^{\top}\boldsymbol{y}\\
\lambda\boldsymbol{w} &amp;amp;= - \Phi^{\top}(\Phi\boldsymbol{w} - \boldsymbol{y})\\
\boldsymbol{w} &amp;amp;= - \frac{1}{\lambda} \Phi^{\top}(\Phi\boldsymbol{w} - \boldsymbol{y}).
\end{split}
\end{align}&lt;/p>
&lt;p>ここで$\boldsymbol{\alpha} = - \frac{1}{\lambda}(\Phi\boldsymbol{w} - \boldsymbol{y})$とすると、$\boldsymbol{w} = \Phi^{\top}\boldsymbol{\alpha}$となる。
これにより、元の線形回帰モデルを$\hat{y} = (\Phi^{\top}\boldsymbol{\alpha})^{\top}\phi(\boldsymbol{x})$と、（右辺にも$\boldsymbol{w}$は含まれるが）見かけ上は$\boldsymbol{w}$を含まない形で表現できるようになった（&lt;strong>双対表現&lt;/strong>）。&lt;/p>
&lt;p>この双対表現の線形回帰モデルについて、最小二乗法を用いて$\boldsymbol{\alpha}$を推定する。
これは上述の$E(\boldsymbol{w})$を双対表現の線形回帰モデルで記述し、解を求めることと同等である。&lt;/p>
&lt;p>このために、式\eqref{eq:ew}に$\boldsymbol{w} = \Phi^{\top}\boldsymbol{\alpha}$を代入し$\boldsymbol{\alpha}$についての関数$E(\boldsymbol{\alpha})$とした上で、以下のように整理する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
E(\boldsymbol{\alpha}) &amp;amp;= (\Phi^{\top}\boldsymbol{\alpha})^{\top}\Phi^{\top}\Phi(\Phi^{\top}\boldsymbol{\alpha}) - 2(\Phi^{\top}\boldsymbol{\alpha})^{\top}\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda(\Phi^{\top}\boldsymbol{\alpha})^{\top}(\Phi^{\top}\boldsymbol{\alpha})\\
&amp;amp;= \boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\Phi\Phi^{\top}\boldsymbol{\alpha} - 2\boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{\alpha}^{\top}\Phi\Phi^{\top}\boldsymbol{\alpha}\\
&amp;amp;= \boldsymbol{\alpha}^{\top}KK\boldsymbol{\alpha} - 2\boldsymbol{\alpha}^{\top}K\boldsymbol{y} + \boldsymbol{y}^{\top}\boldsymbol{y} + \lambda\boldsymbol{\alpha}^{\top}K\boldsymbol{\alpha}.
\end{split}
\end{align}&lt;/p>
&lt;p>なお、
\[
K = \Phi\Phi^{\top} =
\begin{pmatrix}
\boldsymbol{\phi}(\boldsymbol{x}_1)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_1) &amp;amp; \ldots &amp;amp; \boldsymbol{\phi}(\boldsymbol{x}_1)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_N) \\
\vdots &amp;amp; \ddots &amp;amp; \vdots \\
\boldsymbol{\phi}(\boldsymbol{x}_N)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_1) &amp;amp; \ldots &amp;amp; \boldsymbol{\phi}(\boldsymbol{x}_N)^{\top}\boldsymbol{\phi}(\boldsymbol{x}_N)
\end{pmatrix} =
\begin{pmatrix}
k(\boldsymbol{x}_1,\boldsymbol{x}_1) &amp;amp; \ldots &amp;amp; k(\boldsymbol{x}_1,\boldsymbol{x}_N) \\
\vdots &amp;amp; \ddots &amp;amp; \vdots \\
k(\boldsymbol{x}_N,\boldsymbol{x}_1) &amp;amp; \ldots &amp;amp; k(\boldsymbol{x}_N,\boldsymbol{x}_N)
\end{pmatrix}
\in \mathbb{R}^{N \times N}
\]
とした。
ここで、入力$\boldsymbol{p}$と$\boldsymbol{q}$を$\boldsymbol{\phi}$によって特徴ベクトルに変換し内積をとる操作である$k(\boldsymbol{p},\boldsymbol{q})$をカーネル関数と呼ぶ。
また、学習データ$X$に対する全ての組み合わせである$K$をグラム行列と呼ぶ。&lt;/p>
&lt;p>次に、$E(\boldsymbol{\alpha})$を最小化する$\boldsymbol{\alpha}$を求めるために$\boldsymbol{\alpha}$について偏微分して0とおく。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\frac{\partial E(\boldsymbol{\alpha})}{\partial \boldsymbol{\alpha}} &amp;amp;= 2KK\boldsymbol{\alpha} - 2K\boldsymbol{y} + 0 + 2\lambda K\boldsymbol{\alpha}= 0.
\end{split}
\end{align}&lt;/p>
&lt;p>最後に、$\boldsymbol{\alpha}$について整理する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
2KK\boldsymbol{\alpha} - 2K\boldsymbol{y} + 2\lambda K\boldsymbol{\alpha} &amp;amp;= 0\\
KK\boldsymbol{\alpha} - K\boldsymbol{y} + \lambda K\boldsymbol{\alpha} &amp;amp;= 0\\
KK\boldsymbol{\alpha} + \lambda K\boldsymbol{\alpha} &amp;amp;= K\boldsymbol{y}\\
K\boldsymbol{\alpha} + \lambda \boldsymbol{\alpha} &amp;amp;= \boldsymbol{y}\\
(K + \lambda I_N)\boldsymbol{\alpha} &amp;amp;= \boldsymbol{y}\\
\boldsymbol{\alpha} &amp;amp;= (K + \lambda I_N)^{-1}\boldsymbol{y}.
\label{eq:alpha}
\end{split}
\end{align}&lt;/p>
&lt;p>新しい入力$\boldsymbol{x}$に対する出力は、推定した$\boldsymbol{\alpha}$を用いて以下のように予測できる。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\hat{y} &amp;amp;= (\Phi^{\top}\boldsymbol{\alpha})^{\top}\boldsymbol{\phi}(\boldsymbol{x}) \\
&amp;amp;= \boldsymbol{\alpha}^{\top}\Phi\boldsymbol{\phi}(\boldsymbol{x}) \\
&amp;amp;= \sum_{n=1}^{N} \alpha_n \boldsymbol{\phi}(\boldsymbol{x}_n)^{\top}\boldsymbol{\phi}(\boldsymbol{x}) \\
&amp;amp;= \sum_{n=1}^{N} \alpha_n k(\boldsymbol{x}_n, \boldsymbol{x}).
\label{eq:yk}
\end{split}
\end{align}&lt;/p>
&lt;p>すなわち、$F$次元の$\boldsymbol{w}$を用いず、学習データ数$N$を次元とする$\boldsymbol{\alpha}$で予測できるようになった。&lt;/p>
&lt;h3 id="22-カーネル関数の構成">2.2. カーネル関数の構成&lt;/h3>
&lt;p>ここまで、$F$個の基底関数$\phi$を用いた特徴ベクトルとしての$\boldsymbol{\phi}$同士の内積として、カーネル関数をボトムアップ的に定義した。&lt;/p>
&lt;p>この場合、どのような基底関数を選定するかという線形回帰モデルのもう一つの課題が残る。
カーネル法を用いた線形回帰モデルでは、発想を逆転させ、カーネル関数をトップダウン的に先に直接定義することで、その内部の基底関数を陽に知らずにすませるというアプローチをとる。&lt;/p>
&lt;p>ただし、この場合は定義したカーネル関数が正定値性を満たす必要がある。
すなわち、任意の$M$個の点から計算される、定義したカーネル関数による$M \times M$のグラム行列$K$の2次形式が常に非負（任意の$\boldsymbol{\mu} \in \mathbb{R}^M$に対して$\boldsymbol{\mu}^{\top}K\boldsymbol{\mu} \geq 0$）となる必要がある。&lt;/p>
&lt;p>このような条件を満たすカーネル関数を直接定義できたならば、これはなんらかの特徴ベクトル同士の内積と考えることができる。
ありがたいことに、式\eqref{eq:yk}は基底関数$\phi$を使わず全てカーネル関数$k$で表現できているため、直接定義したカーネル関数があれば、基底関数の選定が不要となる（&lt;strong>カーネルトリック&lt;/strong>）。&lt;/p>
&lt;p>幸い、さまざまなカーネル関数が考案されているため、まずはそれらのカーネル関数を利用することとなる。
以下、多項式カーネルとガウスカーネルを紹介する。&lt;/p>
&lt;h4 id="多項式カーネル">多項式カーネル&lt;/h4>
&lt;p>多項式カーネルは$k(\boldsymbol{p}, \boldsymbol{q}) = (\boldsymbol{p}^{\top}\boldsymbol{q} + c)^{m}$の形をとるカーネル関数である。
上述のカーネルリッジ回帰を利用するにあたってはどのような特徴ベクトルが利用されているのかを陽に知る必要はないが、例えば$m=2,\boldsymbol{p},\boldsymbol{q} \in \mathbb{R}^2$であれば次のような特徴ベクトルが対応することが分かる。&lt;/p>
&lt;p>対応する特徴ベクトルを調べるために、多項式カーネルを特徴ベクトルの内積$\boldsymbol{\phi}(\boldsymbol{p})^{\top}\boldsymbol{\phi}(\boldsymbol{q})$に変形する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
k(\boldsymbol{p}, \boldsymbol{q}) &amp;amp;= (\boldsymbol{p}^{\top}\boldsymbol{q} + c)^{2} \\
&amp;amp;= ((p_1, p_2)^{\top}(q_1, q_2) + c)^2 \\
&amp;amp;= (p_1q_1 + p_2q_2 + c)^2 \\
&amp;amp;= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + 2p_1q_1p_2q_2 + 2cp_2q_2 + 2cp_1q_1\\
&amp;amp;= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + 2p_1p_2q_1q_2 + 2cp_2q_2 + 2cp_1q_1\\
&amp;amp;= p_1^2q_1^2 + p_2^2q_2^2 + c^2 + \sqrt{2}p_1p_2\sqrt{2}q_1q_2 + \sqrt{2c}p_2\sqrt{2c}q_2 + \sqrt{2c}p_1\sqrt{2c}q_1\\
&amp;amp;= (p_1^2, p_2^2, c, \sqrt{2}p_1p_2, \sqrt{2c}p_2, \sqrt{2c}p_1)^{\top}(q_1^2, q_2^2, c, \sqrt{2}q_1q_2, \sqrt{2c}q_2, \sqrt{2c}q_1).
\end{split}
\end{align}&lt;/p>
&lt;p>つまり、今回の例では、特徴ベクトルが$\boldsymbol{\phi}(\boldsymbol{x}) = (x_1^2, x_2^2, c, \sqrt{2}x_1x_2, \sqrt{2c}x_2, \sqrt{2c}x_1)$として扱われていたことが分かる。
言葉を返せば、多項式カーネルを用いると、このような変換を行う6つの基底関数を明示的に選定して地道に内積を取った場合と同様の結果を得られる。&lt;/p>
&lt;p>なお、多項式カーネルの$m=1,c=0$の場合、これを線形カーネルと呼び、この時の特徴ベクトルは入力と等しい（$\boldsymbol{\phi}(\boldsymbol{x}) = \boldsymbol{x}$）。&lt;/p>
&lt;h4 id="ガウスカーネル">ガウスカーネル&lt;/h4>
&lt;p>ガウスカーネルは$k(\boldsymbol{p}, \boldsymbol{q}) = \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2})$の形をとるカーネル関数である。&lt;/p>
&lt;p>以下では、ガウスカーネルにどのような特徴ベクトルが対応するかを確認する。
まず、ガウスカーネルを以下のように展開、変形する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
k(\boldsymbol{p}, \boldsymbol{q}) &amp;amp;= \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{(\boldsymbol{p} - \boldsymbol{q})^{\top}(\boldsymbol{p} - \boldsymbol{q})}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{(\boldsymbol{p}^{\top} - \boldsymbol{q}^{\top})(\boldsymbol{p} - \boldsymbol{q})}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - \boldsymbol{q}^{\top}\boldsymbol{p} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - (\boldsymbol{q}^{\top}\boldsymbol{p})^{\top} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - \boldsymbol{p}^{\top}\boldsymbol{q} - \boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(-\frac{\boldsymbol{p}^{\top}\boldsymbol{p} - 2\boldsymbol{p}^{\top}\boldsymbol{q} + \boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2} + \frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2} + \frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2})\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2})\exp(\frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2}) \\
&amp;amp;= \rho\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2})\psi \\
&amp;amp;= \rho\psi\exp(\frac{\boldsymbol{p}^{\top}\boldsymbol{q}}{\sigma^2}).
\end{split}
\end{align}&lt;/p>
&lt;p>最後の2行では以降の展開を見やすくするため、$\rho=\exp(\frac{-\boldsymbol{p}^{\top}\boldsymbol{p}}{2\sigma^2}), \psi=\exp(\frac{-\boldsymbol{q}^{\top}\boldsymbol{q}}{2\sigma^2})$とおいた。&lt;/p>
&lt;p>次に、$e^x$のマクローリン展開の公式（$e^x = \sum_{i=0}^{\infty} \frac{x^i}{i!} = 1 + x + \frac{x^2}{2} + \frac{x^3}{6} + \cdots$）を使い、特徴ベクトルの内積$\boldsymbol{\phi}(\boldsymbol{p})^{\top}\boldsymbol{\phi}(\boldsymbol{q})$に変形する。&lt;/p>
&lt;p>簡単のため$\sigma=1$とすると、次のような式が得られる。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\rho\psi\exp(\boldsymbol{p}^{\top}\boldsymbol{q}) &amp;amp;= \rho\psi \left(1 + (\boldsymbol{p}^{\top}\boldsymbol{q})^1 + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^2}{2} + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^3}{6} + \ldots \right).
\end{split}
\end{align}&lt;/p>
&lt;p>これは$c=0$の多項式カーネルを次数$m$を増やしながら無限回足したものである。
よって例えば、$\boldsymbol{p},\boldsymbol{q} \in \mathbb{R}^2$では、次のような&lt;strong>無限次元&lt;/strong>の特徴ベクトルが対応することが分かる。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\rho\psi\exp(\boldsymbol{p}^{\top}\boldsymbol{q}) &amp;amp;= \rho\psi \left(1 + (\boldsymbol{p}^{\top}\boldsymbol{q})^1 + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^2}{2} + \frac{(\boldsymbol{p}^{\top}\boldsymbol{q})^3}{6} + \ldots \right) \\
&amp;amp;= \rho\psi \left(1 + (p_1q_1 + p_2q_2) + \frac{p_1^2q_1^2 + p_2^2q_2^2 + \sqrt{2}p_1p_2\sqrt{2}q_1q_2}{2} + \frac{p_1^3q_1^3 + p_2^3q_2^3 + \sqrt{3}p_1^2p_2\sqrt{3}q_1^2q_2 + \sqrt{3}p_1p_2^2\sqrt{3}q_1q_2^2}{6} + \ldots \right) \\
&amp;amp;= \rho\left(1, p_1, p_2, \frac{p_1^2}{\sqrt{2}}, \frac{p_2^2}{\sqrt{2}}, \frac{\sqrt{2}p_1p_2}{\sqrt{2}}, \frac{p_1^3}{\sqrt{6}}, \frac{p_2^3}{\sqrt{6}}, \frac{\sqrt{3}p_1^2p_2}{\sqrt{6}}, \frac{\sqrt{3}p_1p_2^2}{\sqrt{6}}, \ldots \right)^{\top}\psi\left(1, q_1, q_2, \frac{q_1^2}{\sqrt{2}}, \frac{q_2^2}{\sqrt{2}}, \frac{\sqrt{2}q_1q_2}{\sqrt{2}}, \frac{q_1^3}{\sqrt{6}}, \frac{q_2^3}{\sqrt{6}}, \frac{\sqrt{3}q_1^2q_2}{\sqrt{6}}, \frac{\sqrt{3}q_1q_2^2}{\sqrt{6}},\ldots \right) \\
&amp;amp;= \rho\left(1, p_1, p_2, \frac{p_1^2}{\sqrt{2}}, \frac{p_2^2}{\sqrt{2}}, p_1p_2, \frac{p_1^3}{\sqrt{6}}, \frac{p_2^3}{\sqrt{6}}, \frac{p_1^2p_2}{\sqrt{2}}, \frac{p_1p_2^2}{\sqrt{2}}, \ldots \right)^{\top}\psi\left(1, q_1, q_2, \frac{q_1^2}{\sqrt{2}}, \frac{q_2^2}{\sqrt{2}}, q_1q_2, \frac{q_1^3}{\sqrt{6}}, \frac{q_2^3}{\sqrt{6}}, \frac{q_1^2q_2}{\sqrt{2}}, \frac{q_1q_2^2}{\sqrt{2}},\ldots \right).
\end{split}
\end{align}&lt;/p>
&lt;p>ガウスカーネルでは、このような無限個の基底関数を用意して内積を地道に計算した結果が、$k(\boldsymbol{p}, \boldsymbol{q}) = \exp(-\frac{\| \boldsymbol{p} - \boldsymbol{q}\|^2}{2\sigma^2})$のみの計算から得られるとも考えられる。&lt;/p>
&lt;h2 id="3-random-fourier-features乱択化フーリエ特徴">3. Random Fourier Features（乱択化フーリエ特徴）&lt;/h2>
&lt;p>カーネルリッジ回帰による入力$\boldsymbol{x}$に対する予測は式\eqref{eq:alpha}\eqref{eq:yk}より、$\hat{y} = \sum_{n=1}^{N} \alpha_n k(\boldsymbol{x}_n, \boldsymbol{x}), \boldsymbol{\alpha} = (K + \lambda I_N)^{-1}\boldsymbol{y}$となるのであった。
カーネルリッジ回帰では、$F \gg N$となるような学習データ数$N$に対し十分大きい$F$個の基底関数を用いる場合に、双対表現によってパラメータ数を$N$に抑えつつ、カーネル関数の導入によって$F$次元の特徴ベクトルの直接的な算出を回避できた。&lt;/p>
&lt;p>しかしながら、カーネルリッジ回帰は、学習データ数$N$に対して計算量が指数的に増加してしまう課題がある。
これは、グラム行列$K$のサイズが$N \times N$であるため、$\boldsymbol{\alpha}$の計算にあたって、必要なカーネル関数の計算が$N^2$のオーダーで増加することからも分かる。
また、逆行列の計算も$K$のサイズに応じて計算量が増加する。
加えて、$\hat{y}$の計算にあたっても、新しい入力$\boldsymbol{x}$に対して$N$回のカーネル関数の計算が都度必要となってしまう。&lt;/p>
&lt;p>&lt;strong>Random Fourier Features&lt;/strong>は、ある確率分布からのサンプリング結果でカーネル関数とグラム行列を近似することで、上述の課題を解決する、高速化のための手法である。&lt;/p>
&lt;p>この手法では、$\mathbb{R}^D$上のカーネル関数$k(\boldsymbol{p},\boldsymbol{q})$が$\boldsymbol{p}$と$\boldsymbol{q}$の差の形（$k(\boldsymbol{p}-\boldsymbol{q})$）で表せるとき、このカーネル関数が、ある確率密度関数$p(\boldsymbol{\omega})$のフーリエ変換で表せることを利用する。&lt;/p>
&lt;p>\begin{align}
\begin{split}
k(\boldsymbol{p},\boldsymbol{q}) &amp;amp;= k(\boldsymbol{p} - \boldsymbol{q})\\
&amp;amp;= \int_{\mathbb{R}^{D}} p(\boldsymbol{\omega}) \exp(i \boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))d\boldsymbol{\omega} \\
&amp;amp;= \mathbb{E}_{\boldsymbol{\omega}}[\exp(i \boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))] \\
&amp;amp;= \mathbb{E}_{\boldsymbol{\omega}}[\cos(\boldsymbol{\omega}^{\top}(\boldsymbol{p} - \boldsymbol{q}))] \\
&amp;amp;= \mathbb{E}_{\boldsymbol{\omega},b}[\sqrt{2}\cos(\boldsymbol{\omega}^{\top}\boldsymbol{p} + b) \cdot \sqrt{2}\cos(\boldsymbol{\omega}^{\top}\boldsymbol{q} + b)] \\
&amp;amp;\approx \frac{1}{R} \sum_{r=1}^{R} \sqrt{2}\cos(\boldsymbol{\omega}_r^{\top}\boldsymbol{p} + b_r) \cdot \sqrt{2}\cos(\boldsymbol{\omega}_r^{\top}\boldsymbol{q} + b_r).
\end{split}
\end{align}&lt;/p>
&lt;p>ここで、$\boldsymbol{\omega} \sim p(\boldsymbol{\omega}), b \sim \text{Uniform}(0, 2\pi)$である。
なお、$p(\boldsymbol{\omega})$は利用するカーネル関数によって異なるが、ガウスカーネルの場合、$\boldsymbol{w} = (w_d)^{1 \leq d \leq D}, w_d \sim \mathcal{N}(0, \sigma^2)$となる。&lt;/p>
&lt;p>最後の行は、この確率分布の期待値（$=$カーネル関数の結果）を$R$個のサンプリング結果の平均で近似することを示している。&lt;/p>
&lt;p>すなわち、各サンプルから求めた結果を、$z_r(\boldsymbol{x}) = \cos(\boldsymbol{\omega}_{r}^{\top}\boldsymbol{x} + b_r)$、$R$個の$z_r$を$\boldsymbol{z}(\boldsymbol{x}) = \sqrt{\frac{2}{R}}(z_1(\boldsymbol{x}),\ldots,z_R(\boldsymbol{x}))^{\top}$とおくと、カーネル関数$k$の近似$\hat{k}$が$\hat{k}(\boldsymbol{p},\boldsymbol{q}) = \boldsymbol{z}(\boldsymbol{p})^{\top}\boldsymbol{z}(\boldsymbol{q})$のように得られる。
また、学習データ$X$に対する$\boldsymbol{z}$の集合を$Z = (\boldsymbol{z}(\boldsymbol{x}_1)^{\top}, \ldots, \boldsymbol{z}(\boldsymbol{x}_N)^{\top})^{\top} \in \mathbb{R}^{N \times R}$とすると、$\hat{K} = ZZ^{\top}$の操作によって$N \times N$行列の各要素がカーネル関数$k$の近似$\hat{k}(\boldsymbol{x}_i, \boldsymbol{x}_j) = \boldsymbol{z}(\boldsymbol{x}_i)^{\top}\boldsymbol{z}(\boldsymbol{x}_j)$となるグラム行列$K$の近似$\hat{K}$を得られる。&lt;/p>
&lt;p>よって、これらの近似を用いたカーネルリッジ回帰のパラメータ$\boldsymbol{\alpha}$の近似$\hat{\boldsymbol{\alpha}}$は、$\hat{\boldsymbol{\alpha}} = (\hat{K} + \lambda I_{N})^{-1}\boldsymbol{y}$となる。
ただし、この手法では、$\hat{K} = ZZ^{\top}$であることを利用して、計算量を学習データ数$N$ではなくサンプリング数$R$のオーダーに変えることができる。
そのため、$R \ll N$であるならば、非常に効率よく予測が可能となる。&lt;/p>
&lt;p>以下に、$\hat{K}$や$\hat{\boldsymbol{\alpha}}$を消去していく経過と合わせて、この手法における予測式を示す。&lt;/p>
&lt;p>\begin{align}
\begin{split}
\hat{y} &amp;amp;= \sum_{n=1}^{N} \hat{\alpha}_n \hat{k}(\boldsymbol{x}_n, \boldsymbol{x}) \\
&amp;amp;= \sum_{n=1}^{N} \hat{\alpha}_n \hat{k}(\boldsymbol{x}, \boldsymbol{x}_n) \\
&amp;amp;= \sum_{n=1}^{N} \hat{\alpha}_n \boldsymbol{z}(\boldsymbol{x})^{\top}\boldsymbol{z}(\boldsymbol{x}_n) \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} \sum_{n=1}^{N} \hat{\alpha}_n \boldsymbol{z}(\boldsymbol{x}_n) \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} \hat{\boldsymbol{\alpha}} \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} (\hat{K} + \lambda I_{N})^{-1}\boldsymbol{y} \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} Z^{\top} (ZZ^{\top} + \lambda I_{N})^{-1}\boldsymbol{y} \\
&amp;amp;= \boldsymbol{z}(\boldsymbol{x})^{\top} (Z^{\top}Z + \lambda I_{R})^{-1}Z^{\top} \boldsymbol{y}.
\end{split}
\end{align}&lt;/p>
&lt;p>よって、$A=(Z^{\top}Z + \lambda I_{R}) \in \mathbb{R}^{R \times R}$、$\boldsymbol{b} = (Z^{\top} \boldsymbol{y}) \in \mathbb{R}^{R}$、$\boldsymbol{\beta} = A^{-1}\boldsymbol{b}$として、$\hat{y} = \boldsymbol{z}(\boldsymbol{x})^{\top} \boldsymbol{\beta}$と予測できる。
$Z$は$N \times R$であるものの、逆行列のサイズは$R \times R$となること、$\hat{y}$の計算も、新しい入力$\boldsymbol{x}$に対して$R$回の計算で済む$\boldsymbol{z}(\boldsymbol{x})$のみで良いことから、計算量が抑えられることが分かる。&lt;/p>
&lt;p>なお、最後の行では逆行列の補題（$P(I_N + QP)^{-1} = (I_R +PQ)^{-1}P, P \in \mathbb{R}^{R \times N}, Q \in \mathbb{R}^{N \times R}$）を用いた。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;h3 id="線形回帰モデル">線形回帰モデル&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://manabitimes.jp/math/1128">正規方程式の導出と計算例&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kspub.co.jp/book/detail/5161968.html">スタンフォード　ベクトル・行列からはじめる最適化数学&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kspub.co.jp/book/detail/1529267.html">ガウス過程と機械学習&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="カーネル法による線形回帰モデル">カーネル法による線形回帰モデル&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/wsuzume/items/09a59036c8944fd563ff">線形な手法とカーネル法（回帰分析）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://qiita.com/kilometer/items/66e6116cc661019ead59">カーネルトリック&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.slideshare.net/KeisukeSugawara/slide0629">PRML第６章「カーネル法」&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.slideshare.net/hagino_3000/prml-61-17081123">PRML 6.1章 カーネル法と双対表現&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iwanami.co.jp/book/b257891.html">カーネル多変量解析 非線形データ解析の新しい展開&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://towardsdatascience.com/truly-understanding-the-kernel-trick-1aeb11560769">Understanding the Kernel Trick with fundamentals&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Radial_basis_function_kernel">Radial basis function kernel&lt;/a>&lt;/li>
&lt;/ul>
&lt;h3 id="random-fourier-features">Random Fourier Features&lt;/h3>
&lt;ul>
&lt;li>&lt;a href="https://qiita.com/githug0906/items/448daec79fac2ffd82a0">乱択化フーリエ特徴を用いたリッジ回帰&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.kyoritsu-pub.co.jp/book/b10003381.html">機械学習のためのカーネル100問 with Python&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://gregorygundersen.com/blog/2019/12/23/random-fourier-features/">Random Fourier Features&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://proceedings.neurips.cc/paper/2007/hash/013a006f03dbc5392effeb8f18fda755-Abstract.html">Rahimi, Ali, and Benjamin Recht. &amp;ldquo;Random features for large-scale kernel machines.&amp;rdquo; Advances in neural information processing systems 20 (2007).&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>gonum/matパッケージを直感的に操作するMatrix Adapterをつくった</title><link>https://blog.monochromegane.com/blog/2022/07/02/matrix-adapter/</link><pubDate>Sat, 02 Jul 2022 11:59:22 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2022/07/02/matrix-adapter/</guid><description>&lt;p>gonum/matによる行列計算を幾分か直感的に扱える薄いラッパーを作りました。
具体的には、計算結果用に空の行列を予め用意するのではなく、計算結果を戻り値で受け取れるように統一します。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/monochromegane/mat">Matrix Adapter&lt;/a>: Small adapter which provides method signatures that allow intuitive operation with fewer lines of code for gonum/mat.&lt;/li>
&lt;/ul>
&lt;h1 id="背景と課題感">背景と課題感&lt;/h1>
&lt;p>&lt;a href="https://github.com/gonum/gonum/tree/master/mat">Gonumプロジェクトのmatパッケージ&lt;/a>はGo言語での行列計算ライブラリを提供してくれています。
こういった正確さと速度の求められる数値計算の処理には、（趣味は別として）自作ではなく、多くの人に使われ実績のあるライブラリを採用したいことから、このパッケージを利用しています。&lt;/p>
&lt;p>非常に便利に使わせていただいている一方で、自分の場合、スムーズに書けないことがありました。
理由としては、計算結果の受け取り方法に対する一貫性の崩れがあるだろうと考えています。&lt;/p>
&lt;p>matパッケージでは、予め空の行列を用意し、これをレシーバーとして計算対象となる行列を引数で渡します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">Dense&lt;/span>
&lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">a&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>元の行列が維持されるこの設計は非常にありがたいです。
しかしながら、一部の関数（例えば &lt;code>Dense.T&lt;/code>）は結果が戻り値として得られます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">ct&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">c&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>()
&lt;/code>&lt;/pre>&lt;/div>&lt;p>この一貫性の崩れは不変と可変の混在にあるのではないかと考えています。
gonum/matパッケージでは、&lt;a href="https://pkg.go.dev/gonum.org/v1/gonum/mat#hdr-Invariants">引数で渡す行列は計算操作に対して不変&lt;/a>とされています。
これは、関数のパラメータの方が、&lt;code>mat.Matrix&lt;/code>インターフェースであることからも読み取れます。
実際、このインターフェースには、&lt;code>Dims()&lt;/code>, &lt;code>At()&lt;/code>といった参照系かレシーバーを壊さない&lt;code>T()&lt;/code>のみが用意されています。&lt;/p>
&lt;p>一方で、このインターフェースを実装した&lt;code>mat.Dense&lt;/code>などは自身をレシーバーとして内容を変更する操作を認めています。
この差異により、mat.Matrixインターフェースのシグネチャの一つである&lt;code>T()&lt;/code>は戻り値を返すが、Denseの関数ではレシーバーを変更するという振る舞いの違いがあるのではないかと思われました。&lt;/p>
&lt;p>gonum/matパッケージではほとんどの関数が空の行列を予め用意する方式に従っているため、慣れれば問題ない程度ではありますが、久しぶりに使う場合など、多少まごつくことが何度かありました。
個人的に、Go言語で何か書くときは迷わず書きたいという欲求があり、迷わないため一貫性のあるラッパーを作ることとしました。&lt;/p>
&lt;h1 id="matrix-adapter">Matrix Adapter&lt;/h1>
&lt;p>今回は、計算結果を戻り値で受け取れるように統一します。
これにより、利用側からはDenseらも不変であるかのように扱え、一貫性という側面から認知負荷が減ると考えるためです。&lt;/p>
&lt;p>Matrix Adapterを適用した場合、先ほどの例は以下のようになります。
&lt;code>c&lt;/code>がレシーバーではなく、先ほどは引数となっていた&lt;code>a&lt;/code>がレシーバーとなっていることに注意してください。
&lt;code>c&lt;/code>は戻り値として受け取ることになりました。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#a6e22e">c&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">a&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="実装と使い方">実装と使い方&lt;/h2>
&lt;p>Adapterの実装は単純明快で、元の構造体を埋め込み（embedding）し、結果を戻り値で返すように関数のシグネチャを変更しました。
変更が不要なものは移譲されます。
いわゆるGoFのデザインパターンにおけるAdapterパターンというやつです。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#66d9ef">type&lt;/span> &lt;span style="color:#a6e22e">Dense&lt;/span> &lt;span style="color:#66d9ef">struct&lt;/span> {
&lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">Dense&lt;/span>
}
&lt;span style="color:#66d9ef">func&lt;/span> (&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Dense&lt;/span>) &lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">b&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">Matrix&lt;/span>) &lt;span style="color:#f92672">*&lt;/span>&lt;span style="color:#a6e22e">Dense&lt;/span> {
&lt;span style="color:#66d9ef">var&lt;/span> &lt;span style="color:#a6e22e">dense&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">Dense&lt;/span>
&lt;span style="color:#a6e22e">dense&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">m&lt;/span>.&lt;span style="color:#a6e22e">Dense&lt;/span>, &lt;span style="color:#a6e22e">b&lt;/span>)
&lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">Dense&lt;/span>{&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#a6e22e">dense&lt;/span>}
}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>現状、DenseとVecDenseに対するAdapterを提供しています。
既存と同名の&lt;code>NewDense()&lt;/code>と&lt;code>NewVecDense()&lt;/code>を使って、ラップされたDenseやVecDenseを作成できます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;span style="color:#f92672">import&lt;/span> (
&lt;span style="color:#e6db74">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;span style="color:#e6db74">&amp;#34;github.com/monochromegane/mat/adapter&amp;#34;&lt;/span>
)
&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;span style="color:#a6e22e">m&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">adapter&lt;/span>.&lt;span style="color:#a6e22e">NewDense&lt;/span>(&lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, []&lt;span style="color:#66d9ef">float64&lt;/span>{&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">2.0&lt;/span>, &lt;span style="color:#ae81ff">3.0&lt;/span>, &lt;span style="color:#ae81ff">4.0&lt;/span>})
&lt;span style="color:#a6e22e">fmt&lt;/span>.&lt;span style="color:#a6e22e">Printf&lt;/span>(&lt;span style="color:#e6db74">&amp;#34;%v\n&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">m&lt;/span>)
&lt;span style="color:#75715e">// ⎡1 2⎤
&lt;/span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75715e">// ⎣3 4⎦
&lt;/span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/code>&lt;/pre>&lt;/div>&lt;p>ちなみに、提供されるDenseとVecDenseは&lt;code>fmt.Stringer&lt;/code>インターフェースを実装し、行列の内容を整形して出力するようにしています。&lt;/p>
&lt;p>ここで、少し実践的な例として、リッジ回帰によるパラメータ推定（$\hat{\theta} = (X^{\top}X + \lambda I)^{-1} X^{\top}Y$）を実装し、比較してみます。&lt;/p>
&lt;h3 id="matrix-adapterでの実装">Matrix Adapterでの実装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go"> &lt;span style="color:#a6e22e">X&lt;/span>, &lt;span style="color:#a6e22e">Y&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">syntheticData&lt;/span>(&lt;span style="color:#a6e22e">N&lt;/span>, &lt;span style="color:#a6e22e">theta&lt;/span>) &lt;span style="color:#75715e">// Return adapter.Dense
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#a6e22e">I&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDiagDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, []&lt;span style="color:#66d9ef">float64&lt;/span>{&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>})
&lt;span style="color:#a6e22e">reg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">DenseCopyOf&lt;/span>(&lt;span style="color:#a6e22e">I&lt;/span>).&lt;span style="color:#a6e22e">Scale&lt;/span>(&lt;span style="color:#a6e22e">lambda&lt;/span>)
&lt;span style="color:#a6e22e">XTXinv&lt;/span>, &lt;span style="color:#a6e22e">_&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">Transpose&lt;/span>().&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">X&lt;/span>).&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">reg&lt;/span>).&lt;span style="color:#a6e22e">Inverse&lt;/span>()
&lt;span style="color:#a6e22e">XTY&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">Transpose&lt;/span>().&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">Y&lt;/span>)
&lt;span style="color:#a6e22e">estimated&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">XTXinv&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">XTY&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="gonummatでの実装">gonum/matでの実装&lt;/h3>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go"> &lt;span style="color:#a6e22e">X&lt;/span>, &lt;span style="color:#a6e22e">Y&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">syntheticData&lt;/span>(&lt;span style="color:#a6e22e">N&lt;/span>, &lt;span style="color:#a6e22e">theta&lt;/span>) &lt;span style="color:#75715e">// Return adapter.Dense
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
&lt;span style="color:#a6e22e">XTXinv&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">XTXinv&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>(), &lt;span style="color:#a6e22e">X&lt;/span>)
&lt;span style="color:#a6e22e">I&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDiagDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, []&lt;span style="color:#66d9ef">float64&lt;/span>{&lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>, &lt;span style="color:#ae81ff">1.0&lt;/span>})
&lt;span style="color:#a6e22e">reg&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">DenseCopyOf&lt;/span>(&lt;span style="color:#a6e22e">I&lt;/span>)
&lt;span style="color:#a6e22e">reg&lt;/span>.&lt;span style="color:#a6e22e">Scale&lt;/span>(&lt;span style="color:#a6e22e">lambda&lt;/span>, &lt;span style="color:#a6e22e">reg&lt;/span>)
&lt;span style="color:#a6e22e">XTXinv&lt;/span>.&lt;span style="color:#a6e22e">Add&lt;/span>(&lt;span style="color:#a6e22e">XTXinv&lt;/span>, &lt;span style="color:#a6e22e">reg&lt;/span>)
&lt;span style="color:#a6e22e">XTXinv&lt;/span>.&lt;span style="color:#a6e22e">Inverse&lt;/span>(&lt;span style="color:#a6e22e">XTXinv&lt;/span>)
&lt;span style="color:#a6e22e">XTY&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">XTY&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">T&lt;/span>(), &lt;span style="color:#a6e22e">Y&lt;/span>)
&lt;span style="color:#a6e22e">estimated&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">mat&lt;/span>.&lt;span style="color:#a6e22e">NewDense&lt;/span>(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#66d9ef">nil&lt;/span>)
&lt;span style="color:#a6e22e">estimated&lt;/span>.&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">XTXinv&lt;/span>, &lt;span style="color:#a6e22e">XTY&lt;/span>)
&lt;/code>&lt;/pre>&lt;/div>&lt;p>この例では、gonum/matでの実装に比べてMatrix Adapterでの実装が、結果用の&lt;code>Dense&lt;/code>の準備が省略できたこと、各関数で受け取る引数が減ったことなどから、幾分か簡潔に記述できているかと思います。&lt;/p>
&lt;p>なお、Adapterでの実装では、Method Chainによる行数の短縮も見てとれます。
これについては、戻り値を返す実装としたことで副次的に得られた、本Adapterの特徴です。
Go言語におけるMethod Chainは、errorを含む多値の戻り値との相性から、積極的に採用されていないと認識しています。
ただ、今回は元のパッケージが各計算においてerrorを返さないものが多く、多値にならない関数が多くできたため、結果としてMethod Chainがつながる場合ができています（&lt;code>Inverse()&lt;/code>などerrorを返すものもあるため全部は繋げません）。
この辺りのエラー処理については、一考の価値があると思いますが、現時点で本Adapterの対象外（従来パッケージを踏襲）としています。&lt;/p>
&lt;h2 id="相互運用性">相互運用性&lt;/h2>
&lt;p>Adapterの提供する関数でも、引数は&lt;code>mat.Matrix&lt;/code>（や&lt;code>mat.Vector&lt;/code>）を使うため、既存のラップしていないものを入力として受け取れます。
また、これらのAdapterは、&lt;code>mat.Dense&lt;/code>（や&lt;code>mat.VecDense&lt;/code>）構造体を埋め込んでいるため、&lt;code>mat.Matrix&lt;/code>（や&lt;code>mat.Vector&lt;/code>）の実装を満たします。
よって、ラップされた&lt;code>adapter.Dense&lt;/code>（や&lt;code>adapter.VecDense&lt;/code>）を既存の関数の入力として渡すことができます。&lt;/p>
&lt;p>また、&lt;code>T()&lt;/code>は&lt;code>mat.Matrix&lt;/code>として維持しなければならない関数であることから、同等の&lt;code>Transpose()&lt;/code>を提供しています。
これにより、転置行列がレシーバーとなるような呼び出しであっても、&lt;code>adapter.Dense&lt;/code>として振る舞うことができるようになり、Matrix Adapterとの親和性が向上します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-go" data-lang="go">&lt;span style="color:#75715e">// X.T().Product(Y) is invalid due to mat.Matrix has no method Product.
&lt;/span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#a6e22e">XTY&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#a6e22e">X&lt;/span>.&lt;span style="color:#a6e22e">Transpose&lt;/span>().&lt;span style="color:#a6e22e">Product&lt;/span>(&lt;span style="color:#a6e22e">Y&lt;/span>) &lt;span style="color:#75715e">// Valid
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>本エントリでは、gonum/matパッケージを直感的に操作するための&lt;a href="https://github.com/monochromegane/mat">Matrix Adapter&lt;/a>を紹介しました。
本Adapterの作成とエントリ執筆において、「直感的でない」と主観的に感じる理由について、不変と可変の混在に起因するものではないかなと言語化できたのがよかったかなあと思います。&lt;/p>
&lt;p>自分の利用範囲だと、DenseとVecDenseで事足りる場合が多いのですが、必要に応じて対象を増やしていこうかと思います。&lt;/p>
&lt;h1 id="参考">参考&lt;/h1>
&lt;ul>
&lt;li>&lt;a href="https://po3rin.com/blog/gonum">Go + Gonum を使った行列計算まとめ&lt;/a>
&lt;ul>
&lt;li>関数の直感性を上げるための独自関数や、行列のフォーマットなどを参考にさせていただきました。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;a href="https://github.com/gorgonia/tensor">gorgonia/tensor&lt;/a>
&lt;ul>
&lt;li>gonum/matではないGo言語の行列計算パッケージ。戻り値で結果を受け取れたりerrorも返すので本Adapterの目指すところに近いとは思います。速度含めて検証が必要なのもあり、今回は慣れて使っている方が多いであろうgonum/matをラップする方式を採用しました。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></description></item><item><title>2022年2月のアイオー</title><link>https://blog.monochromegane.com/diary/20220226-io/</link><pubDate>Sat, 26 Feb 2022 11:53:35 +0900</pubDate><guid>https://blog.monochromegane.com/diary/20220226-io/</guid><description>&lt;p>月ごとのインプットとアウトプットの記録。&lt;/p>
&lt;h2 id="インプット">インプット&lt;/h2>
&lt;h3 id="書籍">書籍&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3sok7MY">未踏の蒼穹&lt;/a>』&lt;/p>
&lt;p>趣味のSFとして。ジェイムズ・Ｐ・ホーガンの長編作品。作者の『星を継ぐもの』ほど惹かれなかったが、十分面白く読むことができた。作者の科学者に対する理想像の実現が『星を継ぐもの』から今作の間にこのように変わったのだなあという観点で裏読みできたのでもう少し間の作品を埋めてみようかな。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3LZAxTL">情報検索と言語処理 (言語と計算)&lt;/a>』&lt;/p>
&lt;p>今月は情報検索関連でまとまったインプットが必要になったので。初版1999年と古いが（今から見ると）技術的な打ち手がまだ少ない時代は、定量的な評価が難しい人の認知モデルも含めた幅広い議論が交わされており、個人的には立ち返る意味があると思っている。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3M11yGd">情報検索アルゴリズム&lt;/a>』&lt;/p>
&lt;p>同じく情報検索関連のインプットとして。初版2002年。ベクトル空間からの近傍探索、アドホックな文字列照会による検索、索引構築を備えた検索などの基本が広く紹介されている。現在では前半の、これらを一貫して評価するための検索モデルや基準などの整理が参考になると思われた。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3BUPj9v">情報検索のためのユーザインタフェース&lt;/a>』&lt;/p>
&lt;p>同上。初版2011年。以前読んだものだが検索の個人化について章が割り当てられていたので目を通した。フィードバックをどう負担なく獲得しかつ有用に活かすかについて各研究が苦労している様が見てとれる。全体的な傾向を活かすところから順次粒度を細かくしていくのが王道だろうか。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/33W6I5e">AIアルゴリズムマーケティング 自動化のための機械学習/経済モデル、ベストプラクティス、アーキテクチャ&lt;/a>』&lt;/p>
&lt;p>同上。初版2018年。主に検索部分に目を通した。各施策に対してビジネス的な目標をおいた上でモデルやアーキテクチャを検討している。検索においては、その目標に沿って主観的にコントロール可能な部分が例示されており参考になった。上述の評価指標と組み合わせることで検索機構に対して求める性能の解像度を上げることができたと思う。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/33RIPLZ">Elasticsearch実践ガイド&lt;/a>』&lt;/p>
&lt;p>同上。初版2018年。施策を具体的な実装に落とし込む際の用語の紐付けのために読んだ。アーキテクチャの全体と基本的な使い方がわかりやすく図解で紹介されており素早く目的を達成できた。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3hgxvMA">Pythonではじめる 情報検索プログラミング&lt;/a>』&lt;/p>
&lt;p>同上。初版2020年。情報検索に関する基本的なアルゴリズムを実際に手を動かしながら体験できる。具体的にどういう結果がえられるのか、アルゴリズムごとの特性の違いは何かなど勘所をつかむ上で良さそう。特にうまく検索できないパターンなどを具体的なイメージを得られるのではないだろうか。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3Ho8OIw">情報検索 :検索エンジンの実装と評価&lt;/a>』&lt;/p>
&lt;p>同上。初版2020年。タイトルの通り検索エンジンを実装し評価するために必要な技術が詳細に解説されている。今回は検索サーバを使う上での観点が必要だったのでパート3の検索とランキング部分を読んだ。検索サーバで提供されていない基準でどういう手法をとれるかという知識のインデックスを増やせたと思う。必要に応じて読み直すつもり。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/35bOoFF">A/Bテスト実践ガイド　真のデータドリブンへ至る信用できる実験とは&lt;/a>』&lt;/p>
&lt;p>同上。初版2021年。情報検索の施策の有用性の評価の参考のため読んだ。A/Bテストの重要性や手法に加え、それを文化として根付かせるためのノウハウが紹介されている。個人的には多腕バンディットで解決できる部分も多いと思っていたが、その背景にある対照実験のための知識は重要だと改めて認識できたという面で参考になった。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3BThXI8">入門 機械学習による異常検知―Rによる実践ガイド&lt;/a>』&lt;/p>
&lt;p>時系列データの変化点検出をやりたくなり、以前も参考にしていた『&lt;a href="https://amzn.to/3BQL132">異常検知と変化検知&lt;/a>』とあわせて読んだ。非常に参考になるが、分布の仮定が今回解きたいものと合わないかもしれないなあというところで引き続き調べている。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3hieMQH">Machine Learning for Data Streams: with Practical Examples in MOA (Adaptive Computation and Machine Learning series) (English Edition)&lt;/a>』&lt;/p>
&lt;p>同じく変化点検出の方式調査で読んでいる。多腕バンディットやフィードバック制御など逐次的に適応していくような仕組みが好きなのだが、そのような仕組みのひとつで一時期調べていたADWINの提案者が執筆に参加しているもの。各方式については簡単な紹介だけなので英語であっても読みやすいが、アルゴリズム等の詳細は論文を読む必要があると思う。自分の興味範囲を整理整頓するのに良いと思い少しづつ読むことにした。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="論文">論文&lt;/h3>
&lt;p>読めていなかった〜。&lt;/p>
&lt;h2 id="アウトプット">アウトプット&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/monochromegane/banditalgorithms">Bandit algorithms&lt;/a>&lt;/p>
&lt;p>研究のシミュレーションで使う比較用の多腕バンディットのアルゴリズムをテスト込みできちんと整備することにした。&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>2022年1月のアイオー</title><link>https://blog.monochromegane.com/diary/20220130-io/</link><pubDate>Sun, 30 Jan 2022 19:04:47 +0900</pubDate><guid>https://blog.monochromegane.com/diary/20220130-io/</guid><description>&lt;p>月ごとのインプットとアウトプットの記録。&lt;/p>
&lt;h2 id="インプット">インプット&lt;/h2>
&lt;h3 id="書籍">書籍&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3rerg1O">未来は予測するものではなく創造するものである　――考える自由を取り戻すための〈ＳＦ思考〉&lt;/a>』&lt;/p>
&lt;p>2022年の目標である100倍研究のため、入出力の幅を広げられたらと思い読んだもの。SFプロトタイピング、実例などが紹介されている。自分や研究所として、実際にSFとして仕立てる必要はないと思うが、研究テーマやストーリーの生成に、バックキャスティング、フォアキャスティングの反復を意識的に取り入れることは重要だなと思えた。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3oakVlW">WEB+DB PRESS Vol.126&lt;/a>』&lt;/p>
&lt;p>特集の「Goで作って学ぶ検索エンジン」が気になって読んだ。この特集自体は『&lt;a href="https://amzn.to/3rerRk4">情報検索の基礎&lt;/a>』を思い出しながらふむふむとさっくり読めた。実装もついている点も良かった。せっかくなので他の記事も読んだが、コンテナやプライバシー関連の動向など界隈の新しめの情報が端的にまとまっており継続して読んでおこうと思えた。自身の研究がアルゴリズム寄りになりつつあるが、システムとして導入、評価できるという強みは保っておきたいことだし。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3Ght26m">データサイエンスの無駄遣い 日常の些細な出来事を真面目に分析する&lt;/a>』&lt;/p>
&lt;p>もっと機械学習等をどんどん使っていって普段の選択肢を広げたいなあとは思っているので、アイディアのヒントがないかなと読んだもの。なるほどこういう動機や解決策もあるんだなあと思いつつ、現時点ではあまりヒントにはならなかったかな。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3reDk33">完全独習 ベイズ統計学入門&lt;/a>』&lt;/p>
&lt;p>以前読んだはずだけど、所長が読んだという情報から内容が全然思い出せなかったので再読。今よりベイズ統計がさらにわかってなかった時に読んだのだが、今ならすんなり理解ができるので少しは成長した様子。離散から連続確率になるときに条件付き確率と記述されているのが尤度関数になる部分に納得がいかなかったのだが、研究所で教えてもらって理解がより深まった感じ。ありがたい。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3oa1d9I">ガイダンス 確率統計: 基礎から学び本質の理解へ&lt;/a>』&lt;/p>
&lt;p>確率統計はずっと苦手意識があるので何度目かの再入門として読んだ。証明や練習問題もありしっかりサポートしてくれているので、もう一周すればだいぶ理解が深まりそうだが、目を通したところまで。確率と集合の記号がもっと動いて見えるまで慣れないとダメだなあ。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3gaCz4I">円　劉慈欣短篇集&lt;/a>』&lt;/p>
&lt;p>趣味のSFとして。『三体』の作者の短編集。単純にどの作品も面白かったが、SF思考の後に読んだので、短編ごとになるほどそういう世界観で、その技術体系を導くのか等、いつもより多角的な視点で読めて良かった。個人的には「詩雲」「二〇一八年四月一日」「人生」が印象に残ったのだが共通点を振り返って自分でも意外だった。多様で飽きのこない短編集だった。おすすめ。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>『&lt;a href="https://amzn.to/3ISWykL">実践 時系列解析 ―統計と機械学習による予測&lt;/a>』&lt;/p>
&lt;p>研究で時系列を扱う機会はとても多いので新しい観点が得られればと思い読んだもの。解析手法だけでなく、前処理や探索的な解析、データ保存手段、時系列データの探し方、解析の実例等幅広く扱っている。個人的には解析手法における分類自体がそもそもありがたいと感じた。ただし個別の説明はあまりわかりやすいものではないと感じたので、知識のインデックスの増強として割り切って読んだ。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="論文">論文&lt;/h3>
&lt;p>バンディット系を2本。ちょっと少ないので来月はこの辺を改善しようと思う。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://arxiv.org/abs/2010.00827">Neural Thompson Sampling&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arxiv.org/abs/1909.09146">Weighted Linear Bandits for Non-Stationary Environments&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="アウトプット">アウトプット&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://github.com/monochromegane/banditsflow">BanditsFlow&lt;/a>&lt;/p>
&lt;p>100倍研究の出力側の施策として。研究で扱うシミュレーションに纏わる、開発効率の改善や再現性の確保といったいくつかの課題を解決する。シミュレーションにおける定型化可能なワークフロー、ならびにこれらのパラメータや結果の管理を一元に行えるフレームワークである。Gitとあわせて実験内容とその結果を時系列的にコード管理する予定。来月から玄人実行していく。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="100倍アイオーのために">100倍アイオーのために&lt;/h2>
&lt;p>今月はTwitterを制限して読書量が増えたので良かった。
全然見ないというのも情報収集に支障が出るので、以下のような雑スクリプトを一日一回だけ実行している。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">&lt;span style="color:#75715e">#!/bin/bash
&lt;/span>&lt;span style="color:#75715e">&lt;/span>
argv&lt;span style="color:#f92672">=(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>$@&lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;span style="color:#66d9ef">for&lt;/span> i in &lt;span style="color:#e6db74">`&lt;/span>seq &lt;span style="color:#ae81ff">1&lt;/span> $#&lt;span style="color:#e6db74">`&lt;/span>
&lt;span style="color:#66d9ef">do&lt;/span>
yesterday&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>date -v-1d &lt;span style="color:#e6db74">&amp;#39;+%Y-%m-%d&amp;#39;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
encoded&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>echo &lt;span style="color:#e6db74">&amp;#34;https://twitter.com/search?q=from:&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>argv[$i-1]&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74"> since:&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>yesterday&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">_00:00:00_JST until:&lt;/span>&lt;span style="color:#e6db74">${&lt;/span>yesterday&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">_23:59:59_JST&amp;amp;src=typed_query&amp;amp;f=live&amp;#34;&lt;/span> | ruby -r uri -ne &lt;span style="color:#e6db74">&amp;#39;print URI.encode $_.chomp&amp;#39;&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
open $encoded
&lt;span style="color:#66d9ef">done&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>以下のように実行すると、@hogeさんと@fugaさんと@piyoさんの昨日のTweetだけがそれぞれ検索結果のページとして開く。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sh" data-lang="sh">$ ./tw.sh hoge fuga piyo
&lt;/code>&lt;/pre>&lt;/div>&lt;p>Twitterの中毒性は、未読を消化するべく無限に見てしまうことだと思う。
この検索結果のページでは過去にスクロールできないため、やめ時が明確になる点が良い。
今のところはうまくいっていると思う。&lt;/p>
&lt;p>検索クエリは&lt;a href="https://scrapbox.io/june29/">29box&lt;/a>を参考にしました。ありがとうございます。&lt;/p></description></item><item><title>2021</title><link>https://blog.monochromegane.com/blog/2021/12/29/2021/</link><pubDate>Wed, 29 Dec 2021 16:03:57 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2021/12/29/2021/</guid><description>&lt;p>2021年は、自分の研究テーマとひたすら向き合った年となった。
昨年10月より博士後期課程に在学していることもあり、まずは1本国際会議に通すべく、自身の提案手法の改善、評価と従来手法との比較分析を、1年間ひたすら続けていた。
研究の進捗の節目ごとに投稿していた国際会議は、残念ながら3回投稿して全てリジェクトとなってしまったが、これらのフィードバックや方式の改善の結果、論文の質や提案手法の性能はこの1年間で随分上がったのではないかと思う。&lt;/p>
&lt;p>実際に、これらの進捗を議論すべく報告した、国内の2回の研究会では3つの賞を受賞することができ、客観的にも、自分の研究テーマとの向き合ってきた結果が出てきていると思える。
昨年度の受賞は、優秀プレゼンテーション賞という発表の分かりやすさの側面が強かったが、今年は、それに加え、座長や運営委員による選定という、より内容に踏み込んだ評価の上での受賞であり、非常に嬉しかったし、国際会議挑戦を継続するにあたって励みになった。&lt;/p>
&lt;p>来年は引き続き国際会議への挑戦と研究の発展を進めたい。
そのために、結果に一喜一憂せずに淡々と継続することを心がけていく。
また、手法改善の基盤となる数学的な能力向上や先行研究のサーベイは一過性ではなく計画的に長期的に取り組めるような枠組みを作り上げたい。
加えて、来年度は、個人のみの研究の位置付けからもう少し視座を高め、例えば研究所の取り組みと各研究員の研究、会社のサービスやビジョンとの関係性などから、方針や行動を見定め、それらに向かって導いたり知ってもらえるような振る舞いなど、今よりも先を見通し、今よりも大きく影響を与えることも意識していきたい。&lt;/p>
&lt;p>2022年からは、支えてくれる周りの人にも、恩返しだったり良い影響を与えることをできるようになりたいと思う。
来年もよろしくお願いします。&lt;/p>
&lt;h1 id="実績">実績&lt;/h1>
&lt;p>以下、実績を列挙する。&lt;/p>
&lt;h2 id="表彰">表彰&lt;/h2>
&lt;p>2021年は2つの研究会で3つの賞を受賞できた。
聴講者だけでなく運営委員や座長による評価をいただけるような研究を継続的に出せるようになっていることは素直に嬉しい。
また、研究所の共著論文でも2つの賞を受賞しており、研究所全体の盛り上げにも貢献できてよかったと思う。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.sigwi2.org/prev-awardlist">ARG 第17回Webインテリジェンスとインタラクション研究会 優秀研究賞&lt;/a>, 三宅 悠介, 峯 恒憲, 仮想的な探索を用いて文脈や時間の経過による番狂わせにも迅速に追従する多腕バンディット手法, 2021年12月.&lt;/li>
&lt;li>&lt;a href="https://sites.google.com/view/sig-macc/smash/smash21-summer-symposium">SMASH21 Summer Symposium 優秀賞&lt;/a>, 三宅 悠介, 峯 恒憲, Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム, 2021年9月.&lt;/li>
&lt;li>&lt;a href="https://sites.google.com/view/sig-macc/smash/smash21-summer-symposium">SMASH21 Summer Symposium 奨励賞&lt;/a>, 三宅 悠介, 峯 恒憲, Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム, 2021年9月.&lt;/li>
&lt;/ul>
&lt;h2 id="論文">論文&lt;/h2>
&lt;p>招待講演1本、研究報告2本。
実際には国際会議3回投稿、投稿中の国内ジャーナル1本があり、体感的な執筆量は例年と変わらない程度であったと思う。
また、研究報告のラストオーサーを2本、国内査読付き論文と国際会議（ワークショップ）論文でそれぞれ1本づつ共著を務めた。&lt;/p>
&lt;ol>
&lt;li>三宅 悠介, 峯 恒憲, &lt;a href="https://www.sigwi2.org/d_library">仮想的な探索を用いて文脈や時間の経過による番狂わせにも迅速に追従する多腕バンディット手法&lt;/a>, ARG Webインテリジェンスとインタラクション研究会 第17回研究会予稿集, No.17, pp.19-24, Dec 2021. &lt;a href="https://rand.pepabo.com/papers/wi2-17-miyakey.pdf">[論文]&lt;/a> &lt;a href="https://speakerdeck.com/monochromegane/wi2-lkf-bandits">[発表資料]&lt;/a>&lt;/li>
&lt;li>三宅 悠介, 峯 恒憲, &lt;a href="http://id.nii.ac.jp/1001/00212709/">Synapse: 文脈と時間経過に応じて推薦手法の選択を最適化するメタ推薦システム&lt;/a>, 研究報告知能システム（ICS）, Vol.2021-ICS-204, No.9, pp.1-8, Sep 2021. &lt;a href="https://rand.pepabo.com/papers/smash21-miyakey.pdf">[論文]&lt;/a> &lt;a href="https://speakerdeck.com/monochromegane/smash21-synapse">[発表資料]&lt;/a>&lt;/li>
&lt;li>三宅 悠介, 栗林 健太郎, &lt;a href="https://tsys.jp/dicomo/2021/program/program_abst.html#8A-1">(招待講演) なめらかなシステムと運用維持の未来&lt;/a>, マルチメディア，分散，協調とモバイル（DICOMO2021）シンポジウム論文集, 2021, p.1509, Jun-Jul 2021.&lt;a href="https://rand.pepabo.com/papers/dicomo2021-miyakey.pdf">[論文]&lt;/a> &lt;a href="https://speakerdeck.com/monochromegane/dicomo2021-coherently-fittable-system">[発表資料]&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="国内発表">国内発表&lt;/h2>
&lt;p>技術イベント、研究会での発表をそれぞれ1回（学会の研究会、シンポジウムを除く）。
今年はFukuoka.goもWSAも開催が少なかったこともあり、随分控えめになってしまった。
来年はもう少し機会を見つけて登壇していきたい。&lt;/p>
&lt;ol>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/fukoukago17-go-code-embedding">go:embedでExplainable Binaryを作る&lt;/a>, &lt;a href="https://fukuokago.connpass.com/event/202570/">Fukuoka.go#17(オンライン開催)&lt;/a>, 2021年6月.&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/">非定常な多腕バンディット問題において効率的に変化を察知する方式の検討&lt;/a>, &lt;a href="https://wsa.connpass.com/event/207143/">Web System Architecture 研究会 (WSA研) #8&lt;/a>, 2021年6月.&lt;/li>
&lt;/ol>
&lt;h2 id="oss">OSS&lt;/h2>
&lt;p>Fukuoka.go用に書いたツールが1本。
先行研究の実装など随分とコードは書いている気がするので研究とOSSもうまくつないでいきたいところ。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/monochromegane/go-code-embedding">go-code-embedding&lt;/a> A tool to embed Go source code into binary using go:embed.&lt;/li>
&lt;/ul>
&lt;h2 id="コミュニティ活動">コミュニティ活動&lt;/h2>
&lt;p>今年よりこれまでのFukuoka.goに加え、学会系の活動も手伝うようになった。
具体的には研究会の運営委員への就任に伴う運営従事の他、査読、座長、シンポジウムのプログラム委員などを務めた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://fukuokago.connpass.com/event/202570/">Fukuoka.go#17 (オンライン開催)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iot.ipsj.or.jp/">情報処理学会 インターネットと運用技術研究会 運営委員 就任&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.iot.ipsj.or.jp/symposium/iots2021/">第14回 インターネットと運用技術シンポジウム（IOTS 2021）プログラム委員&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="ブログ">ブログ&lt;/h2>
&lt;p>2本。昨年までに比べるとかなり少なめだが、研究の進め方シリーズとして集中的サーベイは研究所のみんなに紹介するなど役立ったと思う。
このような手探りからやり方に昇華できたものは今後もブログにまとめていきたい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/">非定常な多腕バンディット問題において効率的に変化を察知する方式の検討&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2021/05/15/survey-method/">研究の位置づけを明確にする集中型の論文サーベイ方法&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>非定常な多腕バンディット問題において効率的に変化を察知する方式の検討</title><link>https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/</link><pubDate>Tue, 08 Jun 2021 10:52:04 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2021/06/08/wsa8-predictive-exploratory-model/</guid><description>&lt;p>このエントリは、&lt;a href="https://wsa.connpass.com/event/207143/">第8回 Web System Architecture 研究会 (WSA研)&lt;/a>の予稿です。&lt;/p>
&lt;h1 id="非定常な多腕バンディット問題において効率的に変化を察知する方式の検討">非定常な多腕バンディット問題において効率的に変化を察知する方式の検討&lt;/h1>
&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>適応的なシステムの実現には、利用者と情報システムが互いの状態をよく理解するためのコミュニケーションと、それに応じた振る舞いの変更が必要となる。
一方で、そのコミュニケーションから得られる情報や利益の価値を考慮しなければならない環境では、確実な情報に基づく振る舞いを選択しつつ、まだ得られていない情報を引き出すために、価値の低いコミュニケーションを敢行しなければならない。&lt;/p>
&lt;p>これは、多腕バンディット問題として定式化できる。
多腕バンディット問題では、振る舞いの選択肢のことを腕と呼び、ある時点までの情報をもとに有効な腕を選択することを「活用」、腕の可能性を探るために有効ではない腕を選択することを「探索」と呼ぶ。
それぞれの腕はある確率分布に従い報酬を生成する。
中でも、選択肢の相対的な有効性が時間経過とともに変化する問題設定は非定常な多腕バンディット問題と呼ばれ、いくつかの解法が提案されている。&lt;/p>
&lt;p>非定常な多腕バンディット問題に対する解法には、腕の有効性の変化に応じた評価の更新が重要とされてきた。
しかしながら、選択による機会損失の低減を目的とした多腕バンディット問題の設定では、ある時点で有効性の低い選択肢が利用される機会は少なく、腕の有効性の変化を察知する、それ自体がまず難しい。&lt;/p>
&lt;p>本研究では、このような非定常な多腕バンディット問題における変化を素早く察知するにあたり、探索による機会損失を抑制した、効率的な方式を検討する。
なお、多腕バンディット問題の設定は、同時に文脈付きの問題設定に拡張することができるが、課題の本質は同じであること、方式検討の容易性から、本方向では文脈の考慮は行わない。&lt;/p>
&lt;h2 id="非定常な多腕バンディット問題の解法における変化察知の課題">非定常な多腕バンディット問題の解法における、変化察知の課題&lt;/h2>
&lt;p>非定常な多腕バンディット問題への解法では、腕の報酬分布が変化した際に、過去に観測した報酬に捉われずに腕の評価を迅速に更新しなくてはならない。
この問題の解法には大きく4つのアプローチがある。
一つ目は、腕の報酬分布が変化することを前提にして、観測時点からの経過に応じて腕の評価に重み付けをするアプローチである（減衰型）。
二つ目も、同様の前提において、新しく観測した報酬から一定の期間のみの情報で報酬分布を評価する（ウィンドウ型）。
三つ目は、腕の報酬分布の変化を契機として、腕を再評価するものである（変化検出型）。
このアプローチでは、変化検出の手法を用いて腕の報酬の変化を検出し、変化前の観測を取り除くことで、新しく観測された報酬を重視する。
これは変化検出による可変のウィンドウ型とみなすこともできる。
四つ目は、現時点の腕の評価を継続的に推定するものである。
このアプローチでは、腕の状態として状態空間モデルを仮定し、カルマンフィルタや粒子フィルタを推定に用いる。&lt;/p>
&lt;p>これらの全てのアプローチは、変化後の報酬分布から得られる報酬のサンプルを一定数必要とする。
選択による機会損失の低減を目的とした多腕バンディット問題の設定では、ある時点で評価の高い腕を最も多く活用する。
そのため、評価の高い腕が、ある時点で有効性が低くなるようなケースでは、十分な報酬のサンプルを観測することができ、各アプローチは有効に働く。
反対に、評価の低かった腕が、ある時点で有効性が高くなるケースでは、その腕に対する報酬のサンプルを得るまでに時間が掛かり、機会損失の発生に繋がると考えられる。
例えば、ECサイトの推薦アルゴリズムのコールドスタートのような、一定の嗜好情報が蓄積されることでその有効性を増すような選択肢がある場合に、この問題が発生する。&lt;/p>
&lt;p>この問題に直接挑んだ先行研究[1][2]では、いずれもなんらかの非定常な多腕バンディットの解法に従い腕の選択を行うが、一定の割合で、ランダムに腕を選択することで、腕の選択の偏りの解消を試みている。
また、上述のアプローチのうち、報酬の観測数の上限を変化させるような、減衰型、ウィンドウ型、変化検出型でも、間接的に腕の選択の偏りが緩和される。
なぜなら、多くの多腕バンディットの解法では、観測数の少なさを評価の不確かさと捉え、探索を促すからである。&lt;/p>
&lt;p>これらの探索を増やすアプローチは、トレードオフが発生する。
すなわち、相対的な腕の評価が逆転しない期間では、その期間中の探索が機会損失につながってしまう。
そのため、評価の低い腕の有効性の変化を素早く察知できるよう探索を行いつつ、その探索に伴う機会損失を減らすことが求められる。&lt;/p>
&lt;h2 id="非定常な多腕バンディット問題の解法における効率的な変化察知の方式の検討">非定常な多腕バンディット問題の解法における、効率的な変化察知の方式の検討&lt;/h2>
&lt;p>本研究では、評価の低い腕に対する変化の察知について、素早さと機会損失低減の観点を両立させるため、この探索行為を多腕バンディット内の多腕バンディットとみなす。
そして、この多腕バンディット内の多腕バンディットの評価基準に、腕の不安定性と、将来性を採用することで、探索時の機会損失低減を目指す。&lt;/p>
&lt;p>本報告では、先行研究の一定の割合で実施される探索行為を対象として機会損失の改善を目指す。
すなわち、腕の選定の比率が同一となるようなランダム選定ではなく、腕の不安定性と将来性を基準に、腕の選定の比率を変化させる。
提案手法では、腕の不安定性と将来性を扱うために、獲得報酬の時系列予測を行う。
時系列予測には、将来性の変化を扱えるよう少なくともトレンド成分を扱うことができ、不安定性を扱えるよう予測の幅も扱えるようなモデルが望ましい。
そこで、これらを満たすベイズ型統計モデルを採用する。
扱う報酬の形式により、カルマンフィルタや粒子フィルタを選択可能である。
探索には、各腕でn時点先の評価を予測値と信用区間に基づき腕の不安定性と将来性が高い腕を選定する。
予測値が将来性、信用区間の広さが不安定性に該当する。
なお、これらのモデルでは時系列予測の時点が進むにつれ、その信用区間が広がっていくことから、無限の将来を想定した腕の選定では、先行研究と同じ振る舞いになると考えられる。&lt;/p>
&lt;h2 id="評価">評価&lt;/h2>
&lt;p>カルマンフィルタベースの提案方式のコンセプト実装し、トイ・シミュレーションで機会損失を抑えられることを評価した。&lt;/p>
&lt;h3 id="シミュレーション設定">シミュレーション設定&lt;/h3>
&lt;p>評価環境として、腕の数が3、1000回の試行において、期間中に有効性の最も低かった腕が最も高くなるよう設定した。
なお、このシミュレーションでは、先行研究における一定数の割合の探索の試行のみを取り出したことを想定している。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/1845486/120578001-10a3b200-c460-11eb-83f6-d9b4d703125b.png" alt="plot_true_reward">&lt;/p>
&lt;h3 id="評価方法">評価方法&lt;/h3>
&lt;p>そして、以下のそれぞれの方式に対して、機会損失を抑える性能と変化を素早く察知する性能を評価した。&lt;/p>
&lt;ul>
&lt;li>random: ランダムな探索（予測できない未来を想定）ε-Greedy(ε=1.0)&lt;/li>
&lt;li>epsilon: 現在の情報に基づく探索（予測できない未来を想定）ε-Greedy(ε=0.1)&lt;/li>
&lt;li>state model: 予測に基づく探索（予測できる未来を想定）ε-Greedy(ε=0.1)だが活用時はカルマンフィルタによる100期先予測の値で選定する&lt;/li>
&lt;/ul>
&lt;p>なお、本報告の提案手法のコンセプト実装では、将来性のみを扱い、不安定性の考慮はできていない。&lt;/p>
&lt;p>本評価では、機会損失を抑える性能を、累積リグレットの低さによって評価する。
本報告で、累積リグレットとは、各時点での最適な腕から得られる期待報酬額と方策が選定した腕から得られた報酬額の差の合計のことを指す。
また、変化を素早く察知する性能を、腕の真の有効性が切り替わった時点以降で新しい最適な腕を選択した回数が一定数を超えるまでの期間の短さによって評価する。&lt;/p>
&lt;p>なお、準備期間の関係上、シミュレーションは複数回行っていないため、変動する可能性がある。&lt;/p>
&lt;h3 id="機会損失を抑える性能の評価">機会損失を抑える性能の評価&lt;/h3>
&lt;p>各方式の累積リグレットの推移を下図に示す。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/1845486/120577990-0e415800-c460-11eb-9521-bc81e83b2f38.png" alt="plot_cum_regret">&lt;/p>
&lt;p>均等に腕を選択するrandomではおおよそ線形にリグレットが増加する。
epsilonでは、変化前のリグレットの増加は抑えられるが、変化後には追従が遅れ、リグレットが大きく増加した。
これは、腕の選定の偏りによって探索が十分に行えないことと、過去データにひきづられて腕の評価の更新が遅れていることから発生していると考えられる。&lt;/p>
&lt;p>提案のstate modelでは、シミュレーション初期にrandomと同じ程度のリグレットの増加が確認された。
これは、予測に基づく活用が精度が低かったことに起因する。
50時点以降は予測が安定することで、リグレットの増加がepsilonと同等になった。
そして、変化後であっても、リグレットの増加が抑えられていることが確認できる。
これは、予測によって、将来性がある探索すべき腕を決定し、評価の更新をいち早く行えたためである。&lt;/p>
&lt;h3 id="変化を素早く察知する性能の評価">変化を素早く察知する性能の評価&lt;/h3>
&lt;p>切り替わり後の最適な腕を選択した累積回数の推移を下図に示す。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/1845486/120577999-10a3b200-c460-11eb-8798-e56325190308.png" alt="plot_sampled_new_arm">&lt;/p>
&lt;p>均等に腕を選定するrandomではおおよそ線形に腕が選定される。
本研究の課題設定では、この増加より大きいことが望まれる。
epsilonでは、腕の有効性の変化に追従できず、ε-Greedyの探索割合に応じた増加にとどまった。
これは、腕の選択肢が増加するほど、探索が行われない可能性が増すことも示している。
提案のstate modelでは、予測によって、将来性がある探索すべき腕を決定し、該当の腕に対する探索がrandomと比べて多く行われた。
これにより、変化の察知が素早く進むことが期待できる。&lt;/p>
&lt;p>腕の有効性の変更に対する、提案方式の100時点先の予測を下図に示す。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/1845486/120577996-0f728500-c460-11eb-963f-63cf25f17038.png" alt="plot_predicted_reward">&lt;/p>
&lt;p>本評価のシミュレーション設定は非常に単純なものであったため、予測がおおよそ正しかったことがわかる。&lt;/p>
&lt;h2 id="まとめ">まとめ&lt;/h2>
&lt;p>本報告では、非定常な多腕バンディットにおける変化の察知の課題を整理し、腕の不安定性と将来性に着目した予測型の多腕バンディット方策を提案した。
将来性を考慮可能なコンセプト実装では、シミュレーションにおいて、累積リグレットを抑えた素早い変化察知の可能性が示唆された。
今後はコンセプト実装に、不安定性の考慮を組み込むこと、そのためにε-Greedyではなくトンプソンサンプリングをベースにした手法との統合を進めたい。
また、文脈を考慮した場合での実装とシミュレーションの拡張を行う。
加えて、探索割合自体を環境の変化の度合いに応じて変動させる方式も検討する。&lt;/p>
&lt;h2 id="参考文献">参考文献&lt;/h2>
&lt;ul>
&lt;li>[1] Fang Liu, Joohyun Lee, and Ness Shroff. 2018. A change-detection based framework for piecewise-stationary multi-armed bandit problem. In Proceedings of the AAAI Conference on Artificial Intelligence, Vol. 32.&lt;/li>
&lt;li>[2] Yang Cao, Zheng Wen, Branislav Kveton, and Yao Xie. 2019. Nearly optimal adaptive procedure with change detection for piecewise-stationary bandit. In The 22nd International Conference on Artificial Intelligence and Statistics. PMLR, 418–427.&lt;/li>
&lt;/ul>
&lt;h1 id="発表スライド">発表スライド&lt;/h1>
&lt;!-- raw HTML omitted -->
&lt;h1 id="発表を終えて">発表を終えて&lt;/h1>
&lt;!-- raw HTML omitted --></description></item><item><title>研究の位置づけを明確にする集中型の論文サーベイ方法</title><link>https://blog.monochromegane.com/blog/2021/05/15/survey-method/</link><pubDate>Sat, 15 May 2021 15:35:14 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2021/05/15/survey-method/</guid><description>&lt;p>博士課程に進学し、国際会議に論文を投稿した際に行った論文サーベイの流れやツールについてまとめておく。
今回のサーベイを行うにあたり、既存研究に対する自身の研究の位置づけを明らかにすることを目標とした。
すなわち、自身の提案がある程度カタチになっていることを前提とした集中的サーベイ方法である。&lt;/p>
&lt;h1 id="論文サーベイの流れ">論文サーベイの流れ&lt;/h1>
&lt;p>以下に行った工程を示す。&lt;/p>
&lt;ol>
&lt;li>会議名とキーワード検索による候補のリストアップ&lt;/li>
&lt;li>各候補のアブストラクトによる選定&lt;/li>
&lt;li>各候補の精読&lt;/li>
&lt;li>必要に応じて参考になる会議名、キーワード、参照論文を候補に追加&lt;/li>
&lt;li>候補がなくなるまで繰り返す&lt;/li>
&lt;/ol>
&lt;p>以降、各工程について利用したツールや工夫などを述べる。&lt;/p>
&lt;h1 id="1-会議名とキーワード検索による候補のリストアップ">1. 会議名とキーワード検索による候補のリストアップ&lt;/h1>
&lt;p>サーベイは十分な量の候補を必要とする。
自身の研究分野や貢献と完全に一致する論文は多くはないが、全くゼロではない。
もし多すぎるのであれば、自身の研究の貢献や目的が十分に掘り下げられていない可能性がある。
もしゼロであれば、自身の研究に有用性がないか、十分な調査ができていないかもしれない。
自身の研究を信じる我々は、いずれにせよ十分に候補を見つける必要がある。&lt;/p>
&lt;p>候補の選定には、&lt;a href="https://scholar.google.com/">Google Scholar&lt;/a>によるキーワード検索を用いる。
なるべく多くの論文を候補とするため、キーワードは関連しそうなキーワードを複数挙げて、ORで繋ぐと良い。
この時、指導教官からのアドバイスで会議名を絞って検索するようにした。
これは、検索クエリに &lt;code>source:SIGKDD&lt;/code> などと指定することで実現できる。&lt;/p>
&lt;p>そして、検索結果から以下の情報をリスト化する。&lt;/p>
&lt;ul>
&lt;li>Title&lt;/li>
&lt;li>Citiations&lt;/li>
&lt;li>URL&lt;/li>
&lt;li>Authors&lt;/li>
&lt;/ul>
&lt;p>おおよそ、Google Scholarではキーワードへの関連性が高いものから並べてくれているため、会議ごとに上位20-50本程度を候補とすれば十分であったように思える。&lt;/p>
&lt;p>リスト化にはGoogleスプレッドシートを利用した。後の工程のため、関連有無フラグとメモ欄をカラムとして追加する。&lt;/p>
&lt;p>なお、検索〜リスト作成は手動では面倒なので、スクリプトを用意した。&lt;/p>
&lt;h1 id="2-各候補のアブストラクトによる選定">2. 各候補のアブストラクトによる選定&lt;/h1>
&lt;p>1.でリストアップした候補について、精読すべきかの選定を行う。
なお、選定はアブストラクトのみで行うこと。
ここで、個別に精読を始めると時間がいくらあっても足りないからである（逆に言えば自身の研究もやはりアブストラクトに提案と貢献をしっかり記述する必要がある）。&lt;/p>
&lt;p>選定基準は自身の研究や提案、貢献に関連がありそうかとする。
また、いくつか読んでいく中で判断基準が徐々に形成されていくので、効率よく見直せるよう、メモを書いておく。
メモには、どういう提案や手法かを一行程度書けば良い。
精読すべきと判断したものには、リストに丸をつけ、フィルタなり色付けして候補を見つけやすくしておく。&lt;/p>
&lt;h1 id="3-各候補の精読">3. 各候補の精読&lt;/h1>
&lt;p>2.で選定した精読候補を読み、まとめる。
多くの論文を読まなければならないこと、最終的に自分の研究との相対的な位置づけを整理する必要があるため、効率よく見直せるようまとめを残す必要がある。
まとめがないと何度も同じ論文をイチから読み直す必要があるので絶対にまとめること。
以下にまとめの観点とこれを実現するツールについて示す。&lt;/p>
&lt;h2 id="まとめの観点">まとめの観点&lt;/h2>
&lt;p>まとめの粒度や項目が統一されていることが望ましい。
自分は、&lt;a href="https://www.slideshare.net/Ochyai/1-ftma15/">落合メソッド&lt;/a>をアレンジして使っている。
つまり、自分の研究の位置づけを整理するのに適した問いかけにしている。&lt;/p>
&lt;ul>
&lt;li>どんなもの？&lt;/li>
&lt;li>先行研究と比べてどこがすごい？（どんな課題を解決する？）&lt;/li>
&lt;li>技術や手法のキモはどこ？（どうやって解決した？）&lt;/li>
&lt;li>どうやって有効だと検証した？&lt;/li>
&lt;li>議論はある？（自分の研究との差異は？）&lt;/li>
&lt;li>次に読むべき論文は？（他に知らなかった技術や概念は？）&lt;/li>
&lt;/ul>
&lt;p>括弧内が自分用の問いかけである。
特に、「議論はある？」を「自分の研究との差異は？」に置き換えることで位置付けの整理を強く意識したまとめができるようになった点が気に入っている。&lt;/p>
&lt;h2 id="まとめのためのツール">まとめのためのツール&lt;/h2>
&lt;p>これまで論文管理には、&lt;a href="https://www.mendeley.com/">Mendeley&lt;/a>を利用し、&lt;a href="https://www.papershipapp.com/">PaperShip&lt;/a>と同期、必要に応じてiPadで書き込みを行っていた。&lt;/p>
&lt;p>しかしながら、今回まとめには&lt;a href="https://www.notion.so/">Notion&lt;/a>を別途利用した。
Notionは、論文への直接書き込みの場合の、十分な余白がない点や論文同士の関係性を横串で把握しにくかった点を解消してくれる。
Notionで、上述のアレンジ版落合メソッドを含んだテンプレートを用意し、サーベイDATABASEに論文ごとに1ページ作り、読みながらまとめを作っていく。&lt;/p>
&lt;p>この時、最初からまとめようとすると論文全体を覚えておかなくてはならないので、自由に記入可能なメモ欄を用意して、読みながら、そちらにわかったこと疑問に思ったことなどを気楽に書いて、最後にまとめる方法をとっている。
メモ欄も残したままにしておくと後から読み直した時に記憶が蘇りやすいのでそのまま残している。&lt;/p>
&lt;p>また、Notionでは各ページに対してPropertyを付与することで絞り込みができるため、会議名タグ、論文の発行年度、論文のURL、その論文を読んだ日付、キーワードのタグをPropertyとして設定している。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2021/05/notion_survey_template.png" alt="notion-survey-template">&lt;/p>
&lt;h1 id="4-必要に応じて参考になる会議名キーワード参照論文を候補に追加">4. 必要に応じて参考になる会議名、キーワード、参照論文を候補に追加&lt;/h1>
&lt;p>精読の中で、気になる会議名、キーワードが追加された場合、もう一度、1.の検索に戻り候補を追加する。
また、参照されている論文も候補に追加する。&lt;/p>
&lt;p>コツとしては、追加された候補に対してすぐにアブストや精読を始めずに、候補として追加に止める事。
この追加した候補はまた新しい候補を増やすので、ゴールが見えなくなってしまうからである。
なので、最初に決めた候補まで読み切ってから、新しい候補の処理に着手すると気分的に進捗感が出て楽であった（これはまあ人による）。&lt;/p>
&lt;h1 id="5-候補がなくなるまで繰り返す">5. 候補がなくなるまで繰り返す&lt;/h1>
&lt;p>以上を候補がなくなるまで繰り返す。
参考文献が参考文献を呼んで終わらないのではないかと思われたが、2-3周もすれば新しい文献も出てこなくなってくる。
まとめの中で自身の研究が位置付けられてくるので、そこを一旦の止め時とした。&lt;/p>
&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>国際会議への投稿にあたって、自身の研究の位置づけを明確にするための論文サーベイの方法をまとめた。
今回は、最初のリストが243本、精読が47本であった。
会議を分けてサーベイすることで会議ごとに同じキーワードでも論文に特色があることなどが分かり興味深かった。
また、トップカンファレンスに限ることで、サーベイ効率も高まったと思う。
指導教官に感謝である。&lt;/p>
&lt;p>Notion上の47ページの論文まとめは執筆中、何度も読み直したが自分なりのまとめメモが入っていること、自分の研究との位置づけが一言でまとめられていることから、効率よく記憶が蘇らせることができた。
結果として、複数の論文同士の関係性を整理するという目標に自身のリソースを采配することができたと思う。&lt;/p>
&lt;p>一方で、キーワード検索では、既読管理と相性が悪いため、普段のインプットとしての継続的なサーベイには向かない。
RSSフィード的なインプットの方法を探したい。&lt;/p></description></item><item><title>2020</title><link>https://blog.monochromegane.com/blog/2020/12/31/2020/</link><pubDate>Thu, 31 Dec 2020 11:47:04 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/12/31/2020/</guid><description>&lt;p>今年は、なんと言っても、6月の初めてのジャーナル論文採録が文句なしに一番嬉しかった出来事だった。
ペパボ研究所に入って3年半。
本当に長かったし苦しかった。
それでもこの期間にたくさん自分自身や研究と向き合うことで、多くのものを得ることができたと思う。
今は、ただただ「巨人の肩に乗ることから逃げずに真摯に向き合い一歩づつ精進して」いる。&lt;/p>
&lt;p>10月には、博士後期課程に挑戦し、無事に入学することができた。
12月のインターネットと運用技術シンポジウムではジャーナル論文の研究を発展させる手法が採録され、優秀プレゼンテーション賞も受賞することができた。
来年は国際会議に挑戦する。&lt;/p>
&lt;p>長い暗中模索を抜けたが、スタートラインにやっと立てたとも言える。
遅れを取り戻すことを動機とはしないが、2021年は、可能な限り、適切な粒度で継続的に分野への貢献を出していきたい。
また、その貢献を通して周りの人へ直接的間接的に良い影響を与えたいと思う。&lt;/p>
&lt;p>そのためにも、習慣と計画をうまく使い、仕組みによって淡々と自分を駆動していきたい。
2020年は1月末からリモートワークに完全移行したが、毎朝の論文読み会によって生活リズムが崩れることはなく研究に取り組めた。
毎日の業務後に進めるよう計画していた、大学基礎数学の参考書は、微分積分、線形代数、確率統計を一通りこなすことができた。
一方で、研究開発において、習慣と計画は適用が難しいと感じている。
研究には終わりがないため、どこまでの試行錯誤を区切りとするのか判断がつきにくい。
また、アイディアは無限にあるため、いろいろなことをやりたくなり、優先順位の判断がつきにくい。
つまり、全体をブレイクダウンしてルーティーンに落とし込むところに苦労している。
ここに関しては、研究日誌のような短期のアウトプットに加えて、もう少しだけ長い視点での判断をする機会を計画や習慣として組み込んでいきたい。
まずは、その観点でも指導教官や研究所のみんなにも相手になってもらおう。&lt;/p>
&lt;p>2020年は光が見えた年だった。
2021年からは、この成果を普段から出せるよう、そして一つ上を目指せるようにしていこうと思う。
そして、その成果から行動の意義が伝わるような良い影響を与えられるようになりたいと思う。
来年もよろしくお願いします。&lt;/p>
&lt;h1 id="実績">実績&lt;/h1>
&lt;p>以下、実績を列挙する。&lt;/p>
&lt;h2 id="表彰">表彰&lt;/h2>
&lt;p>2020年は2回の表彰があった。
コミュニティ活動と研究活動の両面で表彰をいただくことができて、非常に嬉しい。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://www.iot.ipsj.or.jp/awards/symposium/">IOTS2020 優秀プレゼンテーション賞&lt;/a>, 三宅 悠介, 栗林 健太郎, 変化検出と要約データ構造を用いた利用者の嗜好の変化に迅速に追従する多腕バンディット手法, 2020年12月.&lt;/li>
&lt;li>&lt;a href="https://efc.fukuoka.jp/information/3116">エンジニアフレンドリーシティ福岡アワード コミュニティ部門&lt;/a>, 三宅 悠介,小田 知央, Fukuoka.go, 2020年1月.&lt;/li>
&lt;/ul>
&lt;h2 id="論文">論文&lt;/h2>
&lt;p>国内ジャーナル論文1本、査読付き論文1本。研究報告については第一著者のものが1本。
また、今年は研究報告のラストオーサーを2本務めた。&lt;/p>
&lt;ol>
&lt;li>三宅 悠介, 峯 恒憲, &lt;a href="https://search.ieice.org/bin/summary.php?id=j103-d_11_764">Synapse: 文脈に応じて継続的に推薦手法の選択を最適化する推薦システム&lt;/a>, 電子情報通信学会論文誌D, Vol.J103-D, No.11, pp.764-775, Nov 2020.&lt;/li>
&lt;li>三宅 悠介, 栗林 健太郎, &lt;a href="http://id.nii.ac.jp/1001/00208105/">変化検出と要約データ構造を用いた利用者の嗜好の変化に迅速に追従する多腕バンディット手法&lt;/a>, インターネットと運用技術シンポジウム論文集, 2020, pp.1-8, Nov 2020. &lt;a href="https://speakerdeck.com/monochromegane/iots2020-adaptive-linear-mab">[発表資料]&lt;/a>&lt;/li>
&lt;li>三宅 悠介, 栗林 健太郎, &lt;a href="http://id.nii.ac.jp/1001/00206029/">非定常な多腕バンディット問題における変化検出アプローチの線形モデルへの拡張&lt;/a>, 研究報告インターネットと運用技術（IOT）, Vol.2020-IOT-50, pp.1-8, July 2020.&lt;a href="http://localhost:4567/papers/iot50-miyakey.pdf">[論文]&lt;/a> &lt;a href="https://speakerdeck.com/monochromegane/extension-of-change-detection-method-for-non-stationary-linear-multi-armed-bandit">[発表資料]&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="国内発表">国内発表&lt;/h2>
&lt;p>技術イベント、研究会での発表で計６回（学会の研究会、シンポジウムを除く）。
Fukuoka.go、WSA研究会といったお馴染みのところに加え、GMOのテックカンファレンス、エンジニアフレンドリーシティ福岡のような声をかけていただいた登壇もあり、バランスは良かったと思う。
来年は、国際カンファレンス登壇が最初の目標だが、国内でも参加したことがない技術カンファレンスや勉強会なども挑戦してみたい。&lt;/p>
&lt;ol>
&lt;li>三宅 悠介 &lt;a href="https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/">嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討&lt;/a>, &lt;a href="https://wsa.connpass.com/event/187128/">Web System Architecture 研究会 (WSA研) #7&lt;/a>, 2020年11月.&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/coherently-fittable-system">なめらかなシステムの実現に向けて&lt;/a>, &lt;a href="https://www.gmo.jp/developersday/">GMO Developers Day 2020&lt;/a>, 2020年7月. [&lt;a href="https://youtu.be/KW-YKuM1ndI">動画&lt;/a>]&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/fukuokago-stage">Go言語でシミュレーション用のシンプルなフレームワークStageをつくった&lt;/a>, &lt;a href="https://fukuokago.connpass.com/event/180414/">Fukuoka.go#16(オンライン開催)&lt;/a>, 2020年7月.&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/wsa6-sifter">軽量なインデックス機構を用いた全文検索ツールの高速化の検討&lt;/a>, &lt;a href="https://websystemarchitecture.hatenablog.jp/entry/2019/12/11/165624">Web System Architecture 研究会 (WSA研) #6&lt;/a>, 2020年4月.&lt;/li>
&lt;li>三宅 悠介 &lt;a href="https://speakerdeck.com/monochromegane/fukuokago15-adwin-exphist">Adaptiveなウィンドウを求めて 〜サーベイと実装 Go言語編〜&lt;/a>, &lt;a href="https://fukuokago.connpass.com/event/164350/">Fukuoka.go#15 + 鹿児島Gophers(オンライン開催)&lt;/a>, 2020年3月.&lt;/li>
&lt;li>三宅 悠介, 田中 孝明, 白石 憲正, 浜崎 陽一郎, 松口 健司 &lt;a href="https://efc.fukuoka.jp/information/2562#day2_7">トークセッション / エンジニアと企業が描く未来のかたち&lt;/a>, &lt;a href="https://efc.fukuoka.jp/information/2562">エンジニアフレンドリーシティ福岡フェスティバル&lt;/a>, 2020年2月.&lt;/li>
&lt;/ol>
&lt;h2 id="oss">OSS&lt;/h2>
&lt;p>変化検出の手法をはじめ、シミュレーションのフレームワークなど研究開発で取り組む分野の実装が増えてきた。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/monochromegane/adwin-v">ADWIN-V&lt;/a>: ADWIN-V is an adaptive windowing algorithm for vector data.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/stage">stage&lt;/a>: Simple and flexible simulation framework for Go.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/sifter">sifter&lt;/a>: A lightweight index for full text search tools using bloom filter.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/adwin">adwin&lt;/a>: Adwin is an adaptive windowing algorithm.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/exponential-histograms">exponential-histograms&lt;/a>: Exponential histograms is a data structure for sliding windows.&lt;/li>
&lt;li>&lt;a href="https://github.com/monochromegane/random_multivariate_normal">random_multivariate_normal&lt;/a>: Random number generator from a multivariate normal distribution.&lt;/li>
&lt;/ul>
&lt;h2 id="コミュニティ活動">コミュニティ活動&lt;/h2>
&lt;p>昨年度の活動や昨今の状況でのオンラインでの活動が評価され、表彰やインタビューを受ける機会をいただき非常にありがたいことであった。
一方で、Fukuoka.go自体の活動実績は2回と例年に比べかなり少なめであった。
オンライン開催での主催者側のモチベーションをどう維持するかも課題である。&lt;/p>
&lt;ul>
&lt;li>小田 知央,三宅 悠介,清家 史郎 &lt;a href="https://efc.fukuoka.jp/interview/3704">勉強会はパーティーだ! ビール片手に楽しくGo言語を学ぶコミュニティ「Fukuoka.go」&lt;/a>, &lt;a href="https://efc.fukuoka.jp/interview">ENGINEER INTERVIEW - Engineer Friendly City Fukuoka&lt;/a>, 2020年8月.&lt;/li>
&lt;li>&lt;a href="https://fukuokago.connpass.com/event/180414/">Fukuoka.go#16 (オンライン開催)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://fukuokago.connpass.com/event/164350/">Fukuoka.go#15 + 鹿児島Gophers(オンライン開催)&lt;/a>&lt;/li>
&lt;li>三宅 悠介,小田 知央 &lt;a href="https://dayori.city.fukuoka.lg.jp/129892/">エンジニアの技術向上に取り組むコミュニティ･企業を表彰 エンジニアフレンドリーシティ福岡アワード&lt;/a>, &lt;a href="https://dayori.city.fukuoka.lg.jp/">福岡市政だより&lt;/a>, 2020年3月.&lt;/li>
&lt;/ul>
&lt;h2 id="ブログ">ブログ&lt;/h2>
&lt;p>13本。結果だけでなく、どうしてその考えに至ったかなど、その経緯、考えをまとめるカタチの文章をいくつか出すことができた。特に論文執筆のエントリのような自分なりのまとめは定期的に書いていきたいと思う。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/">嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/10/14/pen-tablet/">ペンタブレットでリモートワークのコミュニケーションを改善する&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/09/23/structure-of-research-paper/">構造を意識した抜け漏れがなく主張点が明確な論文執筆&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/09/21/isee-kyushu-u/">九州大学大学院システム情報科学府博士後期課程に入学します&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/06/28/my-first-journal/">ペパ研から研究をはじめてジャーナルでのアクセプトまでいけた日&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/05/31/simulation-framework-stage/">Go言語でシミュレーション用のシンプルなフレームワークStageをつくった&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/05/16/bandit-algorithm-ucb1/">多腕バンディット問題におけるUCB方策を理解する&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/04/29/why-fukuokago/">なぜ勉強会「だった」のか&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/04/29/wsa6_sifter/">軽量なインデックス機構を用いた全文検索ツールの高速化の検討&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/03/11/dynamic-gamma-poisson/">Dynamic Gamma-Poisson modelを試す&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/03/03/minimum-start-for-online-event/">勉強会をオンライン配信するための必要最小限な環境構築&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/01/30/memo-getting-start-reinformation-learning-algorithm/">『強化学習アルゴリズム入門』第1章〜第2章の学習メモ&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.monochromegane.com/blog/2020/01/26/exhalation-and-coherently-fittable-system/">テッド・チャン『息吹』と「なめらかなシステム」&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討</title><link>https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/</link><pubDate>Tue, 17 Nov 2020 10:46:53 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/11/17/wsa7-local-preference/</guid><description>&lt;p>このエントリは、&lt;a href="https://wsa.connpass.com/event/187128/">第7回 Web System Architecture 研究会 (WSA研)&lt;/a>の予稿です。&lt;/p>
&lt;h1 id="嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討">嗜好伝達コミュニケーションの効率化を目指した伝達方式の検討&lt;/h1>
&lt;h2 id="はじめに">はじめに&lt;/h2>
&lt;p>適応的なシステムの実現には、システムが利用者の状況をよく知ることが重要になる。
ECサイトのシステムであれば、利用者の嗜好を把握することで、最適な商品を提案できると考えられる。&lt;/p>
&lt;p>ECサイトのシステムが利用者の嗜好を把握するためには、特に初期段階における利用者との一定量のコミュニケーションが必要となる。
明示的なコミュニケーションであれば、システムは利用者に、年齢や居住地、興味関心などのプロファイルの登録を依頼する。
暗黙的なコミュニケーションであれば、システムは利用者の、閲覧や購買、検索履歴を通して利用者の嗜好を把握する。
システムはこれらのプロファイルの登録や履歴の蓄積なくして、適応的に振舞うことが難しい。
一方で、これらのコミュニケーションは利用者に負担を強いる。
これには、システムごとに発生するプロファイルの登録や履歴蓄積のための労力的な負担の他、プライバシーを守りたいという意識的な負担も考えられる。&lt;/p>
&lt;p>本研究では、利用者の嗜好伝達に纏わるコミュニケーションの負担を低減しつつ、適応的なシステムによる利便性を常に享受できるインターネット世界に向けて、嗜好伝達コミュニケーションの効率化のための伝達方式の検討を行う。&lt;/p>
&lt;h2 id="嗜好伝達コミュニケーションの課題">嗜好伝達コミュニケーションの課題&lt;/h2>
&lt;p>嗜好伝達コミュニケーションの課題整理にあたり、本研究における「嗜好」を定義する。
まず、嗜好(preference)とは「利用者の素性(feature)」に基づく「対象(content)への反応(reaction)」と考える。&lt;/p>
&lt;pre tabindex="0">&lt;code>preference(feature,content) #=&amp;gt; reaction
&lt;/code>&lt;/pre>&lt;p>対象(content)はシステムごと（ECサイトごと）に異なるため、嗜好伝達にはシステムごとに個別のコミュニケーションが求められる。
利用者の素性(feature)を示すか、直接、対象(content)への反応(reaction)を示す行為がこれに該当する。
推薦システムでは、利用者の素性(feature)を示す場合、類似する素性の群の反応を用いて利用者の嗜好が推測される。
対象(content)への反応(reaction)を示す場合、この反応から、もしくは類似する群から利用者の嗜好が推測される。&lt;/p>
&lt;p>本研究では、この、利用者の素性(feature)の伝達か、対象(content)への反応(reaction)の伝達に纏わるコミュニケーションの効率化を検討する。&lt;/p>
&lt;h3 id="利用者の素性featureの伝達の課題">利用者の素性(feature)の伝達の課題&lt;/h3>
&lt;ol>
&lt;li>システム内に限定された利用者の素性&lt;/li>
&lt;li>適切なデータ構造が不明&lt;/li>
&lt;li>プライバシー保護が必要&lt;/li>
&lt;/ol>
&lt;p>「1. システム内に限定された利用者の素性」について、利用者の素性(feature)には人口統計的な情報だけでなく、行動データが考えられる。
利用者の素性をより知るためには、システムを横断して蓄積された行動データを得られることが望ましい。
しかしながら、通常、システムの把握可能な履歴はシステム内に限定される。
オンライン広告に見られるアドネットワークやオーディエンスデータの利用により、横断した行動を特定できる。
しかしながら、これらのcookieなどを用いた名寄せに関してはプライバシー保護意識の高まりもあり、代替手段を検討すべきである（要リファレンス）。&lt;/p>
&lt;p>「2. 適切なデータ構造が不明」について、利用者の素性(feature)となり得る要因は無限に検討可能なことから、これを全てのシステムで共通に管理することは困難である。
例えば、訪問したサイトを利用者の素性として扱うとして、多次元のベクトルデータで表現すると、各次元とサイトの紐付けやサイトの追加削除を管理しなければならない。&lt;/p>
&lt;p>「3. プライバシー保護が必要」について、人口統計的な情報だけでなく、行動データを含む利用者の素性は多くのセンシティブな情報を含むことから、利用者側が開示するにあたって内容の制限が求められるであろう。&lt;/p>
&lt;h3 id="対象contentへの反応reactionの伝達の課題">対象(content)への反応(reaction)の伝達の課題&lt;/h3>
&lt;ol>
&lt;li>システム内に限定された利用者の嗜好&lt;/li>
&lt;li>プライバシー保護が必要&lt;/li>
&lt;/ol>
&lt;p>「1. システム内に限定された利用者の嗜好」について、前述の通り、プロファイルの登録や履歴蓄積のための労力的な負担が発生する。
対象(content)はシステム内に限定されるため、システムごとにその反応を提示しなければならない。
この時、利用者の嗜好をより知るためには、できるだけ多くの対象(content)に対する反応(reaction)を示せることが望ましいが、労力的な負担は比例して増加する。&lt;/p>
&lt;p>「2. プライバシー保護が必要」について、利用者の嗜好傾向は（素性と比較して間接的ではあるものの）センシティブな情報を含むことから、利用者側が開示するにあたって内容の制限が求められるであろう。&lt;/p>
&lt;h2 id="嗜好伝達コミュニケーションの効率化の検討">嗜好伝達コミュニケーションの効率化の検討&lt;/h2>
&lt;h3 id="利用者の素性featureの伝達の効率化">利用者の素性(feature)の伝達の効率化&lt;/h3>
&lt;p>本研究では、利用者の素性(feature)の伝達の効率化のため、人口統計的な情報だけでなく、システムを横断した行動データを局所管理するアプローチを検討する。
無限に検討可能な要因を共通して扱うため、Key-Value形式のデータ構造を採用する。
また、システムへの提示時に、このKey-Value形式のデータをBloomFilterに変換することでプライバシー保護を試みる。
すなわち、BloomFilterの偽陽性に着目した素性であるKeyを断定することができない特性を利用する。
また、BloomFilterが保存する要素数に依存しない特性を利用して、無限に検討可能な利用者の素性の要因を固定次元で扱うことができる。&lt;/p>
&lt;p>なお、あるシステムに提示されるBloomFilterのパラメータは全ての利用者が同じものを用いる必要があるが、これらの共有方式についてはここでは検討しない。&lt;/p>
&lt;h3 id="対象contentへの反応reactionの伝達の効率化">対象(content)への反応(reaction)の伝達の効率化&lt;/h3>
&lt;p>本研究では、対象(content)への反応(reaction)の伝達の効率化のため、嗜好モデルを局所管理するアプローチを検討する。
提案手法では、システムを横断した行動データから、嗜好モデルを構築するローカルエージェントを設ける。
構築される嗜好モデルはこれまでの行動データから、未知の対象(content)への反応(reaction)を精度よく推測する。
ローカルエージェントは、このモデルを使い、システムに対する対象(content)への反応(reaction)の伝達を代理する。
具体的には、利用者が新しいシステムへのアクセスする際に、（システムが対応していれば）この嗜好モデルを使って、先方のシステムから示された大量の対象(content)への反応(reaction)を回答する。
先方のシステムは、十分な量のコミュニケーションを終え、利用者に利便性の高い状態から利用を開始してもらうことができる。
また、予めローカルエージェントの嗜好提示範囲に制限を持たせておくことで、プライバシー管理も行えると考える。&lt;/p>
&lt;p>なお、これらの方式は検討段階であり、ローカルエージェント、嗜好モデルの具体的な実装はこれから検討していく。&lt;/p>
&lt;h2 id="評価">評価&lt;/h2>
&lt;h3 id="利用者の素性featureの伝達の効率化の評価">利用者の素性(feature)の伝達の効率化の評価&lt;/h3>
&lt;p>提案手法の有効性を判断するため、BloomFilterに変換した素性によって嗜好情報の伝達能力を評価した。
評価として、素性を特徴量として用いた多腕バンディットのシミュレーションを行った。
元の素性と比較して提案手法の素性で、どの程度精度に変化があったかを確認した。&lt;/p>
&lt;p>以下は、腕の数が30、密度（＊後述）10倍の実験設定の時の、BloomFilterの次元数と精度の変化を表している。
ここで、精度の変化とは、元の素性を使ったシミュレーションで選定された腕と同じ腕を選定できた割合を言う。&lt;/p>
&lt;pre tabindex="0">&lt;code>1: 1.0
2: 0.60425
3: 0.424515
4: 0.38845
5: 0.35002
6: 0.32798
7: 0.335945
8: 0.307885
9: 0.31443
10: 0.317955
20: 0.311235
30: 0.3068
40: 0.320385
50: 0.30193
60: 0.31655
70: 0.33412
80: 0.319935
90: 0.309365
100: 0.33812
&lt;/code>&lt;/pre>&lt;p>BloomFilterで表現された素性をコンテキスト情報として用いた推定には誤差が生じる。
そして、この誤差の増加はBloomFilterの偽陽性率の増加に従う。
今回の問題設定では、例えば100次元のバイナリベクトルを50次元のBloomFilterで表現することである（このような状態を本研究では密度2倍と考える）。
また、多腕バンディットでは腕の本数の増加に従い、不確実な状況において偶然当たる確率が下がる。
これらを考慮して、100次元のコンテキスト情報を10次元へ圧縮、30本の腕という問題設定でベストな腕を選択できた割合をサンプリングによって求めた。
結果として正しい腕を選択できたのは33%程度であった。
現実の推薦システムにおいてあり得る程度のスケールでも精度に対して大きな影響が発生することがわかった。&lt;/p>
&lt;h3 id="対象contentへの反応reactionの伝達の効率化の評価">対象(content)への反応(reaction)の伝達の効率化の評価&lt;/h3>
&lt;p>今後、実装と評価を行っていく。&lt;/p>
&lt;h1 id="発表スライド">発表スライド&lt;/h1>
&lt;!-- raw HTML omitted -->
&lt;p>発表後の議論では、アプローチに対する新規性や有用性について、また、Webサービスへの適用のアイディアについても話すことができ、今後にとって非常に有意義なものとなった。&lt;/p>
&lt;h1 id="発表を終えて">発表を終えて&lt;/h1>
&lt;p>今回のWSA研では、最初のアプローチの失敗で終わらず、やりたいことに立ち返り、より良いと思われるアプローチも検討できた点が良かったと思う。
長期間続く研究であればこそ、個々の結果に一喜一憂ではなく全体として進んでいけるよう全てを糧にしていきたい。&lt;/p>
&lt;p>そして、このような研究のアイディア段階から前向きに意見を出し合うことができる機会を定期的に設けることができるWSA研はとても良いコンセプトの研究会だと思う。
何よりその時間はとても楽しい。&lt;/p>
&lt;p>Webシステムアーキテクチャに関する運用知見を研究的アプローチで前進させること興味がある方は次回開催の参加を検討してみてはいかがでしょうか。&lt;/p>
&lt;!-- raw HTML omitted --></description></item><item><title>ペンタブレットでリモートワークのコミュニケーションを改善する</title><link>https://blog.monochromegane.com/blog/2020/10/14/pen-tablet/</link><pubDate>Wed, 14 Oct 2020 20:47:32 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/10/14/pen-tablet/</guid><description>&lt;p>リモートワークが続く中、口頭での説明を補足するため電子ホワイトボードなどを使ったコミュニケーションの機会が増えています。
一方で、手書きの気軽さに追従できないマウスを使っていると、書くより口頭での説明の方が早いと電子ホワイトボードを使わずにすましてしまうこともありました。&lt;/p>
&lt;p>しかしながら手書きの表現力を生かしたコミュニケーションは捨て難く、ペン型の入力装置を探していました。
iPadは入力装置としても優れていますが、他にも活躍する場面が多いこと、連携時にも一手間かかることから、常時接続できる据置型のシンプルな入力装置としてペンタブレット（いわゆる板タブ）を導入しました。
今のところ、快適に利用できているので、簡単にご紹介します。&lt;/p>
&lt;h2 id="機材">機材&lt;/h2>
&lt;p>家にあった&lt;a href="https://www.amazon.co.jp/gp/product/B013SMIUDU/ref=as_li_tl?ie=UTF8&amp;amp;camp=247&amp;amp;creative=1211&amp;amp;creativeASIN=B013SMIUDU&amp;amp;linkCode=as2&amp;amp;tag=monochromeg03-22&amp;amp;linkId=fe1ce71c51452d4f2aeb9e54b37e1ed5">ワコム Intuos Comic&lt;/a>を使っています。&lt;/p>
&lt;!-- raw HTML omitted -->
&lt;p>僕の用途であればSサイズ（210x169mm。ただし入力領域はこのうち155x95mm程度）で十分でした。
こちらはUSB(Type-A)でPCと接続します。すでに旧モデルとのことで、これから購入するならBluetoothで接続できる新しいものが良さそうです。&lt;/p>
&lt;p>また、接続先のPCはMacBook Pro (15-inch, 2019) です。
macOS Catalinaですが、ワコムのサイトに公開されている最新のドライバをインストールした上で、「セキュリティとプライバシー」で必要なアプリケーションに許可を与えることで利用できるようになりました。&lt;/p>
&lt;h2 id="設定">設定&lt;/h2>
&lt;p>後述しますが、タブレットの座標検出は絶対位置の指定です。
小さいタブレットに大きな画面をマッピングして使うのは向いていないため、画面内の限られた範囲をマッピングして利用しています。&lt;/p>
&lt;p>僕の用途では電子ホワイトボードとしてJamboardを利用しており、画面内の決まった位置（左上）で扱うため、この範囲をタブレットの操作範囲としました。
これによってJamboardの表示範囲とタブレットの入力領域がある程度同じになり、違和感なく入力できるようになりました。&lt;/p>
&lt;p>ワコムのタブレットの場合、以下のように設定できます。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2020/10/wacom-config.png" alt="wacom">&lt;/p>
&lt;h2 id="タブレットの操作">タブレットの操作&lt;/h2>
&lt;p>普段の業務は、キーボードとマウスで済むため、タブレットは初めて利用でした。
そのため、操作に慣れるまで少しだけ戸惑いましたが、以下のサイトを見て、基本を理解しました。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://tablet.wacom.co.jp/article/%E3%83%9A%E3%83%B3%E3%82%BF%E3%83%96%E3%83%AC%E3%83%83%E3%83%88-%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E4%BD%BF%E3%81%84%E6%96%B9">ペンタブレット 基本的な使い方&lt;/a>&lt;/li>
&lt;/ul>
&lt;p>以下だけ理解すればすんなり使えると思います。&lt;/p>
&lt;ul>
&lt;li>ペンをタブレットから浮かした状態でポインタを移動&lt;/li>
&lt;li>ペンをタブレットにつけるとクリックしながらポインタを移動することに相当&lt;/li>
&lt;li>タブレットの操作領域が画面にマッピングされている&lt;/li>
&lt;/ul>
&lt;h1 id="まとめ">まとめ&lt;/h1>
&lt;p>Google MeetからJamboardを開いて参加者にリンクを共有できるようになり、便利になりました。
利用までの手間を小さくできるよう、常時接続型のシンプルなタブレットを導入することで、Jamboardを積極的に利用することができ、手書きの気軽さと表現力を活かしたコミュニケーションの改善につながっていると感じます。&lt;/p>
&lt;p>今後改善したいところとしては、ペンのボタンへのアクション割り当てなのですが、Jamboardの消しゴムやレーザーポインタ切り替えにショートカットがなく、まだ実現できていない状態です（フィードバック送ろう）。&lt;/p>
&lt;p>まだまだリモートワークも続くでしょうから、引き続き、入力機器の構成や工夫など進めていきたいと思います。&lt;/p></description></item><item><title>構造を意識した抜け漏れがなく主張点が明確な論文執筆</title><link>https://blog.monochromegane.com/blog/2020/09/23/structure-of-research-paper/</link><pubDate>Wed, 23 Sep 2020 13:36:25 +0900</pubDate><guid>https://blog.monochromegane.com/blog/2020/09/23/structure-of-research-paper/</guid><description>&lt;h1 id="はじめに">はじめに&lt;/h1>
&lt;p>研究者は、自身の研究の有用性を主張するため論文を発表する。
しかしながら、研究の有用性を主張するために、抜け漏れがなく主張点が明確な文章を書くのは、慣れないうちは難しい（慣れても難しい）。
本エントリでは、論文の構造を見出だす工程とその構造を書き下す工程を明示的に分離することで、抜け漏れがなく主張点が明確な論文執筆を行う方法を検討する。&lt;/p>
&lt;h1 id="論文執筆の課題">論文執筆の課題&lt;/h1>
&lt;p>前述の通り、研究の有用性を主張するために、抜け漏れがなく主張点が明確な文章を書くのは、慣れないうちは難しい。
これは、主張の整理と文章の生成を頭の中で同時にやろうとしていることが原因であるように思う。&lt;/p>
&lt;p>第一に、主張の整理は複雑なタスクである。
研究の有用性の主張は、いくつかの課題や提案、評価といった複数の要素と、要素同士の関係性のあり方、すなわち「構造」を持つ。
要素やその関係性の増加に伴い、構造は複雑になるため、頭の中だけで網羅しつつ整合性を取り続けるのは困難である。&lt;/p>
&lt;p>第二に、主張の構造を文章に落とし込むのは複雑なタスクである。
文章は連続した文から構成され、逐次的に記述される。
そのため、要素同士の関係性を含む主張の構造を書き下すためには、文同士の局所的な繋がりに加え、段落や接続詞による大局的な繋がりを表現しなければならない。
頭の中の主張の構造を余さずに正確に文章へと変換するのは困難である。
主張の構造が明らかでない段階では尚更である。&lt;/p>
&lt;h1 id="抜け漏れがなく主張点が明確な論文を書く">抜け漏れがなく主張点が明確な論文を書く&lt;/h1>
&lt;p>論文執筆が難しい理由は、主張の構造を見出だすこと、この構造を文章に落とし込むことという複雑なタスクを同時に行うためだと解釈した。
そこで、これらのタスクを明示的に分離する方法を考える。
この時、主張の構造を見出だすタスクの成果物を文章としてしまっては、主張の構造を文章に落とし込むタスクを兼ねてしまう。
主張の構造を見出だすタスクには必要な要素を文単位で表し、これらの関係性を表現できる形式が望ましい。
本エントリでは、このタスクをつなぐ中間表現を論文ストラクチャーと名付ける。
提案する論文ストラクチャーを以下に示す。&lt;/p>
&lt;p>&lt;img src="https://blog.monochromegane.com/images/2020/09/research_paper_structure.jpeg" alt="structure">&lt;/p>
&lt;p>提案する論文執筆では、この論文ストラクチャーを埋めていく工程と、論文ストラクチャーをもとに主張を文章に落とし込む工程を繰り返すことで執筆を行う。&lt;/p>
&lt;h2 id="主張の構造を見出だす論文ストラクチャーを埋める">主張の構造を見出だす（論文ストラクチャーを埋める）&lt;/h2>
&lt;p>以下、埋めるべき内容について簡単に説明する。
はじめに②と⑤から主張を明確にし、その主張をストーリー立てて仕上げるよう残りの項目を埋めていくと良い。
なお、③④⑥はリスト形式かつ対応づけを行えるため、ストーリー内の根拠の抜け漏れを防ぐことができる。&lt;/p>
&lt;h3 id="-やりたいこと">② やりたいこと&lt;/h3>
&lt;p>⑤と合わせて、&lt;strong>主張を明確にするために重要な要素&lt;/strong>。
リサーチクエスチョンとして、何を解決したいのか、達成したいのかを一文で述べる。&lt;/p>
&lt;p>システム・ソフトウェア開発の論文では、提案手法によって、どのような理想の世界に近づくのかを示す。&lt;/p>
&lt;ul>
&lt;li>例）実行環境の変化に素早く適応する &lt;!-- raw HTML omitted -->[*1]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>例）文脈に応じて継続的に推薦手法の選択を最適化する &lt;!-- raw HTML omitted -->[*2]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;/ul>
&lt;h3 id="-やったこと">⑤ やったこと&lt;/h3>
&lt;p>②と合わせて、&lt;strong>主張を明確にするために重要な要素&lt;/strong>。
リサーチクエスチョンをどのようなアプローチ、着眼点をもって解決、達成したかを一文で述べる。&lt;/p>
&lt;p>システム・ソフトウェア開発の論文では、開発したシステムやソフトウェア、アーキテクチャなどの特徴を示す。&lt;/p>
&lt;ul>
&lt;li>例）恒常性を持つシステムアーキテクチャ（を提案・開発）&lt;!-- raw HTML omitted -->[*1]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;li>例）多腕バンディットを用いたメタ推薦システム（を開発）&lt;!-- raw HTML omitted -->[*2]&lt;!-- raw HTML omitted -->&lt;/li>
&lt;/ul>
&lt;h3 id="-なぜやりたいのか">① なぜ、やりたいのか&lt;/h3>
&lt;p>②への導入となる要素。
その研究の価値や意義を述べる。&lt;/p>
&lt;p>システム・ソフトウェア開発の論文では、提案手法によって、どうして、そのような理想の世界に近づけたいのかを示す。
世間一般的に解決すべき課題として位置付けるも良いし、これまで世間が気づけていなかったけれども見方を変えて課題として捉え直した、のようにしても良いと思う。&lt;/p>
&lt;h3 id="-なぜできないのか">③ なぜ、できないのか&lt;/h3>
&lt;p>②に対しての課題であり、⑤のアプローチへの導入となる要素。
理想となる世界に対しての（主に）技術的な課題を述べる。
多くの研究では、従来の研究成果で未解決、もしくは改善が必要とされる領域についてサーベイ結果が該当する。&lt;/p>
&lt;p>なお、ここは複数の要素が挙げられるため、論文ストラクチャー上は「A、B、C&amp;hellip;」とリスト形式で記述する。&lt;/p>
&lt;h3 id="-どうやって解決したのか">④ どうやって、解決したのか&lt;/h3>
&lt;p>③の複数の課題に対する個々の解決手段であり、⑤の詳細となる要素。
提案手法である⑤がどのような方法で課題を解決するのかを述べる。&lt;/p>
&lt;p>ここは対応づけを行うことでストーリー内での根拠の抜け漏れを防ぐことが目的であるため、③の個々の課題に対する解決手段を「A'、B'、C'&amp;hellip;」とリスト形式で記述する。&lt;/p>
&lt;h3 id="-本当にできたのか">⑥ 本当に、できたのか&lt;/h3>
&lt;p>③の課題を④の手法で解決できたことを示す要素。
評価とその結果を述べる。&lt;/p>
&lt;p>ここも対応づけによる抜け漏れを防ぐことが目的であるため、③④の個々の課題、手法に対する評価内容を「A''、B''、C''&amp;hellip;」とリスト形式で記述する。&lt;/p>
&lt;h2 id="構造を文章に落とし込む論文ストラクチャーから文章を作る">構造を文章に落とし込む（論文ストラクチャーから文章を作る）&lt;/h2>
&lt;p>論文ストラクチャーを埋めたら、各項目を使って論文の文章の雛形を作っていく。&lt;/p>
&lt;h3 id="タイトル">タイトル&lt;/h3>
&lt;p>②と⑤を組み合わせることは主張を端的に表現したタイトル案を作ることができる。
よく使われるパターンは「⑤を用いた②」「②が可能な⑤」などであろう。&lt;/p>
&lt;h3 id="概要">概要&lt;/h3>
&lt;p>①から⑥を順番に並べることで抜け漏れのない概要案を作ることができる。
典型的な例では以下のようにつながれる。&lt;/p>
&lt;ul>
&lt;li>①の状況になっている&lt;/li>
&lt;li>そのため②が求められている、必要となる&lt;/li>
&lt;li>一方で③A&amp;hellip;の課題がある&lt;/li>
&lt;li>本研究では⑤を提案する&lt;/li>
&lt;li>提案手法では④A'&amp;hellip;を用いて課題を解決した&lt;/li>
&lt;li>評価では⑤A''&amp;hellip;によって有効性を確認した&lt;/li>
&lt;/ul>
&lt;h3 id="1-はじめに">1. はじめに&lt;/h3>
&lt;p>概要と同じく①から⑥を順番に並べることで案を作ることができる。
ここでは、パラグラフのトピックセンテンスが論文ストラクチャーの各項目になるように配置し、各パラグラフに説明とリファレンスを追加していくと良い。&lt;/p>
&lt;h3 id="2-関連研究">2. 関連研究&lt;/h3>
&lt;p>③の各課題を単位とする節やパラグラフを並べることで案を作ることができる。
ここでは、各課題がなぜ発生するのか、解決できていないのかを説明するために、従来手法の説明を加えるのが一般的である。&lt;/p>
&lt;h3 id="3-提案手法">3. 提案手法&lt;/h3>
&lt;p>④の各手法を単位とする節やパラグラフを並べることで案を作ることができる。
ここでは、③との対応づけが明らかになるようにできるだけ順序を維持し、また対応する課題について明記すべきである。
また、⑤を用いて提案手法全体の概要と達成できる事柄について導入部分で触れておくと良い。&lt;/p>
&lt;h3 id="4-評価">4. 評価&lt;/h3>
&lt;p>⑥の各評価を単位とする節やパラグラフを並べることで案を作ることができる。
ここでも、③や④との対応づけが明らかになるようにできるだけ順序を維持し、また対応する課題、手法について明記すべきである。&lt;/p>
&lt;h3 id="5-まとめ">5. まとめ&lt;/h3>
&lt;p>②と⑤からリサーチクエスチョンとこれに対する提案をまとめる。
また、⑥の結果を踏まえ解決した③を明記する。
最後に研究を発展させるための今後の予定を述べる。&lt;/p>
&lt;h1 id="おわりに">おわりに&lt;/h1>
&lt;p>本エントリでは、抜け漏れがなく主張点が明確な論文執筆のために、論文執筆の複雑なタスクを分離し、主張の構造を見出だすタスクと、この構造を文章に落とし込むタスクという二つのタスクを交互に行う方式を提案した。
また、このために論文ストラクチャーと名付けた主張の構造の整理に適した表現形式を提案した。&lt;/p>
&lt;p>提案手法によって、論文の品質を一定に保ちつつ初稿までの執筆時間を短縮する。
加えて、論文ストラクチャーを通した研究成果共有によって共著者との早期の意思疎通が容易になり、手戻りを防ぐ効果が期待できる。&lt;/p>
&lt;p>あとは良い研究をするだけである（それもまた難しいのであった）。&lt;/p>
&lt;hr>
&lt;h3 id="参照">参照&lt;/h3>
&lt;ul>
&lt;li>*1: 松本 亮介, 近藤 宇智朗, 三宅 悠介, 力武 健次, 栗林 健太郎, FastContainer: 実行環境の変化に素早く適応できる恒常性を持つシステムアーキテクチャ, インターネットと運用技術シンポジウム2017論文集，2017，89-97（2017-11-30）, Nov 2017&lt;/li>
&lt;li>*2: 三宅 悠介, 峯 恒憲, Synapse: 文脈に応じて継続的に推薦手法の選択を最適化する推薦システム, 電子情報通信学会論文誌D, Vol.J103-D,No.11,pp.-,Nov. 2020. (to appear)&lt;/li>
&lt;/ul></description></item></channel></rss>